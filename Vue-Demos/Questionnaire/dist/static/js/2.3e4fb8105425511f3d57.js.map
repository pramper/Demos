{"version":3,"sources":["webpack:///static/js/2.3e4fb8105425511f3d57.js","webpack:///Data.vue","webpack:///./src/components/Data.vue?a9a7","webpack:///./src/components/Data.vue?2a40","webpack:///./src/components/Data.vue?0fb9","webpack:///./src/components/Data.vue","webpack:///./src/echarts.js"],"names":["webpackJsonp","15","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_echarts","_echarts2","data","typeMap","radio","checkbox","textarea","vuex","getters","questionnaire","state","currentQuestionnaire","questionnaireList","actions","setCurrentQuest","_ref","item","dispatch","route","_ref2","_this","this","to","next","id","params","questId","forEach","parseInt","directives","echarts","bind","self","vm","$nextTick","instance","init","el","update","newVal","oldVal","seriesData","option","type","selections","push","Math","random","grid","top","bottom","title","text","textAlign","yAxis","xAxis","series","radius","name","setOption","unbind","dispose","23","version","sources","names","mappings","file","sourcesContent","sourceRoot","27","content","locals","34","41","__vue_script__","__vue_template__","options","template","47","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","root","factory","apply","undefined","require","define","normalize","baseId","indexOf","basePath","split","namePath","baseLen","length","nameLen","cutBaseTerms","cutNameTerms","pathLoop","i","slice","concat","join","createRequire","localRequire","callback","cacheMods","getModExports","Array","getModsExports","ids","es","mod","mods","l","min","arg","Error","defined","factoryReturn","deps","zrUtil","event","method","registerVisual","curry","registerLayout","registerProcessor","barLayoutGrid","ecModel","eachSeriesByType","seriesModel","getData","setVisual","graphic","layout","extendComponentModel","layoutMode","ignoreSize","defaultOption","zlevel","z","show","target","subtext","subtarget","left","backgroundColor","borderColor","borderWidth","padding","itemGap","textStyle","fontSize","fontWeight","color","subtextStyle","extendComponentView","render","titleModel","api","group","removeAll","get","textStyleModel","getModel","subtextStyleModel","textBaseline","textEl","Text","style","textFont","getFont","fill","getTextColor","z2","textRect","getBoundingRect","subText","subTextEl","y","height","link","sublink","silent","on","window","open","add","groupRect","layoutOption","getBoxLayoutParams","width","layoutRect","getLayoutRect","getWidth","getHeight","x","attr","alignStyle","textVerticalAlign","setStyle","margin","getItemStyle","rect","Rect","shape","subPixelOptimizeRect","gridModel","coordinateSystem","getRect","defaults","registerPreprocessor","numberUtil","formatUtil","IntervalScale","intervalScaleProto","prototype","mathCeil","ceil","mathFloor","floor","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","a","lo","hi","mid","TimeScale","extend","getLabel","val","stepLvl","_stepLvl","date","Date","formatTime","niceExtent","approxTickNum","fixMin","fixMax","extent","_extent","Infinity","d","getFullYear","getMonth","getDate","niceTicks","interval","_interval","round","span","approxInterval","scaleLevelsLen","scaleLevels","idx","level","yearSpan","yearStep","nice","_niceExtent","parse","parseDate","each","methodName","call","create","createRegisterEventWithLowercaseName","eventName","handler","context","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","b","prio","themeStorage","_dom","_zr","zrender","renderer","devicePixelRatio","_theme","clone","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","_onframe","toggleHighlight","payload","_model","eachComponent","mainType","query","index","chartView","__viewId","__alive","invokeUpdateMethod","component","componentModel","__model","updateZ","eachSeries","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","__id","remove","splice","processData","process","func","stackSeriesData","stackedDataMap","stack","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","storage","elCount","traverse","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","stopAnimation","blendMode","canvasSupported","console","warn","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","action","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","off","one","mixin","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","notMerge","lazyUpdate","assert","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","log","getOption","getRenderedCanvas","pixelRatio","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","mathMax","max","MAX_NUMBER","right","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","createCanvas","img","Image","image","coordSysMgr","restoreData","isSingleCanvas","configLayer","clearColor","colorArr","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","cfg","isObject","hideLoading","loadingEffects","eventObj","actionWrap","actionInfo","updateMethod","payloads","batched","batch","map","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","shift","MOUSE_EVENT_NAMES","eveName","e","dataIndex","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","groupIdBase","DOM_ATTRIBUTE_KEY","dependencies","replace","isDom","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","isArray","disConnect","getInstanceByDom","key","getAttribute","getInstanceById","registerTheme","preprocessorFunc","priority","processorFunc","isNaN","registerAction","registerCoordinateSystem","CoordinateSystem","register","layoutFunc","visualFunc","registerLoading","loadingFx","superClass","extendSeriesModel","extendChartView","setCanvasCreator","creator","noop","List","Model","number","format","matrix","vector","util","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","Scale","scaleProto","mathPow","pow","mathLog","LogScale","base","getTicks","scale","setExtent","start","end","getExtent","unionExtent","quantity","err","abs","updateDataSelected","uid","hasAnimation","getName","selectedOffset","from","seriesId","toggleItemSelected","getItemGraphicEl","getItemLayout","isSelected","midAngle","startAngle","endAngle","dx","cos","dy","sin","offset","position","animate","when","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","Group","sector","Sector","Polyline","updateData","getLabelStyle","labelModel","labelPosition","isLabelInside","getItemVisual","opacity","retrieve","hostModel","getFormattedLabel","piePieceProto","firstCreate","animateTo","r","childAt","itemModel","getItemModel","sectorShape","label","setShape","updateProps","itemStyleModel","visualColor","useStyle","lineJoin","hoverStyle","ifEnableAnimation","_updateLabel","setHoverStyle","labelLine","labelText","labelLayout","points","linePoints","verticalAlign","font","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","stroke","getLineStyle","smooth","inherits","Pie","sectorGroup","_sectorGroup","oldData","_data","isFirstRender","onSectorClick","selectedMode","diff","piePiece","eachChild","child","setItemGraphicEl","newIdx","oldIdx","execute","count","removeClipPath","setClipPath","_createClipPath","cx","cy","clockwise","cb","clipPath","r0","initProps","PI","modelUtil","completeDimensions","dataSelectableMixin","PieSeries","superApply","arguments","legendDataProvider","_dataBeforeProcessed","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getInitialData","dimensions","initData","sum","getSum","percent","toFixed","$vars","defaultEmphasis","labelLineNormalOpt","normal","labelLineEmphasisOpt","emphasis","legendHoverLink","hoverAnimation","center","minAngle","avoidLabelOverlap","rotate","length2","lineStyle","itemStyle","animationEasing","seriesType","actionInfos","selected","subType","source","result","len","isBuildInObject","hasOwnProperty","merge","overwrite","targetProp","sourceProp","mergeAll","targetAndSources","overlay","document","createElement","getContext","_ctx","array","clazz","baseClazz","F","clazzPrototype","prop","constructor","isArrayLike","nativeForEach","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","args","nativeSlice","objToString","isFunction","isString","BUILTIN_OBJECT","nodeType","values","Function","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","toString","arrayProto","paletteScope","eachRawSeriesByType","dataAll","getRawData","idxMap","isSeriesFiltered","rawIdx","getRawIndex","filteredIdx","singleDataColor","setItemVisual","getColorFromPalette","parsePercent","PI2","RADIAN","size","unitRadian","roseType","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","dir","angle","setItemLayout","linearMap","legendModels","findComponents","filterSelf","isAxisUsedInTheGrid","axisModel","findGridModel","getLabelUnionRect","axis","labels","getFormattedLabels","step","labelCount","isLabelIgnored","singleRect","getTextRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","axesTypes","axisType","queryComponents","isCartesian2D","axisHelper","Cartesian2D","Axis2D","ifAxisCrossZero","niceScaleExtent","gridProto","_rect","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","inverse","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","axesCount","cartesian","addAxis","coordDimToDataDim","axesModels","xAxisModel","yAxisModel","componentIndex","grids","createListFromArray","coordSys","getMarkerPosition","pt","dataToPoint","getLayout","offsetIndex","getBaseAxis","NaN","brushSelector","barMinHeight","fixLayoutWithLineWidth","lineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","isUpdate","barBorderWidthQuery","enableAnimation","rectShape","animateProperty","animateTarget","baseAxis","hasValue","newIndex","oldIndex","_updateStyle","setLabel","labelPositionOutside","setText","textPosition","eachItemGraphicEl","getBarItemStyle","hoverLabelModel","rectStyle","getRawValue","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","valueAxisStart","dataToCoord","getGlobalExtent","coords","dataToPoints","setLayout","p","n","sign","lastCoord","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","doSingleLeaveHover","normalStl","removeHover","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","props","animatableModel","animationEnabled","getShallow","postfix","duration","animationDelay","pathTool","Path","Circle","Ring","Polygon","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","path","createFromString","aspect","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","labelColor","textDistance","textFill","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","elMap1","oldEl","newProp","boxLayout","orient","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","containerWidth","containerHeight","parseFloat","normalizeCssArray","verticalMargin","horizontalMargin","positionGroup","mergeLayoutParam","targetOption","opt","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","hasProp","copy","hNames","vNames","hResult","vResult","getLayoutParams","copyLayoutParams","_trim","str","RADIAN_EPSILON","domain","range","clamp","subDomain","subRange","all","match","precision","asc","arr","sort","getPrecision","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","isRadianAroundZero","ret","nf","exp10","f","textContain","addCommas","toCamelCase","group1","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","seriesLen","alias","k","s2d","M","h","getHours","getMinutes","s","getSeconds","capitalFirst","charAt","substr","truncateText","roundingErrorFix","thisExtent","other","getInterval","setInterval","ticks","safeLimit","tick","getTicksLabels","splitNumber","isFinite","reverse","expandSize","detect","ua","os","browser","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","chartInstance","echartsAPIList","mergeTheme","hasClass","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","types","makeKeyInfo","mapResult","idMap","existCpt","exist","determineSubType","keyInfo","idNum","newCptOption","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","parentModel","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","normalizeToArray","mappingToExists","dependentModels","resultItem","ComponentModelClass","optionUpdated","extraOpt","newCptTypes","componentOption","topologicalTravel","getAllClassMainTypes","isIdInner","getTheme","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","res","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","compare","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","indices","_coordinateSystems","coordinateSystemCreators","coordinateSystems","coordinateSystemCreator","colorPaletteMixin","visualColorAccessPath","mergeDefaultAndTheme","cloneShallow","getDefaultOption","LABEL_OPTIONS","fillDataTextStyle","newSeriesOption","getLinkedData","setData","coordDim","dataDimToCoordDim","dataDim","formatTooltip","multipleSeries","formatArrayValue","dimInfo","getDimensionInfo","dimType","formattedValue","colorEl","seriesName","scope","getAxisTooltipDataIndex","dataFormatMixin","getDependencies","getClassesByMainType","arrayPush","clazzUtil","componentUtil","$constructor","getUID","inputPositionParams","themeModel","isInit","optList","Class","__defaultOption","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","Component","componentProto","enableClassExtend","Chart","elSetState","childCount","dataIndices","indexOfName","chartProto","delInstance","guid","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","Ctor","rendererType","vml","handerProxy","getViewportRoot","stage","_needsRefresh","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","removeSelfFromZr","addSelfToZr","getId","addRoot","delRoot","zLevel","config","refresh","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","stop","arrySlice","_$handlers","_h","ctx","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","m1","m2","lerp","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","toHex","fastMapToColor","normalizedValue","colors","out","leftIndex","rightIndex","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","runHi","reverseRun","t","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","tmp","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Gradient","encodeColor","colorAccessPath","set","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","textColor","maskColor","mask","arc","lineCap","labelRect","animateShape","delay","ArrayCtor","Float32Array","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","ignoreParent","thisParentModel","isEmpty","setReadOnly","properties","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","transferProperties","_storage","originalStorage","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","hasItemOption","getDimension","nameList","dimValueGetter","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dataItem","dimName","dimIndex","getDataItemValue","isDataItemOption","converDataValue","dimStorage","stackedValue","getValues","dimData","dimExtent","rawIndex","indexOfRawIndex","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","dist","getRawDataItem","dims","dimSize","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","getVisual","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","distance","distanceSquare","negate","lengthSquare","distSquare","contain","OrdinalScale","getScaleExtent","originalExtent","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","minInterval","intervalScale","getCategories","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","tickCoord","intersect","labelFormatter","Cartesian","getAxesByScale","containPoint","point","axisX","axisY","containData","pointToData","coordToData","Axis","axisLabelInterval","coordExtent","getLabelInterval","labelInterval","_labelInterval","containLabel","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","c","ctlPtx","ctlPty","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","transformPath","rebuildPath","dirty","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","localPos","transformCoordToLocal","containStroke","dirtyPath","__clipTarget","loop","attrKV","Sub","extendFrom","defaultShape","thisShape","addColorStop","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addChildrenToStorage","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","lineHeight","measureText","textLines","fillText","strokeText","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","sx","sy","drawImage","moveTo","unitX","unitY","lineTo","closePath","roundRectHelper","polyHelper","smoothConstraint","pointAt","someVectorAt","isTangent","cpx2","cpy2","cubicDerivativeAt","cubicAt","cpx1","cpy1","quadraticDerivativeAt","quadraticAt","curveTool","vec2","quadraticSubdivide","cubicSubdivide","quadraticCurveTo","bezierCurveTo","tangentAt","globalCoord","paths","_updatePathDirty","beforeBrush","afterBrush","v2ApplyTransform","mathAbs","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","getTextWidth","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","textLineLen","adjustTextPositionOnRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","j","subLength","estimateLength","charCode","charCodeAt","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","createDataFormatModel","rawValue","rawDataIndex","itemOpt","componentSubType","formatter","exists","newCptOptions","cptOption","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","platform","fontFamily","fontStyle","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","curve","bbox","min2","max2","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","anticlockwise","arcTo","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","nPoint","mathAtan2","atan2","TYPE_DELIMITER","IS_CONTAINER","RootClass","proto","ExtendedClass","entity","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","o","hasSubTypes","originalExtend","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","rectContain","animateStyle","isAroundEqual","EPSILON","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","roots","y0_","y1_","nExtrema","unit","x_","cubicExtrema","windingQuadratic","quadraticRootAt","quadraticExtremum","y_","windingArc","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","line","excludes","getLineDash","lineType","rank","repeat","_canvasPattern","createPattern","getAreaStyle","gTextStyleModel","align","baseline","getBorderLineDash","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","maxValue","lastIndexOf","save","shadowColor","textShadowColor","restore","Transformable","Animatable","drift","decomposeTransform","beforeUpdate","afterUpdate","updateTransform","hide","animators","addAnimator","removeAnimator","dimAxisMapper","_axes","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","output","idStart","isNotAroundZero","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","transformCoordToGlobal","Animator","animatingShape","pathSplitted","animator","during","done","forwardToLast","easing","_animateToShallow","objShallow","propertyCount","DELIMITER","subTypeDefaulters","registerSubTypeDefaulter","defaulter","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","fixExtentWithBands","nTick","normalizedExtent","getTicksCoords","alignWithLabel","bands","getBands","getLabelsCoords","debugMode","defaultGetter","defaultSetter","interpolateNumber","p0","p1","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","getAxisType","axisDim","axisModelCreator","AxisModel","_resetRange","setRange","rangeStart","rangeEnd","extraOption","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","axisDefault","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","nameLocation","nameRotate","nameTruncate","nameTextStyle","nameGap","triggerEvent","tooltip","axisLine","axisTick","inside","axisLabel","splitLine","splitArea","areaStyle","categoryAxis","timeAxis","logAxis","logBase","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","isAroundZero","onet","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","ASqrt","THREE_SQRT","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","divider","quadraticProjectPoint","v2Create","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","_l","_a","_b","_s","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","pos","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","d0","cp0","r1","r2","r3","r4","total","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","makeEventPacket","eveType","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","setTimeout","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","addEventListener","GestureMgr","eventTool","removeEventListener","normalizeEvent","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","parentNode","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","overflow","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","imageLayer","stl","defaultView","getComputedStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","clientToLocal","clientX","clientY","isTouch","touch","targetTouches","changedTouches","detail","isDomLevel2","attachEvent","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","targetList","_selectTargetMap","targetMap","select","unSelect","toggleSelected","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","labelDirection","tickDirection","nameDirection","labelOffset","labelRotation","AxisBuilder","ifIgnoreOnTick","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","_splitLine","splitLineModel","lineStyleModel","lineColors","lineInterval","lineCount","ticksCoords","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","makeAxisEventDataBase","innerTextLayout","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","pt1","pt2","tickModel","tickLen","tickInterval","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","categoryData","textEls","itemTextStyleModel","labelBeforeFormat","targetType","firstLabel","nextLabel","lastLabel","prevLabel","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","rawTick"],"mappings":"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CA,GACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,OACA,IACA,IACA,GACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,GACA,GACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,UACA,EACA,EACA,IACA,GAEAC,UACA,EACA,IACA,IACA,GAEAC,eACA,IACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,EACA,IACA,EACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,EACA,IACA,GAEAC,gBACA,GACA,IACA,GACA,GAEAC,YACA,IACA,IACA,EACA,GAEAC,YACA,IACA,GACA,IACA,GAEAC,SACA,IACA,EACA,EACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,eACA,GACA,GACA,IACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,GACA,GACA,GACA,GAEAC,eACA,EACA,IACA,IACA,GAEAC,YACA,IACA,EACA,IACA,GAEAC,UACA,IACA,GACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,YACA,GACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,aACA,GACA,IACA,GACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,OACA,EACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,GACA,GAEAC,QACA,GACA,EACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,EACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,sBACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,eACA,GACA,IACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,gBACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,EACA,GAEAC,WACA,GACA,IACA,GACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,SACA,IACA,EACA,IACA,GAEAC,QACA,IACA,EACA,EACA,GAEAC,kBACA,IACA,IACA,IACA,GAEAC,YACA,EACA,EACA,IACA,GAEAC,cACA,IACA,GACA,IACA,GAEAC,cACA,IACA,IACA,IACA,GAEAC,gBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,IACA,IACA,GAEAC,mBACA,EACA,IACA,IACA,GAEAC,iBACA,GACA,IACA,IACA,GAEAC,iBACA,IACA,GACA,IACA,GAEAC,cACA,GACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,aACA,IACA,IACA,IACA,GAEAC,MACA,EACA,EACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,EACA,GAEAC,WACA,IACA,IACA,GACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,WACA,IACA,GACA,EACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,eACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,GACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,EACA,IACA,GAEAC,KACA,IACA,EACA,EACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,aACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,GACA,GAEAC,UACA,GACA,IACA,GACA,GAEAC,UACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,WACA,IACA,GACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,WACA,IACA,IACA,IACA,GAEAC,MACA,IACA,IACA,IACA,GAEAC,aACA,EACA,IACA,IACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,KACA,IACA,IACA,IACA,GAEAC,MACA,EACA,IACA,IACA,GAEAC,SACA,IACA,IACA,IACA,GAEAC,QACA,IACA,GACA,GACA,GAEAC,WACA,GACA,IACA,IACA,GAEAC,QACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,OACA,IACA,IACA,IACA,GAEAC,YACA,IACA,IACA,IACA,GAEAC,QACA,IACA,IACA,EACA,GAEAC,aACA,IACA,IACA,GACA,GAkWA,QACApzC,QACAyrB,OACAyd,QACAC,iBACAS,aACAE,YACAC,cACAx9B,eAGA1X,E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","file":"static/js/2.3e4fb8105425511f3d57.js","sourcesContent":["webpackJsonp([2,4],{\n\n/***/ 15:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _echarts = __webpack_require__(47);\n\t\n\tvar _echarts2 = _interopRequireDefault(_echarts);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    data: function data() {\n\t        return {\n\t            typeMap: {\n\t                radio: '',\n\t                checkbox: '',\n\t                textarea: ''\n\t            }\n\t        };\n\t    },\n\t\n\t    vuex: {\n\t        getters: {\n\t            questionnaire: function questionnaire(state) {\n\t                return state.currentQuestionnaire;\n\t            },\n\t            questionnaireList: function questionnaireList(state) {\n\t                return state.questionnaireList;\n\t            }\n\t        },\n\t        actions: {\n\t            setCurrentQuest: function setCurrentQuest(_ref, item) {\n\t                var dispatch = _ref.dispatch;\n\t\n\t                dispatch(\"SET_QUEST\", item);\n\t            }\n\t        }\n\t    },\n\t    route: {\n\t        data: function data(_ref2) {\n\t            var _this = this;\n\t\n\t            var to = _ref2.to;\n\t            var next = _ref2.next;\n\t\n\t            var id = to.params.questId;\n\t            if (!this.questionnaire) {\n\t                this.questionnaireList.forEach(function (item) {\n\t                    if (parseInt(item.id) === parseInt(id)) {\n\t                        _this.setCurrentQuest(item);\n\t                        return;\n\t                    }\n\t                });\n\t            }\n\t\n\t            next();\n\t        }\n\t    },\n\t    directives: {\n\t        'echarts': {\n\t            bind: function bind() {\n\t                var self = this;\n\t                this.vm.$nextTick(function () {\n\t                    self.instance = _echarts2.default.init(self.el);\n\t                });\n\t            },\n\t            update: function update(newVal, oldVal) {\n\t                var self = this;\n\t                var seriesData = [];\n\t                var option = {};\n\t\n\t                if (newVal.type !== 'textarea') {\n\t                    newVal.selections.forEach(function (item) {\n\t                        seriesData.push(parseInt(Math.random() * 100));\n\t                    });\n\t                    option = {\n\t                        grid: {\n\t                            top: 40,\n\t                            bottom: 25\n\t                        },\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        yAxis: {},\n\t                        xAxis: {\n\t                            data: newVal.selections\n\t                        },\n\t                        series: [{\n\t                            type: 'bar',\n\t                            data: seriesData\n\t                        }]\n\t                    };\n\t                } else {\n\t                    seriesData.push(parseInt(Math.random() * 100));\n\t                    seriesData.push(100 - seriesData[0]);\n\t                    option = {\n\t                        title: {\n\t                            text: self.vm.typeMap[newVal.type] + '.' + newVal.title,\n\t                            textAlign: \"left\"\n\t                        },\n\t                        series: [{\n\t                            type: 'pie',\n\t                            radius: \"60%\",\n\t                            data: [{ name: '', value: seriesData[0] }, { name: '', value: seriesData[1] }]\n\t                        }]\n\t                    };\n\t                }\n\t                this.vm.$nextTick(function () {\n\t                    self.instance.setOption(option);\n\t                });\n\t            },\n\t            unbind: function unbind() {\n\t                this.instance.dispose();\n\t            }\n\t        }\n\t    }\n\t};\n\n/***/ },\n\n/***/ 23:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/Data.vue\"],\"names\":[],\"mappings\":\"AAAA,0BAA0B,iBAAiB,iBAAiB,iBAAiB,CAAC,6BAA6B,kBAAkB,sBAAsB,iBAAiB,eAAgB,CAAC,wBAAwB,eAAe,sBAAsB,oBAAoB,CAAC,eAAe,gBAAgB,WAAW,aAAa,CAAC\",\"file\":\"Data.vue\",\"sourcesContent\":[\"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:bold}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 27:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(23);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(2)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 34:\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n/***/ },\n\n/***/ 41:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(27)\n\t__vue_script__ = __webpack_require__(15)\n\t__vue_template__ = __webpack_require__(34)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n\n/***/ 47:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(global) {(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object' && module.exports) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like environments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals (root is window)\n\t        root.echarts = factory();\n\t    }\n\t}(this, function () {var require, define;\n\t(function () {\n\t    var mods = {};\n\t\n\t    define = function (id, deps, factory) {\n\t        mods[id] = {\n\t            id: id,\n\t            deps: deps,\n\t            factory: factory,\n\t            defined: 0,\n\t            exports: {},\n\t            require: createRequire(id)\n\t        };\n\t    };\n\t\n\t    require = createRequire('');\n\t\n\t    function normalize(id, baseId) {\n\t        if (!baseId) {\n\t            return id;\n\t        }\n\t\n\t        if (id.indexOf('.') === 0) {\n\t            var basePath = baseId.split('/');\n\t            var namePath = id.split('/');\n\t            var baseLen = basePath.length - 1;\n\t            var nameLen = namePath.length;\n\t            var cutBaseTerms = 0;\n\t            var cutNameTerms = 0;\n\t\n\t            pathLoop: for (var i = 0; i < nameLen; i++) {\n\t                switch (namePath[i]) {\n\t                    case '..':\n\t                        if (cutBaseTerms < baseLen) {\n\t                            cutBaseTerms++;\n\t                            cutNameTerms++;\n\t                        }\n\t                        else {\n\t                            break pathLoop;\n\t                        }\n\t                        break;\n\t                    case '.':\n\t                        cutNameTerms++;\n\t                        break;\n\t                    default:\n\t                        break pathLoop;\n\t                }\n\t            }\n\t\n\t            basePath.length = baseLen - cutBaseTerms;\n\t            namePath = namePath.slice(cutNameTerms);\n\t\n\t            return basePath.concat(namePath).join('/');\n\t        }\n\t\n\t        return id;\n\t    }\n\t\n\t    function createRequire(baseId) {\n\t        var cacheMods = {};\n\t\n\t        function localRequire(id, callback) {\n\t            if (typeof id === 'string') {\n\t                var exports = cacheMods[id];\n\t                if (!exports) {\n\t                    exports = getModExports(normalize(id, baseId));\n\t                    cacheMods[id] = exports;\n\t                }\n\t\n\t                return exports;\n\t            }\n\t            else if (id instanceof Array) {\n\t                callback = callback || function () {};\n\t                callback.apply(this, getModsExports(id, callback, baseId));\n\t            }\n\t        };\n\t\n\t        return localRequire;\n\t    }\n\t\n\t    function getModsExports(ids, factory, baseId) {\n\t        var es = [];\n\t        var mod = mods[baseId];\n\t\n\t        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n\t            var id = normalize(ids[i], baseId);\n\t            var arg;\n\t            switch (id) {\n\t                case 'require':\n\t                    arg = (mod && mod.require) || require;\n\t                    break;\n\t                case 'exports':\n\t                    arg = mod.exports;\n\t                    break;\n\t                case 'module':\n\t                    arg = mod;\n\t                    break;\n\t                default:\n\t                    arg = getModExports(id);\n\t            }\n\t            es.push(arg);\n\t        }\n\t\n\t        return es;\n\t    }\n\t\n\t    function getModExports(id) {\n\t        var mod = mods[id];\n\t        if (!mod) {\n\t            throw new Error('No ' + id);\n\t        }\n\t\n\t        if (!mod.defined) {\n\t            var factory = mod.factory;\n\t            var factoryReturn = factory.apply(\n\t                this,\n\t                getModsExports(mod.deps || [], factory, id)\n\t            );\n\t            if (typeof factoryReturn !== 'undefined') {\n\t                mod.exports = factoryReturn;\n\t            }\n\t            mod.defined = 1;\n\t        }\n\t\n\t        return mod.exports;\n\t    }\n\t}());\n\tdefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('./pie/PieSeries');\n\t    require('./pie/PieView');\n\t    require('../action/createDataSelectAction')('pie', [\n\t        {\n\t            type: 'pieToggleSelect',\n\t            event: 'pieselectchanged',\n\t            method: 'toggleSelected'\n\t        },\n\t        {\n\t            type: 'pieSelect',\n\t            event: 'pieselected',\n\t            method: 'select'\n\t        },\n\t        {\n\t            type: 'pieUnSelect',\n\t            event: 'pieunselected',\n\t            method: 'unSelect'\n\t        }\n\t    ]);\n\t    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\t    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n\t    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\t});\n\tdefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    require('../coord/cartesian/Grid');\n\t    require('./bar/BarSeries');\n\t    require('./bar/BarView');\n\t    var barLayoutGrid = require('../layout/barGrid');\n\t    var echarts = require('../echarts');\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t    // In case developer forget to include grid component\n\t    require('../component/grid');\n\t});\n\tdefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n\t    'use strict';\n\t    var echarts = require('../echarts');\n\t    var graphic = require('../util/graphic');\n\t    var layout = require('../util/layout');\n\t    // Model\n\t    echarts.extendComponentModel({\n\t        type: 'title',\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 6,\n\t            show: true,\n\t            text: '',\n\t            target: 'blank',\n\t            subtext: '',\n\t            subtarget: 'blank',\n\t            left: 0,\n\t            top: 0,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderColor: '#ccc',\n\t            borderWidth: 0,\n\t            padding: 5,\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: { color: '#aaa' }\n\t        }\n\t    });\n\t    // View\n\t    echarts.extendComponentView({\n\t        type: 'title',\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t            var group = this.group;\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t            var textEl = new graphic.Text({\n\t                    style: {\n\t                        text: titleModel.get('text'),\n\t                        textFont: textStyleModel.getFont(),\n\t                        fill: textStyleModel.getTextColor()\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var textRect = textEl.getBoundingRect();\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                    style: {\n\t                        text: subText,\n\t                        textFont: subtextStyleModel.getFont(),\n\t                        fill: subtextStyleModel.getTextColor(),\n\t                        y: textRect.height + titleModel.get('itemGap'),\n\t                        textBaseline: 'top'\n\t                    },\n\t                    z2: 10\n\t                });\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding'));\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                } else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                } else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t            group.attr('position', [\n\t                layoutRect.x,\n\t                layoutRect.y\n\t            ]);\n\t            var alignStyle = {\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: textBaseline\n\t                };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle([\n\t                    'color',\n\t                    'opacity'\n\t                ]);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                    shape: {\n\t                        x: groupRect.x - padding[3],\n\t                        y: groupRect.y - padding[0],\n\t                        width: groupRect.width + padding[1] + padding[3],\n\t                        height: groupRect.height + padding[0] + padding[2]\n\t                    },\n\t                    style: style,\n\t                    silent: true\n\t                });\n\t            graphic.subPixelOptimizeRect(rect);\n\t            group.add(rect);\n\t        }\n\t    });\n\t});\n\tdefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n\t    'use strict';\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var echarts = require('../echarts');\n\t    require('../coord/cartesian/Grid');\n\t    require('./axis');\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t        type: 'grid',\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n\t                    silent: true\n\t                }));\n\t            }\n\t        }\n\t    });\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\t});\n\tdefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var IntervalScale = require('./Interval');\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t    // FIXME \n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            } else {\n\t                hi = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t            type: 'time',\n\t            getLabel: function (val) {\n\t                var stepLvl = this._stepLvl;\n\t                var date = new Date(val);\n\t                return formatUtil.formatTime(stepLvl[0], date);\n\t            },\n\t            niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    // Expand extent\n\t                    extent[0] -= ONE_DAY;\n\t                    extent[1] += ONE_DAY;\n\t                }\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                    var d = new Date();\n\t                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                    extent[0] = extent[1] - ONE_DAY;\n\t                }\n\t                this.niceTicks(approxTickNum);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                var approxInterval = span / approxTickNum;\n\t                var scaleLevelsLen = scaleLevels.length;\n\t                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t                var interval = level[2];\n\t                // Same with interval scale if span is much larger than 1 year\n\t                if (level[0] === 'year') {\n\t                    var yearSpan = span / interval;\n\t                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t                    interval *= yearStep;\n\t                }\n\t                var niceExtent = [\n\t                        mathCeil(extent[0] / interval) * interval,\n\t                        mathFloor(extent[1] / interval) * interval\n\t                    ];\n\t                this._stepLvl = level;\n\t                // Interval will be used in getTicks\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            parse: function (val) {\n\t                // val might be float.\n\t                return +numberUtil.parseDate(val);\n\t            }\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t            [\n\t                'hh:mm:ss',\n\t                1,\n\t                ONE_SECOND\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                5,\n\t                ONE_SECOND * 5\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                10,\n\t                ONE_SECOND * 10\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                15,\n\t                ONE_SECOND * 15\n\t            ],\n\t            [\n\t                'hh:mm:ss',\n\t                30,\n\t                ONE_SECOND * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_MINUTE\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                5,\n\t                ONE_MINUTE * 5\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                10,\n\t                ONE_MINUTE * 10\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                15,\n\t                ONE_MINUTE * 15\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                30,\n\t                ONE_MINUTE * 30\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                1,\n\t                ONE_HOUR\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                2,\n\t                ONE_HOUR * 2\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                6,\n\t                ONE_HOUR * 6\n\t            ],\n\t            [\n\t                'hh:mm\\nMM-dd',\n\t                12,\n\t                ONE_HOUR * 12\n\t            ],\n\t            [\n\t                'MM-dd\\nyyyy',\n\t                1,\n\t                ONE_DAY\n\t            ],\n\t            [\n\t                'week',\n\t                7,\n\t                ONE_DAY * 7\n\t            ],\n\t            [\n\t                'month',\n\t                1,\n\t                ONE_DAY * 31\n\t            ],\n\t            [\n\t                'quarter',\n\t                3,\n\t                ONE_DAY * 380 / 4\n\t            ],\n\t            [\n\t                'half-year',\n\t                6,\n\t                ONE_DAY * 380 / 2\n\t            ],\n\t            [\n\t                'year',\n\t                1,\n\t                ONE_DAY * 380\n\t            ]\n\t        ];\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t    return TimeScale;\n\t});\n\tdefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n\t    var env = require('zrender/core/env');\n\t    var GlobalModel = require('./model/Global');\n\t    var ExtensionAPI = require('./ExtensionAPI');\n\t    var CoordinateSystemManager = require('./CoordinateSystem');\n\t    var OptionManager = require('./model/OptionManager');\n\t    var ComponentModel = require('./model/Component');\n\t    var SeriesModel = require('./model/Series');\n\t    var ComponentView = require('./view/Component');\n\t    var ChartView = require('./view/Chart');\n\t    var graphic = require('./util/graphic');\n\t    var zrender = require('zrender');\n\t    var zrUtil = require('zrender/core/util');\n\t    var colorTool = require('zrender/tool/color');\n\t    var Eventful = require('zrender/mixin/Eventful');\n\t    var timsort = require('zrender/core/timsort');\n\t    var each = zrUtil.each;\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts(dom, theme, opts) {\n\t        opts = opts || {};\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio\n\t        });\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t        Eventful.call(this);\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t        // Init mouse events\n\t        this._initEvents();\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t    var echartsProto = ECharts.prototype;\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t            this[IN_MAIN_PROCESS] = true;\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this[IN_MAIN_PROCESS] = false;\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        } else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({ mainType: componentType }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = opts && opts.pixelRatio || 1;\n\t            for (var id in instances) {\n\t                var chart = instances[id];\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            }\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                        style: {\n\t                            x: item.left * dpr - left,\n\t                            y: item.top * dpr - top,\n\t                            image: item.dom\n\t                        }\n\t                    });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        } else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t    var updateMethods = {\n\t            update: function (payload) {\n\t                // console.time && console.time('update');\n\t                var ecModel = this._model;\n\t                var api = this._api;\n\t                var coordSysMgr = this._coordSysMgr;\n\t                var zr = this._zr;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                // Fixme First time update ?\n\t                ecModel.restoreData();\n\t                // TODO\n\t                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t                // Create new coordinate system each update\n\t                // In LineView may save the old coordinate system and use it to get the orignal point\n\t                coordSysMgr.create(this._model, this._api);\n\t                processData.call(this, ecModel, api);\n\t                stackSeriesData.call(this, ecModel);\n\t                coordSysMgr.update(ecModel, api);\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                doRender.call(this, ecModel, payload);\n\t                // Set background\n\t                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t                var painter = zr.painter;\n\t                // TODO all use clearColor ?\n\t                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                    zr.configLayer(0, { clearColor: backgroundColor });\n\t                } else {\n\t                    // In IE8\n\t                    if (!env.canvasSupported) {\n\t                        var colorArr = colorTool.parse(backgroundColor);\n\t                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                        if (colorArr[3] === 0) {\n\t                            backgroundColor = 'transparent';\n\t                        }\n\t                    }\n\t                    if (backgroundColor.colorStops || backgroundColor.image) {\n\t                        // Gradient background\n\t                        // FIXME Fixed layer\n\t                        zr.configLayer(0, { clearColor: backgroundColor });\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t                        this._dom.style.background = 'transparent';\n\t                    } else {\n\t                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                            zr.configLayer(0, { clearColor: null });\n\t                        }\n\t                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t                        this._dom.style.background = backgroundColor;\n\t                    }\n\t                }    // console.time && console.timeEnd('update');\n\t            },\n\t            updateView: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t            },\n\t            updateVisual: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                ecModel.eachSeries(function (seriesModel) {\n\t                    seriesModel.getData().clearAllVisual();\n\t                });\n\t                doVisualEncoding.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t            },\n\t            updateLayout: function (payload) {\n\t                var ecModel = this._model;\n\t                // update before setOption\n\t                if (!ecModel) {\n\t                    return;\n\t                }\n\t                doLayout.call(this, ecModel, payload);\n\t                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t            },\n\t            highlight: function (payload) {\n\t                toggleHighlight.call(this, 'highlight', payload);\n\t            },\n\t            downplay: function (payload) {\n\t                toggleHighlight.call(this, 'downplay', payload);\n\t            },\n\t            prepareAndUpdate: function (payload) {\n\t                var ecModel = this._model;\n\t                prepareView.call(this, 'component', ecModel);\n\t                prepareView.call(this, 'chart', ecModel);\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        };\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t        ecModel.eachComponent({\n\t            mainType: 'series',\n\t            query: payload\n\t        }, function (seriesModel, index) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            if (chartView && chartView.__alive) {\n\t                chartView[method](seriesModel, ecModel, this._api, payload);\n\t            }\n\t        }, this);\n\t    }\n\t    /**\n\t     * Resize the chart\n\t     */\n\t    echartsProto.resize = function () {\n\t        if (true) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        this._zr.resize();\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t        this[IN_MAIN_PROCESS] = false;\n\t        this._flushPendingActions();\n\t    };\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (true) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t        zr.add(el);\n\t    };\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t        this[IN_MAIN_PROCESS] = true;\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            } else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        } else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t        this[IN_MAIN_PROCESS] = false;\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t        this._flushPendingActions();\n\t    };\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t            updateZ(seriesModel, chart);\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            } else {\n\t                model = componentType;\n\t            }\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                } else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            } else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t            updateZ(seriesModel, chartView);\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t        }, this);\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t    var MOUSE_EVENT_NAMES = [\n\t            'click',\n\t            'dblclick',\n\t            'mouseover',\n\t            'mouseout',\n\t            'mousemove',\n\t            'mousedown',\n\t            'mouseup',\n\t            'globalout'\n\t        ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }    // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    this.trigger(eveName, el.eventData);\n\t                }\n\t            }, this);\n\t        }, this);\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (true) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t        delete instances[this.id];\n\t    };\n\t    zrUtil.mixin(ECharts, Eventful);\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (true) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t            version: '3.2.3',\n\t            dependencies: { zrender: '3.1.3' }\n\t        };\n\t    function enableConnect(chart) {\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t                    for (var id in instances) {\n\t                        var otherChart = instances[id];\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    }\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (true) {\n\t            // Check version\n\t            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n\t                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t        enableConnect(chart);\n\t        return chart;\n\t    };\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || 'g_' + groupIdBase++;\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        } else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if (chart instanceof ECharts && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n\t                actionInfo,\n\t                actionInfo = { event: eventName }\n\t            ][0];\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {\n\t                action: action,\n\t                actionInfo: actionInfo\n\t            };\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (true) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n\t    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n\t    echarts.registerLoading('default', require('./loading/default'));\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = require('./data/List');\n\t    echarts.Model = require('./model/Model');\n\t    echarts.graphic = require('./util/graphic');\n\t    echarts.number = require('./util/number');\n\t    echarts.format = require('./util/format');\n\t    echarts.matrix = require('zrender/core/matrix');\n\t    echarts.vector = require('zrender/core/vector');\n\t    echarts.color = require('zrender/tool/color');\n\t    echarts.util = {};\n\t    each([\n\t        'map',\n\t        'each',\n\t        'filter',\n\t        'indexOf',\n\t        'inherits',\n\t        'reduce',\n\t        'filter',\n\t        'bind',\n\t        'curry',\n\t        'isArray',\n\t        'isString',\n\t        'isObject',\n\t        'isFunction',\n\t        'extend',\n\t        'defaults'\n\t    ], function (name) {\n\t        echarts.util[name] = zrUtil[name];\n\t    });\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t    return echarts;\n\t});\n\tdefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var numberUtil = require('../util/number');\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = require('./Interval');\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t    var mathLog = Math.log;\n\t    var LogScale = Scale.extend({\n\t            type: 'log',\n\t            base: 10,\n\t            getTicks: function () {\n\t                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                    return numberUtil.round(mathPow(this.base, val));\n\t                }, this);\n\t            },\n\t            getLabel: intervalScaleProto.getLabel,\n\t            scale: function (val) {\n\t                val = scaleProto.scale.call(this, val);\n\t                return mathPow(this.base, val);\n\t            },\n\t            setExtent: function (start, end) {\n\t                var base = this.base;\n\t                start = mathLog(start) / mathLog(base);\n\t                end = mathLog(end) / mathLog(base);\n\t                intervalScaleProto.setExtent.call(this, start, end);\n\t            },\n\t            getExtent: function () {\n\t                var base = this.base;\n\t                var extent = scaleProto.getExtent.call(this);\n\t                extent[0] = mathPow(base, extent[0]);\n\t                extent[1] = mathPow(base, extent[1]);\n\t                return extent;\n\t            },\n\t            unionExtent: function (extent) {\n\t                var base = this.base;\n\t                extent[0] = mathLog(extent[0]) / mathLog(base);\n\t                extent[1] = mathLog(extent[1]) / mathLog(base);\n\t                scaleProto.unionExtent.call(this, extent);\n\t            },\n\t            niceTicks: function (approxTickNum) {\n\t                approxTickNum = approxTickNum || 10;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (span === Infinity || span <= 0) {\n\t                    return;\n\t                }\n\t                var interval = numberUtil.quantity(span);\n\t                var err = approxTickNum / span * interval;\n\t                // Filter ticks to get closer to the desired count.\n\t                if (err <= 0.5) {\n\t                    interval *= 10;\n\t                }\n\t                // Interval should be integer\n\t                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                    interval *= 10;\n\t                }\n\t                var niceExtent = [\n\t                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t                    ];\n\t                this._interval = interval;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: intervalScaleProto.niceExtent\n\t        });\n\t    zrUtil.each([\n\t        'contain',\n\t        'normalize'\n\t    ], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t    return LogScale;\n\t});\n\tdefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n\t    var graphic = require('../../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t        data.each(function (idx) {\n\t            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [\n\t                dx * offset,\n\t                dy * offset\n\t            ];\n\t        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n\t    }\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t        graphic.Group.call(this);\n\t        var sector = new graphic.Sector({ z2: 2 });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t        this.updateData(data, idx, true);\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n\t    }\n\t    var piePieceProto = PiePiece.prototype;\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n\t        };\n\t    }\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t        var sector = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n\t        } else {\n\t            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n\t        }\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        sector.useStyle(zrUtil.defaults({\n\t            lineJoin: 'bevel',\n\t            fill: visualColor\n\t        }, itemStyleModel.getModel('normal').getItemStyle()));\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t        // Toggle selected\n\t        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n\t        }\n\t        this._updateLabel(data, idx);\n\t        graphic.setHoverStyle(this);\n\t    };\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ],\n\t                    [\n\t                        labelLayout.x,\n\t                        labelLayout.y\n\t                    ]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [\n\t                labelLayout.x,\n\t                labelLayout.y\n\t            ],\n\t            z2: 10\n\t        });\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({ smooth: smooth });\n\t    };\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t    // Pie view\n\t    var Pie = require('../../view/Chart').extend({\n\t            type: 'pie',\n\t            init: function () {\n\t                var sectorGroup = new graphic.Group();\n\t                this._sectorGroup = sectorGroup;\n\t            },\n\t            render: function (seriesModel, ecModel, api, payload) {\n\t                if (payload && payload.from === this.uid) {\n\t                    return;\n\t                }\n\t                var data = seriesModel.getData();\n\t                var oldData = this._data;\n\t                var group = this.group;\n\t                var hasAnimation = ecModel.get('animation');\n\t                var isFirstRender = !oldData;\n\t                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n\t                var selectedMode = seriesModel.get('selectedMode');\n\t                data.diff(oldData).add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t                    group.add(piePiece);\n\t                }).update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t                    piePiece.updateData(data, newIdx);\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                }).remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                }).execute();\n\t                if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                    var shape = data.getItemLayout(0);\n\t                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n\t                }\n\t                this._data = data;\n\t            },\n\t            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n\t                var clipPath = new graphic.Sector({\n\t                        shape: {\n\t                            cx: cx,\n\t                            cy: cy,\n\t                            r0: 0,\n\t                            r: r,\n\t                            startAngle: startAngle,\n\t                            endAngle: startAngle,\n\t                            clockwise: clockwise\n\t                        }\n\t                    });\n\t                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n\t                return clipPath;\n\t            }\n\t        });\n\t    return Pie;\n\t});\n\tdefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\t    var PieSeries = require('../../echarts').extendSeriesModel({\n\t            type: 'series.pie',\n\t            init: function (option) {\n\t                PieSeries.superApply(this, 'init', arguments);\n\t                // Enable legend selection for each data item\n\t                // Use a function instead of direct access because data reference may changed\n\t                this.legendDataProvider = function () {\n\t                    return this._dataBeforeProcessed;\n\t                };\n\t                this.updateSelectedMap(option.data);\n\t                this._defaultLabelLine(option);\n\t            },\n\t            mergeOption: function (newOption) {\n\t                PieSeries.superCall(this, 'mergeOption', newOption);\n\t                this.updateSelectedMap(this.option.data);\n\t            },\n\t            getInitialData: function (option, ecModel) {\n\t                var dimensions = completeDimensions(['value'], option.data);\n\t                var list = new List(dimensions, this);\n\t                list.initData(option.data);\n\t                return list;\n\t            },\n\t            getDataParams: function (dataIndex) {\n\t                var data = this._data;\n\t                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t                var sum = data.getSum('value');\n\t                // FIXME toFixed?\n\t                //\n\t                // Percent is 0 if sum is 0\n\t                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t                params.$vars.push('percent');\n\t                return params;\n\t            },\n\t            _defaultLabelLine: function (option) {\n\t                // Extend labelLine emphasis\n\t                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t                var labelLineNormalOpt = option.labelLine.normal;\n\t                var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t                // Not show label line if `label.normal.show = false`\n\t                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n\t                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n\t            },\n\t            defaultOption: {\n\t                zlevel: 0,\n\t                z: 2,\n\t                legendHoverLink: true,\n\t                hoverAnimation: true,\n\t                center: [\n\t                    '50%',\n\t                    '50%'\n\t                ],\n\t                radius: [\n\t                    0,\n\t                    '75%'\n\t                ],\n\t                clockwise: true,\n\t                startAngle: 90,\n\t                minAngle: 0,\n\t                selectedOffset: 10,\n\t                avoidLabelOverlap: true,\n\t                label: {\n\t                    normal: {\n\t                        rotate: false,\n\t                        show: true,\n\t                        position: 'outer'\n\t                    },\n\t                    emphasis: {}\n\t                },\n\t                labelLine: {\n\t                    normal: {\n\t                        show: true,\n\t                        length: 15,\n\t                        length2: 15,\n\t                        smooth: false,\n\t                        lineStyle: {\n\t                            width: 1,\n\t                            type: 'solid'\n\t                        }\n\t                    }\n\t                },\n\t                itemStyle: {\n\t                    normal: { borderWidth: 1 },\n\t                    emphasis: {}\n\t                },\n\t                animationEasing: 'cubicOut',\n\t                data: []\n\t            }\n\t        });\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t    return PieSeries;\n\t});\n\tdefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n\t    var echarts = require('../echarts');\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent({\n\t                    mainType: 'series',\n\t                    subType: seriesType,\n\t                    query: payload\n\t                }, function (seriesModel) {\n\t                    if (seriesModel[actionInfo.method]) {\n\t                        seriesModel[actionInfo.method](payload.name);\n\t                    }\n\t                    var data = seriesModel.getData();\n\t                    // Create selected map\n\t                    data.each(function (idx) {\n\t                        var name = data.getName(idx);\n\t                        selected[name] = seriesModel.isSelected(name) || false;\n\t                    });\n\t                });\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\t});\n\tdefine('zrender/core/util', ['require'], function (require) {\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t            '[object Function]': 1,\n\t            '[object RegExp]': 1,\n\t            '[object Date]': 1,\n\t            '[object Error]': 1,\n\t            '[object CanvasGradient]': 1,\n\t            '[object CanvasPattern]': 1,\n\t            '[object Image]': 1\n\t        };\n\t    var objToString = Object.prototype.toString;\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} \n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            } else if (!isBuildInObject(source) && !isDom(source)) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t        return source;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                } else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {\n\t        }\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t        defaults(target, source, overlay);\n\t    }\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (!data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        } else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        } else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        } else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        } else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || !!value && type == 'object';\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n\t    }\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t    var util = {\n\t            inherits: inherits,\n\t            mixin: mixin,\n\t            clone: clone,\n\t            merge: merge,\n\t            mergeAll: mergeAll,\n\t            extend: extend,\n\t            defaults: defaults,\n\t            getContext: getContext,\n\t            createCanvas: createCanvas,\n\t            indexOf: indexOf,\n\t            slice: slice,\n\t            find: find,\n\t            isArrayLike: isArrayLike,\n\t            each: each,\n\t            map: map,\n\t            reduce: reduce,\n\t            filter: filter,\n\t            bind: bind,\n\t            curry: curry,\n\t            isArray: isArray,\n\t            isString: isString,\n\t            isObject: isObject,\n\t            isFunction: isFunction,\n\t            isBuildInObject: isBuildInObject,\n\t            isDom: isDom,\n\t            retrieve: retrieve,\n\t            assert: assert,\n\t            noop: function () {\n\t            }\n\t        };\n\t    return util;\n\t});\n\tdefine('echarts/visual/dataColor', ['require'], function (require) {\n\t    return function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    } else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = require('./labelLayout');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t    return function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [\n\t                    0,\n\t                    radius\n\t                ];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [\n\t                    center,\n\t                    center\n\t                ];\n\t            }\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t            var data = seriesModel.getData();\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t            var clockwise = seriesModel.get('clockwise');\n\t            var roseType = seriesModel.get('roseType');\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t            var currentAngle = startAngle;\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME  2.0  roseType  area \n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : value * unitRadian;\n\t                } else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                } else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType ? numberUtil.linearMap(value, extent, [\n\t                        r0,\n\t                        r\n\t                    ]) : r\n\t                });\n\t                currentAngle = endAngle;\n\t            }, true);\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 0.001) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                } else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\t});\n\tdefine('echarts/processor/dataFilter', [], function () {\n\t    return function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n\t    var layout = require('../../util/layout');\n\t    var axisHelper = require('../../coord/axisHelper');\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian2D = require('./Cartesian2D');\n\t    var Axis2D = require('./Axis2D');\n\t    var each = zrUtil.each;\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t    //  GridModel, AxisModel \n\t    require('./GridModel');\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : rect = singleRect;\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t        this._initCartesian(gridModel, ecModel, api);\n\t        this._model = gridModel;\n\t    }\n\t    var gridProto = Grid.prototype;\n\t    gridProto.type = 'grid';\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t    gridProto.update = function (ecModel, api) {\n\t        var axesMap = this._axesMap;\n\t        this._updateScale(ecModel, this._model);\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                var axis = axes[idx];\n\t                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        this._rect = gridRect;\n\t        var axesList = this._axesList;\n\t        adjustAxes();\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        } else if (axis.position === 'left') {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            adjustAxes();\n\t        }\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [\n\t                        0,\n\t                        gridRect.width\n\t                    ] : [\n\t                        0,\n\t                        gridRect.height\n\t                    ];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    return axesMapOnDim[name];\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        } else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t                left: false,\n\t                right: false,\n\t                top: false,\n\t                bottom: false\n\t            };\n\t        var axesMap = {\n\t                x: {},\n\t                y: {}\n\t            };\n\t        var axesCount = {\n\t                x: 0,\n\t                y: 0\n\t            };\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t        this._axesMap = axesMap;\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t                cartesian.grid = this;\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                } else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n\t                        0,\n\t                        0\n\t                    ], axisModel.get('type'), axisPosition);\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t                this._axesList.push(axis);\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord + coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n\t            return coord - coordBase;\n\t        } : function (coord) {\n\t            return axisExtentSum - coord + coordBase;\n\t        };\n\t    }\n\t    var axesTypes = [\n\t            'xAxis',\n\t            'yAxis'\n\t        ];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = ecModel.queryComponents({\n\t                    mainType: axisType,\n\t                    index: seriesModel.get(axisType + 'Index'),\n\t                    id: seriesModel.get(axisType + 'Id')\n\t                })[0];\n\t            if (true) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t            gridModel.coordinateSystem = grid;\n\t            grids.push(grid);\n\t        });\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t            var gridModel = xAxisModel.findGridModel();\n\t            if (true) {\n\t                if (!gridModel) {\n\t                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t            var grid = gridModel.coordinateSystem;\n\t            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        });\n\t        return grids;\n\t    };\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\t    return Grid;\n\t});\n\tdefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n\t    'use strict';\n\t    var SeriesModel = require('../../model/Series');\n\t    var createListFromArray = require('../helper/createListFromArray');\n\t    return SeriesModel.extend({\n\t        type: 'series.bar',\n\t        dependencies: [\n\t            'grid',\n\t            'polar'\n\t        ],\n\t        getInitialData: function (option, ecModel) {\n\t            if (true) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [\n\t                NaN,\n\t                NaN\n\t            ];\n\t        },\n\t        brushSelector: 'rect',\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            barMinHeight: 0,\n\t            itemStyle: {\n\t                normal: {},\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t    return require('../../echarts').extendChartView({\n\t        type: 'bar',\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t            return this.group;\n\t        },\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t            var enableAnimation = seriesModel.get('animation');\n\t            var barBorderWidthQuery = [\n\t                    'itemStyle',\n\t                    'normal',\n\t                    'barBorderWidth'\n\t                ];\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData).add(function (dataIndex) {\n\t                // \n\t                if (!data.hasValue(dataIndex)) {\n\t                    return;\n\t                }\n\t                var rect = createRect(dataIndex);\n\t                data.setItemGraphicEl(dataIndex, rect);\n\t                group.add(rect);\n\t            }).update(function (newIndex, oldIndex) {\n\t                var rect = oldData.getItemGraphicEl(oldIndex);\n\t                // \n\t                if (!data.hasValue(newIndex)) {\n\t                    group.remove(rect);\n\t                    return;\n\t                }\n\t                if (!rect) {\n\t                    rect = createRect(newIndex, true);\n\t                }\n\t                var layout = data.getItemLayout(newIndex);\n\t                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n\t                data.setItemGraphicEl(newIndex, rect);\n\t                // Add back\n\t                group.add(rect);\n\t            }).remove(function (idx) {\n\t                var rect = oldData.getItemGraphicEl(idx);\n\t                if (rect) {\n\t                    // Not show text when animating\n\t                    rect.style.text = '';\n\t                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n\t                        group.remove(rect);\n\t                    });\n\t                }\n\t            }).execute();\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t            this._data = data;\n\t        },\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t                rect.useStyle(zrUtil.defaults({\n\t                    fill: color,\n\t                    opacity: opacity\n\t                }, itemStyleModel.getBarItemStyle()));\n\t                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n\t                } else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            } else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\t});\n\tdefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('../util/number');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                    bandWidth: bandWidth,\n\t                    remainedWidth: bandWidth,\n\t                    autoWidthCount: 0,\n\t                    categoryGap: '20%',\n\t                    gap: '30%',\n\t                    stacks: {}\n\t                };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n\t            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            barGap != null && (columnsOnAxis.gap = barGap);\n\t            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t        var result = {};\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t            result[coordSysName] = {};\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n\t                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t            }));\n\t        var lastStackCoords = {};\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // \n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart,\n\t                        n: valueAxisStart\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var x, y, width, height;\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoord;\n\t                    height = columnWidth;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                } else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoord;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t        }, this);\n\t    }\n\t    return barLayoutGrid;\n\t});\n\tdefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var pathTool = require('zrender/tool/path');\n\t    var round = Math.round;\n\t    var Path = require('zrender/graphic/Path');\n\t    var colorTool = require('zrender/tool/color');\n\t    var matrix = require('zrender/core/matrix');\n\t    var vector = require('zrender/core/vector');\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    var graphic = {};\n\t    graphic.Group = require('zrender/container/Group');\n\t    graphic.Image = require('zrender/graphic/Image');\n\t    graphic.Text = require('zrender/graphic/Text');\n\t    graphic.Circle = require('zrender/graphic/shape/Circle');\n\t    graphic.Sector = require('zrender/graphic/shape/Sector');\n\t    graphic.Ring = require('zrender/graphic/shape/Ring');\n\t    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n\t    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n\t    graphic.Rect = require('zrender/graphic/shape/Rect');\n\t    graphic.Line = require('zrender/graphic/shape/Line');\n\t    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n\t    graphic.Arc = require('zrender/graphic/shape/Arc');\n\t    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n\t    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n\t    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n\t    graphic.BoundingRect = require('zrender/core/BoundingRect');\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                } else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t        var pathRect = path.getBoundingRect();\n\t        var m = pathRect.calculateTransform(rect);\n\t        path.applyTransform(m);\n\t    };\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n\t        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n\t        return param;\n\t    };\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t            el.__normalStl = normalStyle;\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t        cacheElementStl(el);\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        } else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t        el.__isHover = true;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        } else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t        el.__isHover = false;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleEnterHover(child);\n\t            }\n\t        }) : doSingleEnterHover(el);\n\t    }\n\t    function doLeaveHover(el) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                doSingleLeaveHover(child);\n\t            }\n\t        }) : doSingleLeaveHover(el);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group' ? el.traverse(function (child) {\n\t            if (child.type !== 'group') {\n\t                setElementHoverStl(child, hoverStyle);\n\t            }\n\t        }) : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n\t    };\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n\t        } else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t        return mat;\n\t    };\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t        var vertex = [\n\t                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t            ];\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n\t    };\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                    position: vector.clone(el.position),\n\t                    rotation: el.rotation\n\t                };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }    // else {\n\t                     //     if (el.previousProps) {\n\t                     //         graphic.updateProps\n\t                     //     }\n\t                     // }\n\t            }\n\t        });\n\t    };\n\t    return graphic;\n\t});\n\tdefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n\t    'use strict';\n\t    require('../coord/cartesian/AxisModel');\n\t    require('./axis/AxisView');\n\t});\n\tdefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var BoundingRect = require('zrender/core/BoundingRect');\n\t    var numberUtil = require('./number');\n\t    var formatUtil = require('./format');\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t    var layout = {};\n\t    var LOCATION_PARAMS = [\n\t            'left',\n\t            'right',\n\t            'top',\n\t            'bottom',\n\t            'width',\n\t            'height'\n\t        ];\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            } else {\n\t                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                } else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t            position[0] = x;\n\t            position[1] = y;\n\t            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n\t        });\n\t    }\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            } else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t        case 'center':\n\t            left = containerWidth / 2 - width / 2 - margin[3];\n\t            break;\n\t        case 'right':\n\t            left = containerWidth - width - horizontalMargin;\n\t            break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t        case 'middle':\n\t        case 'center':\n\t            top = containerHeight / 2 - height / 2 - margin[0];\n\t            break;\n\t        case 'bottom':\n\t            top = containerHeight - height - verticalMargin;\n\t            break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n\t        var groupRect = group.getBoundingRect();\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = [\n\t                'width',\n\t                'left',\n\t                'right'\n\t            ];\n\t        // Order by priority.\n\t        var vNames = [\n\t                'height',\n\t                'top',\n\t                'bottom'\n\t            ];\n\t        // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }    // Case: newOption: {width: ..., right: ...},\n\t                 // Than we can make sure user only want those two, and ignore\n\t                 // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            } else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t    return layout;\n\t});\n\tdefine('echarts/util/number', ['require'], function (require) {\n\t    var number = {};\n\t    var RADIAN_EPSILON = 0.0001;\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t        if (subDomain === 0) {\n\t            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n\t        }\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                } else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            } else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                } else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        } else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function (percent, all) {\n\t        switch (percent) {\n\t        case 'center':\n\t        case 'middle':\n\t            percent = '50%';\n\t            break;\n\t        case 'left':\n\t        case 'top':\n\t            percent = '0%';\n\t            break;\n\t        case 'right':\n\t        case 'bottom':\n\t            percent = '100%';\n\t            break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t            return parseFloat(percent);\n\t        }\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // PENDING\n\t        return +(+x).toFixed(precision);\n\t    };\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(-dataQuantity + sizeQuantity, 0);\n\t    };\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        } else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t        return new Date(Math.round(value));\n\t    };\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10;\n\t        // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) {\n\t                nf = 1;\n\t            } else if (f < 2.5) {\n\t                nf = 2;\n\t            } else if (f < 4) {\n\t                nf = 3;\n\t            } else if (f < 7) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        } else {\n\t            if (f < 1) {\n\t                nf = 1;\n\t            } else if (f < 2) {\n\t                nf = 2;\n\t            } else if (f < 3) {\n\t                nf = 3;\n\t            } else if (f < 5) {\n\t                nf = 5;\n\t            } else {\n\t                nf = 10;\n\t            }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t    return number;\n\t});\n\tdefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var numberUtil = require('./number');\n\t    var textContain = require('zrender/contain/text');\n\t    var formatUtil = {};\n\t    /**\n\t     * ,\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof val === 'number') {\n\t            return [\n\t                val,\n\t                val,\n\t                val,\n\t                val\n\t            ];\n\t        } else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[0],\n\t                val[1]\n\t            ];\n\t        } else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [\n\t                val[0],\n\t                val[1],\n\t                val[2],\n\t                val[1]\n\t            ];\n\t        }\n\t        return val;\n\t    };\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n\t    };\n\t    var TPL_VAR_ALIAS = [\n\t            'a',\n\t            'b',\n\t            'c',\n\t            'd',\n\t            'e',\n\t            'f',\n\t            'g'\n\t        ];\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n\t            }\n\t        }\n\t        return tpl;\n\t    };\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? '0' + str : str;\n\t    };\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n\t        return tpl;\n\t    };\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t    formatUtil.truncateText = textContain.truncateText;\n\t    return formatUtil;\n\t});\n\tdefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var formatUtil = require('../util/format');\n\t    var Scale = require('./Scale');\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t            type: 'interval',\n\t            _interval: 0,\n\t            setExtent: function (start, end) {\n\t                var thisExtent = this._extent;\n\t                //start,end may be a Number like '25',so...\n\t                if (!isNaN(start)) {\n\t                    thisExtent[0] = parseFloat(start);\n\t                }\n\t                if (!isNaN(end)) {\n\t                    thisExtent[1] = parseFloat(end);\n\t                }\n\t            },\n\t            unionExtent: function (other) {\n\t                var extent = this._extent;\n\t                other[0] < extent[0] && (extent[0] = other[0]);\n\t                other[1] > extent[1] && (extent[1] = other[1]);\n\t                // unionExtent may called by it's sub classes\n\t                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t            },\n\t            getInterval: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                return this._interval;\n\t            },\n\t            setInterval: function (interval) {\n\t                this._interval = interval;\n\t                // Dropped auto calculated niceExtent and use user setted extent\n\t                // We assume user wan't to set both interval, min, max to get a better result\n\t                this._niceExtent = this._extent.slice();\n\t            },\n\t            getTicks: function () {\n\t                if (!this._interval) {\n\t                    this.niceTicks();\n\t                }\n\t                var interval = this._interval;\n\t                var extent = this._extent;\n\t                var ticks = [];\n\t                // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t                var safeLimit = 10000;\n\t                if (interval) {\n\t                    var niceExtent = this._niceExtent;\n\t                    var precision = getPrecisionSafe(interval) + 2;\n\t                    if (extent[0] < niceExtent[0]) {\n\t                        ticks.push(extent[0]);\n\t                    }\n\t                    var tick = niceExtent[0];\n\t                    while (tick <= niceExtent[1]) {\n\t                        ticks.push(tick);\n\t                        // Avoid rounding error\n\t                        tick = roundingErrorFix(tick + interval, precision);\n\t                        if (ticks.length > safeLimit) {\n\t                            return [];\n\t                        }\n\t                    }\n\t                    if (extent[1] > niceExtent[1]) {\n\t                        ticks.push(extent[1]);\n\t                    }\n\t                }\n\t                return ticks;\n\t            },\n\t            getTicksLabels: function () {\n\t                var labels = [];\n\t                var ticks = this.getTicks();\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    labels.push(this.getLabel(ticks[i]));\n\t                }\n\t                return labels;\n\t            },\n\t            getLabel: function (data) {\n\t                return formatUtil.addCommas(data);\n\t            },\n\t            niceTicks: function (splitNumber) {\n\t                splitNumber = splitNumber || 5;\n\t                var extent = this._extent;\n\t                var span = extent[1] - extent[0];\n\t                if (!isFinite(span)) {\n\t                    return;\n\t                }\n\t                // User may set axis min 0 and data are all negative\n\t                // FIXME If it needs to reverse ?\n\t                if (span < 0) {\n\t                    span = -span;\n\t                    extent.reverse();\n\t                }\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceSpan = numberUtil.nice(span, false);\n\t                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n\t                var precision = getPrecisionSafe(step) + 2;\n\t                // Niced extent inside original extent\n\t                var niceExtent = [\n\t                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t                    ];\n\t                this._interval = step;\n\t                this._niceExtent = niceExtent;\n\t            },\n\t            niceExtent: function (splitNumber, fixMin, fixMax) {\n\t                var extent = this._extent;\n\t                // If extent start and end are same, expand them\n\t                if (extent[0] === extent[1]) {\n\t                    if (extent[0] !== 0) {\n\t                        // Expand extent\n\t                        var expandSize = extent[0];\n\t                        // In the fowllowing case\n\t                        //      Axis has been fixed max 100\n\t                        //      Plus data are all 100 and axis extent are [100, 100].\n\t                        // Extend to the both side will cause expanded max is larger than fixed max.\n\t                        // So only expand to the smaller side.\n\t                        if (!fixMax) {\n\t                            extent[1] += expandSize / 2;\n\t                            extent[0] -= expandSize / 2;\n\t                        } else {\n\t                            extent[0] -= expandSize / 2;\n\t                        }\n\t                    } else {\n\t                        extent[1] = 1;\n\t                    }\n\t                }\n\t                var span = extent[1] - extent[0];\n\t                // If there are no data and extent are [Infinity, -Infinity]\n\t                if (!isFinite(span)) {\n\t                    extent[0] = 0;\n\t                    extent[1] = 1;\n\t                }\n\t                this.niceTicks(splitNumber);\n\t                // var extent = this._extent;\n\t                var interval = this._interval;\n\t                if (!fixMin) {\n\t                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t                }\n\t                if (!fixMax) {\n\t                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t                }\n\t            }\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t    return IntervalScale;\n\t});\n\tdefine('zrender/core/env', [], function () {\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            canvasSupported: true\n\t        };\n\t    } else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t    return env;\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/);\n\t        // IE 12 and 12+\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox)\n\t            browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            canvasSupported: document.createElement('canvas').getContext ? true : false,\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n\t        };\n\t    }\n\t});\n\tdefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var echartsAPIList = [\n\t            'getDom',\n\t            'getZr',\n\t            'getWidth',\n\t            'getHeight',\n\t            'dispatchAction',\n\t            'isDisposed',\n\t            'on',\n\t            'off',\n\t            'getDataURL',\n\t            'getConnectedDataURL',\n\t            'getModel',\n\t            'getOption'\n\t        ];\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t    return ExtensionAPI;\n\t});\n\tdefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var Model = require('./Model');\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t    var ComponentModel = require('./Component');\n\t    var globalDefault = require('./globalDefault');\n\t    var OPTION_INNER_KEY = '\u0000_ec_inner';\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t            constructor: GlobalModel,\n\t            init: function (option, parentModel, theme, optionManager) {\n\t                theme = theme || {};\n\t                this.option = null;\n\t                // Mark as not initialized.\n\t                /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t                this._theme = new Model(theme);\n\t                /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t                this._optionManager = optionManager;\n\t            },\n\t            setOption: function (option, optionPreprocessorFuncs) {\n\t                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\t                this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t                this.resetOption();\n\t            },\n\t            resetOption: function (type) {\n\t                var optionChanged = false;\n\t                var optionManager = this._optionManager;\n\t                if (!type || type === 'recreate') {\n\t                    var baseOption = optionManager.mountOption(type === 'recreate');\n\t                    if (!this.option || type === 'recreate') {\n\t                        initBase.call(this, baseOption);\n\t                    } else {\n\t                        this.restoreData();\n\t                        this.mergeOption(baseOption);\n\t                    }\n\t                    optionChanged = true;\n\t                }\n\t                if (type === 'timeline' || type === 'media') {\n\t                    this.restoreData();\n\t                }\n\t                if (!type || type === 'recreate' || type === 'timeline') {\n\t                    var timelineOption = optionManager.getTimelineOption(this);\n\t                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t                }\n\t                if (!type || type === 'recreate' || type === 'media') {\n\t                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                    if (mediaOptions.length) {\n\t                        each(mediaOptions, function (mediaOption) {\n\t                            this.mergeOption(mediaOption, optionChanged = true);\n\t                        }, this);\n\t                    }\n\t                }\n\t                return optionChanged;\n\t            },\n\t            mergeOption: function (newOption) {\n\t                var option = this.option;\n\t                var componentsMap = this._componentsMap;\n\t                var newCptTypes = [];\n\t                //  component model  merge\n\t                each(newOption, function (componentOption, mainType) {\n\t                    if (componentOption == null) {\n\t                        return;\n\t                    }\n\t                    if (!ComponentModel.hasClass(mainType)) {\n\t                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n\t                    } else {\n\t                        newCptTypes.push(mainType);\n\t                    }\n\t                });\n\t                // FIXME OPTION \n\t                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\t                this._seriesIndices = this._seriesIndices || [];\n\t                function visitComponent(mainType, dependencies) {\n\t                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n\t                    makeKeyInfo(mainType, mapResult);\n\t                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n\t                    option[mainType] = [];\n\t                    componentsMap[mainType] = [];\n\t                    each(mapResult, function (resultItem, index) {\n\t                        var componentModel = resultItem.exist;\n\t                        var newCptOption = resultItem.option;\n\t                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n\t                        // Consider where is no new option and should be merged using {},\n\t                        // see removeEdgeAndAdd in topologicalTravel and\n\t                        // ComponentModel.getAllClassMainTypes.\n\t                        if (!newCptOption) {\n\t                            componentModel.mergeOption({}, this);\n\t                            componentModel.optionUpdated({}, false);\n\t                        } else {\n\t                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\t                            if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                                componentModel.mergeOption(newCptOption, this);\n\t                                componentModel.optionUpdated(newCptOption, false);\n\t                            } else {\n\t                                // PENDING Global as parent ?\n\t                                var extraOpt = zrUtil.extend({\n\t                                        dependentModels: dependentModels,\n\t                                        componentIndex: index\n\t                                    }, resultItem.keyInfo);\n\t                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n\t                                componentModel.init(newCptOption, this, this, extraOpt);\n\t                                // Call optionUpdated after init.\n\t                                // newCptOption has been used as componentModel.option\n\t                                // and may be merged with theme and default, so pass null\n\t                                // to avoid confusion.\n\t                                componentModel.optionUpdated(null, true);\n\t                            }\n\t                        }\n\t                        componentsMap[mainType][index] = componentModel;\n\t                        option[mainType][index] = componentModel.option;\n\t                    }, this);\n\t                    // Backup series for filtering.\n\t                    if (mainType === 'series') {\n\t                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                    }\n\t                }\n\t            },\n\t            getOption: function () {\n\t                var option = zrUtil.clone(this.option);\n\t                each(option, function (opts, mainType) {\n\t                    if (ComponentModel.hasClass(mainType)) {\n\t                        var opts = modelUtil.normalizeToArray(opts);\n\t                        for (var i = opts.length - 1; i >= 0; i--) {\n\t                            // Remove options with inner id.\n\t                            if (modelUtil.isIdInner(opts[i])) {\n\t                                opts.splice(i, 1);\n\t                            }\n\t                        }\n\t                        option[mainType] = opts;\n\t                    }\n\t                });\n\t                delete option[OPTION_INNER_KEY];\n\t                return option;\n\t            },\n\t            getTheme: function () {\n\t                return this._theme;\n\t            },\n\t            getComponent: function (mainType, idx) {\n\t                var list = this._componentsMap[mainType];\n\t                if (list) {\n\t                    return list[idx || 0];\n\t                }\n\t            },\n\t            queryComponents: function (condition) {\n\t                var mainType = condition.mainType;\n\t                if (!mainType) {\n\t                    return [];\n\t                }\n\t                var index = condition.index;\n\t                var id = condition.id;\n\t                var name = condition.name;\n\t                var cpts = this._componentsMap[mainType];\n\t                if (!cpts || !cpts.length) {\n\t                    return [];\n\t                }\n\t                var result;\n\t                if (index != null) {\n\t                    if (!isArray(index)) {\n\t                        index = [index];\n\t                    }\n\t                    result = filter(map(index, function (idx) {\n\t                        return cpts[idx];\n\t                    }), function (val) {\n\t                        return !!val;\n\t                    });\n\t                } else if (id != null) {\n\t                    var isIdArray = isArray(id);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n\t                    });\n\t                } else if (name != null) {\n\t                    var isNameArray = isArray(name);\n\t                    result = filter(cpts, function (cpt) {\n\t                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n\t                    });\n\t                } else {\n\t                    // Return all components with mainType\n\t                    result = cpts;\n\t                }\n\t                return filterBySubType(result, condition);\n\t            },\n\t            findComponents: function (condition) {\n\t                var query = condition.query;\n\t                var mainType = condition.mainType;\n\t                var queryCond = getQueryCond(query);\n\t                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n\t                return doFilter(filterBySubType(result, condition));\n\t                function getQueryCond(q) {\n\t                    var indexAttr = mainType + 'Index';\n\t                    var idAttr = mainType + 'Id';\n\t                    var nameAttr = mainType + 'Name';\n\t                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n\t                        mainType: mainType,\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    } : null;\n\t                }\n\t                function doFilter(res) {\n\t                    return condition.filter ? filter(res, condition.filter) : res;\n\t                }\n\t            },\n\t            eachComponent: function (mainType, cb, context) {\n\t                var componentsMap = this._componentsMap;\n\t                if (typeof mainType === 'function') {\n\t                    context = cb;\n\t                    cb = mainType;\n\t                    each(componentsMap, function (components, componentType) {\n\t                        each(components, function (component, index) {\n\t                            cb.call(context, componentType, component, index);\n\t                        });\n\t                    });\n\t                } else if (zrUtil.isString(mainType)) {\n\t                    each(componentsMap[mainType], cb, context);\n\t                } else if (isObject(mainType)) {\n\t                    var queryResult = this.findComponents(mainType);\n\t                    each(queryResult, cb, context);\n\t                }\n\t            },\n\t            getSeriesByName: function (name) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.name === name;\n\t                });\n\t            },\n\t            getSeriesByIndex: function (seriesIndex) {\n\t                return this._componentsMap.series[seriesIndex];\n\t            },\n\t            getSeriesByType: function (subType) {\n\t                var series = this._componentsMap.series;\n\t                return filter(series, function (oneSeries) {\n\t                    return oneSeries.subType === subType;\n\t                });\n\t            },\n\t            getSeries: function () {\n\t                return this._componentsMap.series.slice();\n\t            },\n\t            eachSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }, this);\n\t            },\n\t            eachRawSeries: function (cb, context) {\n\t                each(this._componentsMap.series, cb, context);\n\t            },\n\t            eachSeriesByType: function (subType, cb, context) {\n\t                assertSeriesInitialized(this);\n\t                each(this._seriesIndices, function (rawSeriesIndex) {\n\t                    var series = this._componentsMap.series[rawSeriesIndex];\n\t                    if (series.subType === subType) {\n\t                        cb.call(context, series, rawSeriesIndex);\n\t                    }\n\t                }, this);\n\t            },\n\t            eachRawSeriesByType: function (subType, cb, context) {\n\t                return each(this.getSeriesByType(subType), cb, context);\n\t            },\n\t            isSeriesFiltered: function (seriesModel) {\n\t                assertSeriesInitialized(this);\n\t                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t            },\n\t            filterSeries: function (cb, context) {\n\t                assertSeriesInitialized(this);\n\t                var filteredSeries = filter(this._componentsMap.series, cb, context);\n\t                this._seriesIndices = createSeriesIndices(filteredSeries);\n\t            },\n\t            restoreData: function () {\n\t                var componentsMap = this._componentsMap;\n\t                this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                var componentTypes = [];\n\t                each(componentsMap, function (components, componentType) {\n\t                    componentTypes.push(componentType);\n\t                });\n\t                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        for (var name in theme) {\n\t            //  component model  merge  model \n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof theme[name] === 'object') {\n\t                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n\t                } else {\n\t                    if (option[name] == null) {\n\t                        option[name] = theme[name];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t        mergeTheme(baseOption, this._theme.option);\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t        this.mergeOption(baseOption);\n\t    }\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t        return ret;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {\n\t                    mainType: mainType,\n\t                    subType: subType\n\t                };\n\t            }\n\t        });\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            } else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            } else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n\t                } while (idMap[keyInfo.id]);\n\t            }\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n\t            return cpt.subType === condition.subType;\n\t        }) : components;\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (true) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\t    return GlobalModel;\n\t});\n\tdefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t    OptionManager.prototype = {\n\t        constructor: OptionManager,\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t            // FIXME\n\t            //  timeline options  media baseOption\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            } else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t            // TODO\n\t            // resetclone\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n\t        },\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n\t                }\n\t            }\n\t            return option;\n\t        },\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t            // FIXME\n\t            // mediaDefault\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t            this._currentMediaIndices = indices;\n\t            return result;\n\t        }\n\t    };\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    } else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n\t            return media.option;\n\t        })), function (option) {\n\t            each(optionPreprocessorFuncs, function (preProcess) {\n\t                preProcess(option, isNew);\n\t            });\n\t        });\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t                width: ecWidth,\n\t                height: ecHeight,\n\t                aspectratio: ecWidth / ecHeight\n\t            };\n\t        var applicatable = true;\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t        return applicatable;\n\t    }\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        } else if (operator === 'max') {\n\t            return real <= expect;\n\t        } else {\n\t            // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t            var oldCptOpt = oldOption[mainType];\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            } else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n\t                });\n\t            }\n\t        });\n\t    }\n\t    return OptionManager;\n\t});\n\tdefine('echarts/CoordinateSystem', ['require'], function (require) {\n\t    'use strict';\n\t    var coordinateSystemCreators = {};\n\t    function CoordinateSystemManager() {\n\t        this._coordinateSystems = [];\n\t    }\n\t    CoordinateSystemManager.prototype = {\n\t        constructor: CoordinateSystemManager,\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            for (var type in coordinateSystemCreators) {\n\t                var list = coordinateSystemCreators[type].create(ecModel, api);\n\t                list && (coordinateSystems = coordinateSystems.concat(list));\n\t            }\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t        update: function (ecModel, api) {\n\t            var coordinateSystems = this._coordinateSystems;\n\t            for (var i = 0; i < coordinateSystems.length; i++) {\n\t                // FIXME MUST have\n\t                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n\t            }\n\t        }\n\t    };\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t    return CoordinateSystemManager;\n\t});\n\tdefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../util/format');\n\t    var modelUtil = require('../util/model');\n\t    var ComponentModel = require('./Component');\n\t    var colorPaletteMixin = require('./mixin/colorPalette');\n\t    var env = require('zrender/core/env');\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t    var SeriesModel = ComponentModel.extend({\n\t            type: 'series.__base__',\n\t            seriesIndex: 0,\n\t            coordinateSystem: null,\n\t            defaultOption: null,\n\t            legendDataProvider: null,\n\t            visualColorAccessPath: 'itemStyle.normal.color',\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t                this.seriesIndex = this.componentIndex;\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t                /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t                // If we reverse the order (make this._data firstly, and then make\n\t                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t                // cause this._data.graph.data !== this._data when using\n\t                // module:echarts/data/Graph or module:echarts/data/Tree.\n\t                // See module:echarts/data/helper/linkList\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                // Default label emphasis `position` and `show`\n\t                // FIXME Set label in mergeOption\n\t                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t                this.fillDataTextStyle(option.data);\n\t            },\n\t            mergeOption: function (newSeriesOption, ecModel) {\n\t                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t                this.fillDataTextStyle(newSeriesOption.data);\n\t                var data = this.getInitialData(newSeriesOption, ecModel);\n\t                // TODO Merge data?\n\t                if (data) {\n\t                    this._data = data;\n\t                    this._dataBeforeProcessed = data.cloneShallow();\n\t                }\n\t            },\n\t            fillDataTextStyle: function (data) {\n\t                // Default data label emphasis `position` and `show`\n\t                // FIXME Tree structure data ?\n\t                // FIXME Performance ?\n\t                if (data) {\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] && data[i].label) {\n\t                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            getInitialData: function () {\n\t            },\n\t            getData: function (dataType) {\n\t                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t            },\n\t            setData: function (data) {\n\t                this._data = data;\n\t            },\n\t            getRawData: function () {\n\t                return this._dataBeforeProcessed;\n\t            },\n\t            coordDimToDataDim: function (coordDim) {\n\t                return [coordDim];\n\t            },\n\t            dataDimToCoordDim: function (dataDim) {\n\t                return dataDim;\n\t            },\n\t            getBaseAxis: function () {\n\t                var coordSys = this.coordinateSystem;\n\t                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t            },\n\t            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t                function formatArrayValue(value) {\n\t                    return zrUtil.map(value, function (val, idx) {\n\t                        var dimInfo = data.getDimensionInfo(idx);\n\t                        var dimType = dimInfo && dimInfo.type;\n\t                        if (dimType === 'ordinal') {\n\t                            return val;\n\t                        } else if (dimType === 'time') {\n\t                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                        } else {\n\t                            return addCommas(val);\n\t                        }\n\t                    }).filter(function (val) {\n\t                        return !!val;\n\t                    }).join(', ');\n\t                }\n\t                var data = this._data;\n\t                var value = this.getRawValue(dataIndex);\n\t                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n\t                var name = data.getName(dataIndex);\n\t                var color = data.getItemVisual(dataIndex, 'color');\n\t                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t                var seriesName = this.name;\n\t                // FIXME\n\t                if (seriesName === '\u0000-') {\n\t                    // Not show '-'\n\t                    seriesName = '';\n\t                }\n\t                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n\t            },\n\t            ifEnableAnimation: function () {\n\t                if (env.node) {\n\t                    return false;\n\t                }\n\t                var animationEnabled = this.getShallow('animation');\n\t                if (animationEnabled) {\n\t                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                        animationEnabled = false;\n\t                    }\n\t                }\n\t                return animationEnabled;\n\t            },\n\t            restoreData: function () {\n\t                this._data = this._dataBeforeProcessed.cloneShallow();\n\t            },\n\t            getColorFromPalette: function (name, scope) {\n\t                var ecModel = this.ecModel;\n\t                // PENDING\n\t                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t                if (!color) {\n\t                    color = ecModel.getColorFromPalette(name, scope);\n\t                }\n\t                return color;\n\t            },\n\t            getAxisTooltipDataIndex: null\n\t        });\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t    return SeriesModel;\n\t});\n\tdefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n\t    var Model = require('./Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var layout = require('../util/layout');\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t            type: 'component',\n\t            id: '',\n\t            name: '',\n\t            mainType: '',\n\t            subType: '',\n\t            componentIndex: 0,\n\t            defaultOption: null,\n\t            ecModel: null,\n\t            dependentModels: [],\n\t            uid: null,\n\t            layoutMode: null,\n\t            $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t                Model.call(this, option, parentModel, ecModel, extraOpt);\n\t                // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t                zrUtil.extend(this, extraOpt);\n\t                this.uid = componentUtil.getUID('componentModel');\n\t            },\n\t            init: function (option, parentModel, ecModel, extraOpt) {\n\t                this.mergeDefaultAndTheme(option, ecModel);\n\t            },\n\t            mergeDefaultAndTheme: function (option, ecModel) {\n\t                var layoutMode = this.layoutMode;\n\t                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                var themeModel = ecModel.getTheme();\n\t                zrUtil.merge(option, themeModel.get(this.mainType));\n\t                zrUtil.merge(option, this.getDefaultOption());\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                }\n\t            },\n\t            mergeOption: function (option) {\n\t                zrUtil.merge(this.option, option, true);\n\t                var layoutMode = this.layoutMode;\n\t                if (layoutMode) {\n\t                    layout.mergeLayoutParam(this.option, option, layoutMode);\n\t                }\n\t            },\n\t            optionUpdated: function (newCptOption, isInit) {\n\t            },\n\t            getDefaultOption: function () {\n\t                if (!this.hasOwnProperty('__defaultOption')) {\n\t                    var optList = [];\n\t                    var Class = this.constructor;\n\t                    while (Class) {\n\t                        var opt = Class.prototype.defaultOption;\n\t                        opt && optList.push(opt);\n\t                        Class = Class.superClass;\n\t                    }\n\t                    var defaultOption = {};\n\t                    for (var i = optList.length - 1; i >= 0; i--) {\n\t                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                    }\n\t                    this.__defaultOption = defaultOption;\n\t                }\n\t                return this.__defaultOption;\n\t            }\n\t        });\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\t    return ComponentModel;\n\t});\n\tdefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t    Component.prototype = {\n\t        constructor: Component,\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (componentModel, ecModel, api, payload) {\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t    };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n\t    return Component;\n\t});\n\tdefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n\t    var Group = require('zrender/container/Group');\n\t    var componentUtil = require('../util/component');\n\t    var clazzUtil = require('../util/clazz');\n\t    function Chart() {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t    Chart.prototype = {\n\t        type: 'chart',\n\t        init: function (ecModel, api) {\n\t        },\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t        },\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t        dispose: function () {\n\t        }\n\t    };\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n\t        this.render(seriesModel, ecModel, api, payload);\n\t    };\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = payload && payload.dataIndex;\n\t        var name = payload && payload.name;\n\t        if (dataIndex != null) {\n\t            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n\t            for (var i = 0, len = dataIndices.length; i < len; i++) {\n\t                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n\t            }\n\t        } else if (name) {\n\t            var names = name instanceof Array ? name : [name];\n\t            for (var i = 0, len = names.length; i < len; i++) {\n\t                var dataIndex = data.indexOfName(names[i]);\n\t                elSetState(data.getItemGraphicEl(dataIndex), state);\n\t            }\n\t        } else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart);\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n\t    return Chart;\n\t});\n\tdefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n\t    var guid = require('./core/guid');\n\t    var env = require('./core/env');\n\t    var Handler = require('./Handler');\n\t    var Storage = require('./Storage');\n\t    var Animation = require('./animation/Animation');\n\t    var HandlerProxy = require('./dom/HandlerProxy');\n\t    var useVML = !env.canvasSupported;\n\t    var painterCtors = { canvas: require('./Painter') };\n\t    var instances = {};\n\t    // ZRendermap\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function (dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        } else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t        return zrender;\n\t    };\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function (id, dom, opts) {\n\t        opts = opts || {};\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t        var self = this;\n\t        var storage = new Storage();\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        } else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t            oldDelFromMap.call(storage, elId);\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t    ZRender.prototype = {\n\t        constructor: ZRender,\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t        refresh: function () {\n\t            this._needsRefresh = true;\n\t        },\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t        resize: function () {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t        getWidth: function () {\n\t            return this.painter.getWidth();\n\t        },\n\t        getHeight: function () {\n\t            return this.painter.getHeight();\n\t        },\n\t        pathToImage: function (e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t        on: function (eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t        off: function (eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t        dispose: function () {\n\t            this.animation.stop();\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t            this.animation = this.storage = this.painter = this.handler = null;\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t    return zrender;\n\t});\n\tdefine('zrender/mixin/Eventful', ['require'], function (require) {\n\t    var arrySlice = Array.prototype.slice;\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t    Eventful.prototype = {\n\t        constructor: Eventful,\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t            return this;\n\t        },\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            } else {\n\t                delete _h[event];\n\t            }\n\t            return this;\n\t        },\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(_h[i]['ctx']);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                    case 1:\n\t                        _h[i]['h'].call(ctx);\n\t                        break;\n\t                    case 2:\n\t                        _h[i]['h'].call(ctx, args[1]);\n\t                        break;\n\t                    case 3:\n\t                        _h[i]['h'].call(ctx, args[1], args[2]);\n\t                        break;\n\t                    default:\n\t                        // have more than 2 given arguments\n\t                        _h[i]['h'].apply(ctx, args);\n\t                        break;\n\t                    }\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    } else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    return Eventful;\n\t});\n\tdefine('zrender/tool/color', ['require'], function (require) {\n\t    var kCSSColorTable = {\n\t            'transparent': [\n\t                0,\n\t                0,\n\t                0,\n\t                0\n\t            ],\n\t            'aliceblue': [\n\t                240,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'antiquewhite': [\n\t                250,\n\t                235,\n\t                215,\n\t                1\n\t            ],\n\t            'aqua': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'aquamarine': [\n\t                127,\n\t                255,\n\t                212,\n\t                1\n\t            ],\n\t            'azure': [\n\t                240,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'beige': [\n\t                245,\n\t                245,\n\t                220,\n\t                1\n\t            ],\n\t            'bisque': [\n\t                255,\n\t                228,\n\t                196,\n\t                1\n\t            ],\n\t            'black': [\n\t                0,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'blanchedalmond': [\n\t                255,\n\t                235,\n\t                205,\n\t                1\n\t            ],\n\t            'blue': [\n\t                0,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'blueviolet': [\n\t                138,\n\t                43,\n\t                226,\n\t                1\n\t            ],\n\t            'brown': [\n\t                165,\n\t                42,\n\t                42,\n\t                1\n\t            ],\n\t            'burlywood': [\n\t                222,\n\t                184,\n\t                135,\n\t                1\n\t            ],\n\t            'cadetblue': [\n\t                95,\n\t                158,\n\t                160,\n\t                1\n\t            ],\n\t            'chartreuse': [\n\t                127,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'chocolate': [\n\t                210,\n\t                105,\n\t                30,\n\t                1\n\t            ],\n\t            'coral': [\n\t                255,\n\t                127,\n\t                80,\n\t                1\n\t            ],\n\t            'cornflowerblue': [\n\t                100,\n\t                149,\n\t                237,\n\t                1\n\t            ],\n\t            'cornsilk': [\n\t                255,\n\t                248,\n\t                220,\n\t                1\n\t            ],\n\t            'crimson': [\n\t                220,\n\t                20,\n\t                60,\n\t                1\n\t            ],\n\t            'cyan': [\n\t                0,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'darkblue': [\n\t                0,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkcyan': [\n\t                0,\n\t                139,\n\t                139,\n\t                1\n\t            ],\n\t            'darkgoldenrod': [\n\t                184,\n\t                134,\n\t                11,\n\t                1\n\t            ],\n\t            'darkgray': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkgreen': [\n\t                0,\n\t                100,\n\t                0,\n\t                1\n\t            ],\n\t            'darkgrey': [\n\t                169,\n\t                169,\n\t                169,\n\t                1\n\t            ],\n\t            'darkkhaki': [\n\t                189,\n\t                183,\n\t                107,\n\t                1\n\t            ],\n\t            'darkmagenta': [\n\t                139,\n\t                0,\n\t                139,\n\t                1\n\t            ],\n\t            'darkolivegreen': [\n\t                85,\n\t                107,\n\t                47,\n\t                1\n\t            ],\n\t            'darkorange': [\n\t                255,\n\t                140,\n\t                0,\n\t                1\n\t            ],\n\t            'darkorchid': [\n\t                153,\n\t                50,\n\t                204,\n\t                1\n\t            ],\n\t            'darkred': [\n\t                139,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'darksalmon': [\n\t                233,\n\t                150,\n\t                122,\n\t                1\n\t            ],\n\t            'darkseagreen': [\n\t                143,\n\t                188,\n\t                143,\n\t                1\n\t            ],\n\t            'darkslateblue': [\n\t                72,\n\t                61,\n\t                139,\n\t                1\n\t            ],\n\t            'darkslategray': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkslategrey': [\n\t                47,\n\t                79,\n\t                79,\n\t                1\n\t            ],\n\t            'darkturquoise': [\n\t                0,\n\t                206,\n\t                209,\n\t                1\n\t            ],\n\t            'darkviolet': [\n\t                148,\n\t                0,\n\t                211,\n\t                1\n\t            ],\n\t            'deeppink': [\n\t                255,\n\t                20,\n\t                147,\n\t                1\n\t            ],\n\t            'deepskyblue': [\n\t                0,\n\t                191,\n\t                255,\n\t                1\n\t            ],\n\t            'dimgray': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dimgrey': [\n\t                105,\n\t                105,\n\t                105,\n\t                1\n\t            ],\n\t            'dodgerblue': [\n\t                30,\n\t                144,\n\t                255,\n\t                1\n\t            ],\n\t            'firebrick': [\n\t                178,\n\t                34,\n\t                34,\n\t                1\n\t            ],\n\t            'floralwhite': [\n\t                255,\n\t                250,\n\t                240,\n\t                1\n\t            ],\n\t            'forestgreen': [\n\t                34,\n\t                139,\n\t                34,\n\t                1\n\t            ],\n\t            'fuchsia': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'gainsboro': [\n\t                220,\n\t                220,\n\t                220,\n\t                1\n\t            ],\n\t            'ghostwhite': [\n\t                248,\n\t                248,\n\t                255,\n\t                1\n\t            ],\n\t            'gold': [\n\t                255,\n\t                215,\n\t                0,\n\t                1\n\t            ],\n\t            'goldenrod': [\n\t                218,\n\t                165,\n\t                32,\n\t                1\n\t            ],\n\t            'gray': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'green': [\n\t                0,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'greenyellow': [\n\t                173,\n\t                255,\n\t                47,\n\t                1\n\t            ],\n\t            'grey': [\n\t                128,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'honeydew': [\n\t                240,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'hotpink': [\n\t                255,\n\t                105,\n\t                180,\n\t                1\n\t            ],\n\t            'indianred': [\n\t                205,\n\t                92,\n\t                92,\n\t                1\n\t            ],\n\t            'indigo': [\n\t                75,\n\t                0,\n\t                130,\n\t                1\n\t            ],\n\t            'ivory': [\n\t                255,\n\t                255,\n\t                240,\n\t                1\n\t            ],\n\t            'khaki': [\n\t                240,\n\t                230,\n\t                140,\n\t                1\n\t            ],\n\t            'lavender': [\n\t                230,\n\t                230,\n\t                250,\n\t                1\n\t            ],\n\t            'lavenderblush': [\n\t                255,\n\t                240,\n\t                245,\n\t                1\n\t            ],\n\t            'lawngreen': [\n\t                124,\n\t                252,\n\t                0,\n\t                1\n\t            ],\n\t            'lemonchiffon': [\n\t                255,\n\t                250,\n\t                205,\n\t                1\n\t            ],\n\t            'lightblue': [\n\t                173,\n\t                216,\n\t                230,\n\t                1\n\t            ],\n\t            'lightcoral': [\n\t                240,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'lightcyan': [\n\t                224,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'lightgoldenrodyellow': [\n\t                250,\n\t                250,\n\t                210,\n\t                1\n\t            ],\n\t            'lightgray': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightgreen': [\n\t                144,\n\t                238,\n\t                144,\n\t                1\n\t            ],\n\t            'lightgrey': [\n\t                211,\n\t                211,\n\t                211,\n\t                1\n\t            ],\n\t            'lightpink': [\n\t                255,\n\t                182,\n\t                193,\n\t                1\n\t            ],\n\t            'lightsalmon': [\n\t                255,\n\t                160,\n\t                122,\n\t                1\n\t            ],\n\t            'lightseagreen': [\n\t                32,\n\t                178,\n\t                170,\n\t                1\n\t            ],\n\t            'lightskyblue': [\n\t                135,\n\t                206,\n\t                250,\n\t                1\n\t            ],\n\t            'lightslategray': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightslategrey': [\n\t                119,\n\t                136,\n\t                153,\n\t                1\n\t            ],\n\t            'lightsteelblue': [\n\t                176,\n\t                196,\n\t                222,\n\t                1\n\t            ],\n\t            'lightyellow': [\n\t                255,\n\t                255,\n\t                224,\n\t                1\n\t            ],\n\t            'lime': [\n\t                0,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'limegreen': [\n\t                50,\n\t                205,\n\t                50,\n\t                1\n\t            ],\n\t            'linen': [\n\t                250,\n\t                240,\n\t                230,\n\t                1\n\t            ],\n\t            'magenta': [\n\t                255,\n\t                0,\n\t                255,\n\t                1\n\t            ],\n\t            'maroon': [\n\t                128,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'mediumaquamarine': [\n\t                102,\n\t                205,\n\t                170,\n\t                1\n\t            ],\n\t            'mediumblue': [\n\t                0,\n\t                0,\n\t                205,\n\t                1\n\t            ],\n\t            'mediumorchid': [\n\t                186,\n\t                85,\n\t                211,\n\t                1\n\t            ],\n\t            'mediumpurple': [\n\t                147,\n\t                112,\n\t                219,\n\t                1\n\t            ],\n\t            'mediumseagreen': [\n\t                60,\n\t                179,\n\t                113,\n\t                1\n\t            ],\n\t            'mediumslateblue': [\n\t                123,\n\t                104,\n\t                238,\n\t                1\n\t            ],\n\t            'mediumspringgreen': [\n\t                0,\n\t                250,\n\t                154,\n\t                1\n\t            ],\n\t            'mediumturquoise': [\n\t                72,\n\t                209,\n\t                204,\n\t                1\n\t            ],\n\t            'mediumvioletred': [\n\t                199,\n\t                21,\n\t                133,\n\t                1\n\t            ],\n\t            'midnightblue': [\n\t                25,\n\t                25,\n\t                112,\n\t                1\n\t            ],\n\t            'mintcream': [\n\t                245,\n\t                255,\n\t                250,\n\t                1\n\t            ],\n\t            'mistyrose': [\n\t                255,\n\t                228,\n\t                225,\n\t                1\n\t            ],\n\t            'moccasin': [\n\t                255,\n\t                228,\n\t                181,\n\t                1\n\t            ],\n\t            'navajowhite': [\n\t                255,\n\t                222,\n\t                173,\n\t                1\n\t            ],\n\t            'navy': [\n\t                0,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'oldlace': [\n\t                253,\n\t                245,\n\t                230,\n\t                1\n\t            ],\n\t            'olive': [\n\t                128,\n\t                128,\n\t                0,\n\t                1\n\t            ],\n\t            'olivedrab': [\n\t                107,\n\t                142,\n\t                35,\n\t                1\n\t            ],\n\t            'orange': [\n\t                255,\n\t                165,\n\t                0,\n\t                1\n\t            ],\n\t            'orangered': [\n\t                255,\n\t                69,\n\t                0,\n\t                1\n\t            ],\n\t            'orchid': [\n\t                218,\n\t                112,\n\t                214,\n\t                1\n\t            ],\n\t            'palegoldenrod': [\n\t                238,\n\t                232,\n\t                170,\n\t                1\n\t            ],\n\t            'palegreen': [\n\t                152,\n\t                251,\n\t                152,\n\t                1\n\t            ],\n\t            'paleturquoise': [\n\t                175,\n\t                238,\n\t                238,\n\t                1\n\t            ],\n\t            'palevioletred': [\n\t                219,\n\t                112,\n\t                147,\n\t                1\n\t            ],\n\t            'papayawhip': [\n\t                255,\n\t                239,\n\t                213,\n\t                1\n\t            ],\n\t            'peachpuff': [\n\t                255,\n\t                218,\n\t                185,\n\t                1\n\t            ],\n\t            'peru': [\n\t                205,\n\t                133,\n\t                63,\n\t                1\n\t            ],\n\t            'pink': [\n\t                255,\n\t                192,\n\t                203,\n\t                1\n\t            ],\n\t            'plum': [\n\t                221,\n\t                160,\n\t                221,\n\t                1\n\t            ],\n\t            'powderblue': [\n\t                176,\n\t                224,\n\t                230,\n\t                1\n\t            ],\n\t            'purple': [\n\t                128,\n\t                0,\n\t                128,\n\t                1\n\t            ],\n\t            'red': [\n\t                255,\n\t                0,\n\t                0,\n\t                1\n\t            ],\n\t            'rosybrown': [\n\t                188,\n\t                143,\n\t                143,\n\t                1\n\t            ],\n\t            'royalblue': [\n\t                65,\n\t                105,\n\t                225,\n\t                1\n\t            ],\n\t            'saddlebrown': [\n\t                139,\n\t                69,\n\t                19,\n\t                1\n\t            ],\n\t            'salmon': [\n\t                250,\n\t                128,\n\t                114,\n\t                1\n\t            ],\n\t            'sandybrown': [\n\t                244,\n\t                164,\n\t                96,\n\t                1\n\t            ],\n\t            'seagreen': [\n\t                46,\n\t                139,\n\t                87,\n\t                1\n\t            ],\n\t            'seashell': [\n\t                255,\n\t                245,\n\t                238,\n\t                1\n\t            ],\n\t            'sienna': [\n\t                160,\n\t                82,\n\t                45,\n\t                1\n\t            ],\n\t            'silver': [\n\t                192,\n\t                192,\n\t                192,\n\t                1\n\t            ],\n\t            'skyblue': [\n\t                135,\n\t                206,\n\t                235,\n\t                1\n\t            ],\n\t            'slateblue': [\n\t                106,\n\t                90,\n\t                205,\n\t                1\n\t            ],\n\t            'slategray': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'slategrey': [\n\t                112,\n\t                128,\n\t                144,\n\t                1\n\t            ],\n\t            'snow': [\n\t                255,\n\t                250,\n\t                250,\n\t                1\n\t            ],\n\t            'springgreen': [\n\t                0,\n\t                255,\n\t                127,\n\t                1\n\t            ],\n\t            'steelblue': [\n\t                70,\n\t                130,\n\t                180,\n\t                1\n\t            ],\n\t            'tan': [\n\t                210,\n\t                180,\n\t                140,\n\t                1\n\t            ],\n\t            'teal': [\n\t                0,\n\t                128,\n\t                128,\n\t                1\n\t            ],\n\t            'thistle': [\n\t                216,\n\t                191,\n\t                216,\n\t                1\n\t            ],\n\t            'tomato': [\n\t                255,\n\t                99,\n\t                71,\n\t                1\n\t            ],\n\t            'turquoise': [\n\t                64,\n\t                224,\n\t                208,\n\t                1\n\t            ],\n\t            'violet': [\n\t                238,\n\t                130,\n\t                238,\n\t                1\n\t            ],\n\t            'wheat': [\n\t                245,\n\t                222,\n\t                179,\n\t                1\n\t            ],\n\t            'white': [\n\t                255,\n\t                255,\n\t                255,\n\t                1\n\t            ],\n\t            'whitesmoke': [\n\t                245,\n\t                245,\n\t                245,\n\t                1\n\t            ],\n\t            'yellow': [\n\t                255,\n\t                255,\n\t                0,\n\t                1\n\t            ],\n\t            'yellowgreen': [\n\t                154,\n\t                205,\n\t                50,\n\t                1\n\t            ]\n\t        };\n\t    function clampCssByte(i) {\n\t        // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t    function clampCssAngle(i) {\n\t        // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);\n\t        // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t    function clampCssFloat(f) {\n\t        // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t    function parseCssInt(str) {\n\t        // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t    function parseCssFloat(str) {\n\t        // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        } else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();    // dup.\n\t        }\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 4095)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n\t                    iv & 240 | (iv & 240) >> 4,\n\t                    iv & 15 | (iv & 15) << 4,\n\t                    1\n\t                ];\n\t            } else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);\n\t                // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 16777215)) {\n\t                    return;    // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 16711680) >> 16,\n\t                    (iv & 65280) >> 8,\n\t                    iv & 255,\n\t                    1\n\t                ];\n\t            }\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;\n\t            // To allow case fallthrough.\n\t            switch (fname) {\n\t            case 'rgba':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                alpha = parseCssFloat(params.pop());\n\t            // jshint ignore:line\n\t            // Fall through.\n\t            case 'rgb':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return [\n\t                    parseCssInt(params[0]),\n\t                    parseCssInt(params[1]),\n\t                    parseCssInt(params[2]),\n\t                    alpha\n\t                ];\n\t            case 'hsla':\n\t                if (params.length !== 4) {\n\t                    return;\n\t                }\n\t                params[3] = parseCssFloat(params[3]);\n\t                return hsla2rgba(params);\n\t            case 'hsl':\n\t                if (params.length !== 3) {\n\t                    return;\n\t                }\n\t                return hsla2rgba(params);\n\t            default:\n\t                return;\n\t            }\n\t        }\n\t        return;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n\t        // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t        var rgba = [\n\t                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t            ];\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t        return rgba;\n\t    }\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t        var vMin = Math.min(R, G, B);\n\t        // Min. value of RGB\n\t        var vMax = Math.max(R, G, B);\n\t        // Max. value of RGB\n\t        var delta = vMax - vMin;\n\t        // Delta RGB value\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        } else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            } else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            } else if (G === vMax) {\n\t                H = 1 / 3 + deltaR - deltaB;\n\t            } else if (B === vMax) {\n\t                H = 2 / 3 + deltaG - deltaR;\n\t            }\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t        var hsla = [\n\t                H * 360,\n\t                S,\n\t                L\n\t            ];\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t        return hsla;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                } else {\n\t                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t        }\n\t    }\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        out = out || [\n\t            0,\n\t            0,\n\t            0,\n\t            0\n\t        ];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t            return;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t        var color = stringify([\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ], 'rgba');\n\t        return fullOutput ? {\n\t            color: color,\n\t            leftIndex: leftIndex,\n\t            rightIndex: rightIndex,\n\t            value: value\n\t        } : color;\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t    return {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t});\n\tdefine('zrender/core/timsort', [], function () {\n\t    var DEFAULT_MIN_MERGE = 32;\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t        return n + r;\n\t    }\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t            reverseRun(array, lo, runHi);\n\t        } else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t        return runHi - lo;\n\t    }\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                } else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t            var n = start - left;\n\t            switch (n) {\n\t            case 3:\n\t                array[left + 3] = array[left + 2];\n\t            case 2:\n\t                array[left + 2] = array[left + 1];\n\t            case 1:\n\t                array[left + 1] = array[left];\n\t                break;\n\t            default:\n\t                while (n > 0) {\n\t                    array[left + n] = array[left + n - 1];\n\t                    n--;\n\t                }\n\t            }\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        } else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            } else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        } else {\n\t            maxOffset = length - hint;\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            } else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t        length = array.length;\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t        var tmp = [];\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t        runStart = [];\n\t        runLength = [];\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                } else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t            runLength[i] = length1 + length2;\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t            stackSize--;\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            } else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t            array[dest++] = array[cursor2++];\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = array[cursor2++];\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            minGallop < 1 && (minGallop = 1);\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            } else if (length1 === 0) {\n\t                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n\t            } else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t        function mergeHigh(start1, length1, start2, length2) {\n\t            var i = 0;\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t            array[dest--] = array[cursor1--];\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t                return;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t            var _minGallop = minGallop;\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    } else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = tmp[cursor2--];\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest--] = array[cursor1--];\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t                if (exit) {\n\t                    break;\n\t                }\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t                _minGallop += 2;\n\t            }\n\t            minGallop = _minGallop;\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t                array[dest] = tmp[cursor2];\n\t            } else if (length2 === 0) {\n\t                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n\t            } else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t        var remaining = hi - lo;\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t        var runLength = 0;\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t        var ts = new TimSort(array, compare);\n\t        var minRun = minRunLength(remaining);\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t        ts.forceMergeRuns();\n\t    }\n\t    return sort;\n\t});\n\tdefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n\t    var Gradient = require('zrender/graphic/Gradient');\n\t    return function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n\t            // Default color\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n\t                    });\n\t                }\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\t});\n\tdefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var compatStyle = require('./helper/compatStyle');\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t    var LAYOUT_PROPERTIES = [\n\t            [\n\t                'x',\n\t                'left'\n\t            ],\n\t            [\n\t                'y',\n\t                'top'\n\t            ],\n\t            [\n\t                'x2',\n\t                'right'\n\t            ],\n\t            [\n\t                'y2',\n\t                'bottom'\n\t            ]\n\t        ];\n\t    var COMPATITABLE_COMPONENTS = [\n\t            'grid',\n\t            'geo',\n\t            'parallel',\n\t            'legend',\n\t            'toolbox',\n\t            'title',\n\t            'visualMap',\n\t            'dataZoom',\n\t            'timeline'\n\t        ];\n\t    var COMPATITABLE_SERIES = [\n\t            'bar',\n\t            'boxplot',\n\t            'candlestick',\n\t            'chord',\n\t            'effectScatter',\n\t            'funnel',\n\t            'gauge',\n\t            'lines',\n\t            'graph',\n\t            'heatmap',\n\t            'line',\n\t            'map',\n\t            'parallel',\n\t            'pie',\n\t            'radar',\n\t            'sankey',\n\t            'scatter',\n\t            'treemap'\n\t        ];\n\t    var each = zrUtil.each;\n\t    return function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t            var seriesType = seriesOpt.type;\n\t            compatStyle(seriesOpt);\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\t});\n\tdefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n\t    var graphic = require('../util/graphic');\n\t    var zrUtil = require('zrender/core/util');\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    return function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t                style: { fill: opts.maskColor },\n\t                zlevel: opts.zlevel,\n\t                z: 10000\n\t            });\n\t        var arc = new graphic.Arc({\n\t                shape: {\n\t                    startAngle: -PI / 2,\n\t                    endAngle: -PI / 2 + 0.1,\n\t                    r: 10\n\t                },\n\t                style: {\n\t                    stroke: opts.color,\n\t                    lineCap: 'round',\n\t                    lineWidth: 5\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        var labelRect = new graphic.Rect({\n\t                style: {\n\t                    fill: 'none',\n\t                    text: opts.text,\n\t                    textPosition: 'right',\n\t                    textDistance: 10,\n\t                    textFill: opts.textColor\n\t                },\n\t                zlevel: opts.zlevel,\n\t                z: 10001\n\t            });\n\t        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n\t        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\t});\n\tdefine('zrender/core/matrix', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t            create: function () {\n\t                var out = new ArrayCtor(6);\n\t                matrix.identity(out);\n\t                return out;\n\t            },\n\t            identity: function (out) {\n\t                out[0] = 1;\n\t                out[1] = 0;\n\t                out[2] = 0;\n\t                out[3] = 1;\n\t                out[4] = 0;\n\t                out[5] = 0;\n\t                return out;\n\t            },\n\t            copy: function (out, m) {\n\t                out[0] = m[0];\n\t                out[1] = m[1];\n\t                out[2] = m[2];\n\t                out[3] = m[3];\n\t                out[4] = m[4];\n\t                out[5] = m[5];\n\t                return out;\n\t            },\n\t            mul: function (out, m1, m2) {\n\t                // Consider matrix.mul(m, m2, m);\n\t                // where out is the same as m2.\n\t                // So use temp variable to escape error.\n\t                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t                out[0] = out0;\n\t                out[1] = out1;\n\t                out[2] = out2;\n\t                out[3] = out3;\n\t                out[4] = out4;\n\t                out[5] = out5;\n\t                return out;\n\t            },\n\t            translate: function (out, a, v) {\n\t                out[0] = a[0];\n\t                out[1] = a[1];\n\t                out[2] = a[2];\n\t                out[3] = a[3];\n\t                out[4] = a[4] + v[0];\n\t                out[5] = a[5] + v[1];\n\t                return out;\n\t            },\n\t            rotate: function (out, a, rad) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var st = Math.sin(rad);\n\t                var ct = Math.cos(rad);\n\t                out[0] = aa * ct + ab * st;\n\t                out[1] = -aa * st + ab * ct;\n\t                out[2] = ac * ct + ad * st;\n\t                out[3] = -ac * st + ct * ad;\n\t                out[4] = ct * atx + st * aty;\n\t                out[5] = ct * aty - st * atx;\n\t                return out;\n\t            },\n\t            scale: function (out, a, v) {\n\t                var vx = v[0];\n\t                var vy = v[1];\n\t                out[0] = a[0] * vx;\n\t                out[1] = a[1] * vy;\n\t                out[2] = a[2] * vx;\n\t                out[3] = a[3] * vy;\n\t                out[4] = a[4] * vx;\n\t                out[5] = a[5] * vy;\n\t                return out;\n\t            },\n\t            invert: function (out, a) {\n\t                var aa = a[0];\n\t                var ac = a[2];\n\t                var atx = a[4];\n\t                var ab = a[1];\n\t                var ad = a[3];\n\t                var aty = a[5];\n\t                var det = aa * ad - ab * ac;\n\t                if (!det) {\n\t                    return null;\n\t                }\n\t                det = 1 / det;\n\t                out[0] = ad * det;\n\t                out[1] = -ab * det;\n\t                out[2] = -ac * det;\n\t                out[3] = aa * det;\n\t                out[4] = (ac * aty - ad * atx) * det;\n\t                out[5] = (ab * atx - aa * aty) * det;\n\t                return out;\n\t            }\n\t        };\n\t    return matrix;\n\t});\n\tdefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazzUtil = require('../util/clazz');\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;    // Simple optimization\n\t                                 // if (this.init) {\n\t                                 //     if (arguments.length <= 4) {\n\t                                 //         this.init(option, parentModel, ecModel, extraOpt);\n\t                                 //     }\n\t                                 //     else {\n\t                                 //         this.init.apply(this, arguments);\n\t                                 //     }\n\t                                 // }\n\t    }\n\t    Model.prototype = {\n\t        constructor: Model,\n\t        init: null,\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n\t            return model;\n\t        },\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t        restoreData: function () {\n\t        },\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, require('./mixin/lineStyle'));\n\t    mixin(Model, require('./mixin/areaStyle'));\n\t    mixin(Model, require('./mixin/textStyle'));\n\t    mixin(Model, require('./mixin/itemStyle'));\n\t    return Model;\n\t});\n\tdefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n\t    var dataCtors = {\n\t            'float': Float64Array,\n\t            'int': Int32Array,\n\t            'ordinal': Array,\n\t            'number': Array,\n\t            'time': Array\n\t        };\n\t    var Model = require('../model/Model');\n\t    var DataDiffer = require('./DataDiffer');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../util/model');\n\t    var isObject = zrUtil.isObject;\n\t    var TRANSFERABLE_PROPERTIES = [\n\t            'stackedOn',\n\t            'hasItemOption',\n\t            '_nameList',\n\t            '_idList',\n\t            '_rawData'\n\t        ];\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t        dimensions = dimensions || [\n\t            'x',\n\t            'y'\n\t        ];\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    type: 'number'\n\t                };\n\t            } else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t    var listProto = List.prototype;\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        this._rawData = data;\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t        nameList = nameList || [];\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n\t        };\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t            indices.push(idx);\n\t        }\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t        return values;\n\t    };\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = dimInfo && dimInfo.stackable && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return this._extent[dim + !!stack] = [\n\t                min,\n\t                max\n\t            ];\n\t        } else {\n\t            return [\n\t                Infinity,\n\t                -Infinity\n\t            ];\n\t        }\n\t    };\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            } else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            } else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n\t    };\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t            case 0:\n\t                cb.call(context, i);\n\t                break;\n\t            case 1:\n\t                cb.call(context, this.get(dims[0], i, stack), i);\n\t                break;\n\t            case 2:\n\t                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                break;\n\t            default:\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dims[k], i, stack);\n\t                }\n\t                // Index\n\t                value[k] = i;\n\t                cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t        context = context || this;\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n\t            } else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t        this.indices = newIndices;\n\t        // Reset data extent\n\t        this._extent = {};\n\t        return this;\n\t    };\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n\t            } else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t        var storage = list._storage;\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t        return list;\n\t    };\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n\t            return otherIdList[idx] || idx + '';\n\t        }, function (idx) {\n\t            return idList[idx] || idx + '';\n\t        });\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n\t    };\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t        this._graphicEls[idx] = el;\n\t    };\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t        // FIXME\n\t        list._storage = this._storage;\n\t        transferProperties(list, this);\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t        return list;\n\t    };\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = [\n\t        'cloneShallow',\n\t        'downSample',\n\t        'map'\n\t    ];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t    return List;\n\t});\n\tdefine('zrender/core/vector', [], function () {\n\t    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t            create: function (x, y) {\n\t                var out = new ArrayCtor(2);\n\t                if (x == null) {\n\t                    x = 0;\n\t                }\n\t                if (y == null) {\n\t                    y = 0;\n\t                }\n\t                out[0] = x;\n\t                out[1] = y;\n\t                return out;\n\t            },\n\t            copy: function (out, v) {\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            clone: function (v) {\n\t                var out = new ArrayCtor(2);\n\t                out[0] = v[0];\n\t                out[1] = v[1];\n\t                return out;\n\t            },\n\t            set: function (out, a, b) {\n\t                out[0] = a;\n\t                out[1] = b;\n\t                return out;\n\t            },\n\t            add: function (out, v1, v2) {\n\t                out[0] = v1[0] + v2[0];\n\t                out[1] = v1[1] + v2[1];\n\t                return out;\n\t            },\n\t            scaleAndAdd: function (out, v1, v2, a) {\n\t                out[0] = v1[0] + v2[0] * a;\n\t                out[1] = v1[1] + v2[1] * a;\n\t                return out;\n\t            },\n\t            sub: function (out, v1, v2) {\n\t                out[0] = v1[0] - v2[0];\n\t                out[1] = v1[1] - v2[1];\n\t                return out;\n\t            },\n\t            len: function (v) {\n\t                return Math.sqrt(this.lenSquare(v));\n\t            },\n\t            lenSquare: function (v) {\n\t                return v[0] * v[0] + v[1] * v[1];\n\t            },\n\t            mul: function (out, v1, v2) {\n\t                out[0] = v1[0] * v2[0];\n\t                out[1] = v1[1] * v2[1];\n\t                return out;\n\t            },\n\t            div: function (out, v1, v2) {\n\t                out[0] = v1[0] / v2[0];\n\t                out[1] = v1[1] / v2[1];\n\t                return out;\n\t            },\n\t            dot: function (v1, v2) {\n\t                return v1[0] * v2[0] + v1[1] * v2[1];\n\t            },\n\t            scale: function (out, v, s) {\n\t                out[0] = v[0] * s;\n\t                out[1] = v[1] * s;\n\t                return out;\n\t            },\n\t            normalize: function (out, v) {\n\t                var d = vector.len(v);\n\t                if (d === 0) {\n\t                    out[0] = 0;\n\t                    out[1] = 0;\n\t                } else {\n\t                    out[0] = v[0] / d;\n\t                    out[1] = v[1] / d;\n\t                }\n\t                return out;\n\t            },\n\t            distance: function (v1, v2) {\n\t                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t            },\n\t            distanceSquare: function (v1, v2) {\n\t                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t            },\n\t            negate: function (out, v) {\n\t                out[0] = -v[0];\n\t                out[1] = -v[1];\n\t                return out;\n\t            },\n\t            lerp: function (out, v1, v2, t) {\n\t                out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t                out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t                return out;\n\t            },\n\t            applyTransform: function (out, v, m) {\n\t                var x = v[0];\n\t                var y = v[1];\n\t                out[0] = m[0] * x + m[2] * y + m[4];\n\t                out[1] = m[1] * x + m[3] * y + m[5];\n\t                return out;\n\t            },\n\t            min: function (out, v1, v2) {\n\t                out[0] = Math.min(v1[0], v2[0]);\n\t                out[1] = Math.min(v1[1], v2[1]);\n\t                return out;\n\t            },\n\t            max: function (out, v1, v2) {\n\t                out[0] = Math.max(v1[0], v2[0]);\n\t                out[1] = Math.max(v1[1], v2[1]);\n\t                return out;\n\t            }\n\t        };\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t    return vector;\n\t});\n\tdefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n\t    var clazzUtil = require('../util/clazz');\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [\n\t            Infinity,\n\t            -Infinity\n\t        ];\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t    var scaleProto = Scale.prototype;\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n\t                                                           // this.setExtent(extent[0], extent[1]);\n\t    };\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n\t    return Scale;\n\t});\n\tdefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n\t    var OrdinalScale = require('../scale/Ordinal');\n\t    var IntervalScale = require('../scale/Interval');\n\t    require('../scale/Time');\n\t    require('../scale/Log');\n\t    var Scale = require('../scale/Scale');\n\t    var numberUtil = require('../util/number');\n\t    var zrUtil = require('zrender/core/util');\n\t    var textContain = require('zrender/contain/text');\n\t    var axisHelper = {};\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [\n\t                    0,\n\t                    0\n\t                ];\n\t            } else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [\n\t                boundaryGap || 0,\n\t                boundaryGap || 0\n\t            ];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [\n\t            min,\n\t            max\n\t        ];\n\t    };\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function (model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t            // Buildin scale\n\t            case 'category':\n\t                return new OrdinalScale(model.getCategories(), [\n\t                    Infinity,\n\t                    -Infinity\n\t                ]);\n\t            case 'value':\n\t                return new IntervalScale();\n\t            // Extended scale, like time and log\n\t            default:\n\t                return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !(min > 0 && max > 0 || min < 0 && max < 0);\n\t    };\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // axislabelhorizontalvertical.\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }    // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            } else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            }(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        } else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n\t            }, this);\n\t        } else {\n\t            return labels;\n\t        }\n\t    };\n\t    return axisHelper;\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var Cartesian = require('./Cartesian');\n\t    function Cartesian2D(name) {\n\t        Cartesian.call(this, name);\n\t    }\n\t    Cartesian2D.prototype = {\n\t        constructor: Cartesian2D,\n\t        type: 'cartesian2d',\n\t        dimensions: [\n\t            'x',\n\t            'y'\n\t        ],\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n\t        },\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n\t        },\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray([\n\t                'x',\n\t                'y'\n\t            ], function (x, y) {\n\t                return this.dataToPoint([\n\t                    x,\n\t                    y\n\t                ]);\n\t            }, stack, this);\n\t        },\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t    return Cartesian2D;\n\t});\n\tdefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Axis = require('../Axis');\n\t    var axisLabelInterval = require('./axisLabelInterval');\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t    Axis2D.prototype = {\n\t        constructor: Axis2D,\n\t        index: 0,\n\t        onZero: false,\n\t        model: null,\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t        toLocalCoord: null,\n\t        toGlobalCoord: null\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t    return Axis2D;\n\t});\n\tdefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n\t    'use strict';\n\t    require('./AxisModel');\n\t    var ComponentModel = require('../../model/Component');\n\t    return ComponentModel.extend({\n\t        type: 'grid',\n\t        dependencies: [\n\t            'xAxis',\n\t            'yAxis'\n\t        ],\n\t        layoutMode: 'box',\n\t        coordinateSystem: null,\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            containLabel: false,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\t});\n\tdefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n\t    var Path = require('../graphic/Path');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var transformPath = require('./transformPath');\n\t    var matrix = require('../core/matrix');\n\t    // command chars\n\t    var cc = [\n\t            'm',\n\t            'M',\n\t            'l',\n\t            'L',\n\t            'v',\n\t            'V',\n\t            'h',\n\t            'H',\n\t            'z',\n\t            'Z',\n\t            'c',\n\t            'C',\n\t            'q',\n\t            'Q',\n\t            't',\n\t            'T',\n\t            's',\n\t            'S',\n\t            'a',\n\t            'A'\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t    var vMag = function (v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function (u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function (u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t    };\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n\t        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t        var theta = vAngle([\n\t                1,\n\t                0\n\t            ], [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ]);\n\t        var u = [\n\t                (xp - cxp) / rx,\n\t                (yp - cyp) / ry\n\t            ];\n\t        var v = [\n\t                (-1 * xp - cxp) / rx,\n\t                (-1 * yp - cyp) / ry\n\t            ];\n\t        var dTheta = vAngle(u, v);\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                case 'l':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'L':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'm':\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'l';\n\t                    break;\n\t                case 'M':\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.M;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    c = 'L';\n\t                    break;\n\t                case 'h':\n\t                    cpx += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'H':\n\t                    cpx = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'v':\n\t                    cpy += p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'V':\n\t                    cpy = p[off++];\n\t                    cmd = CMD.L;\n\t                    path.addData(cmd, cpx, cpy);\n\t                    break;\n\t                case 'C':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t                    cpx = p[off - 2];\n\t                    cpy = p[off - 1];\n\t                    break;\n\t                case 'c':\n\t                    cmd = CMD.C;\n\t                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t                    cpx += p[off - 2];\n\t                    cpy += p[off - 1];\n\t                    break;\n\t                case 'S':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 's':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.C) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cmd = CMD.C;\n\t                    x1 = cpx + p[off++];\n\t                    y1 = cpy + p[off++];\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'Q':\n\t                    x1 = p[off++];\n\t                    y1 = p[off++];\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'q':\n\t                    x1 = p[off++] + cpx;\n\t                    y1 = p[off++] + cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, x1, y1, cpx, cpy);\n\t                    break;\n\t                case 'T':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 't':\n\t                    ctlPtx = cpx;\n\t                    ctlPty = cpy;\n\t                    var len = path.len();\n\t                    var pathData = path.data;\n\t                    if (prevCmd === CMD.Q) {\n\t                        ctlPtx += cpx - pathData[len - 4];\n\t                        ctlPty += cpy - pathData[len - 3];\n\t                    }\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.Q;\n\t                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                    break;\n\t                case 'A':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx = p[off++];\n\t                    cpy = p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                case 'a':\n\t                    rx = p[off++];\n\t                    ry = p[off++];\n\t                    psi = p[off++];\n\t                    fa = p[off++];\n\t                    fs = p[off++];\n\t                    x1 = cpx, y1 = cpy;\n\t                    cpx += p[off++];\n\t                    cpy += p[off++];\n\t                    cmd = CMD.A;\n\t                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t                    break;\n\t                }\n\t            }\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t            prevCmd = cmd;\n\t        }\n\t        path.toStatic();\n\t        return path;\n\t    }\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t        return opts;\n\t    }\n\t    return {\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t            return pathBundle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var PathProxy = require('../core/PathProxy');\n\t    var pathContain = require('../contain/path');\n\t    var Pattern = require('./Pattern');\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t    var abs = Math.abs;\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t    Path.prototype = {\n\t        constructor: Path,\n\t        type: 'path',\n\t        __dirtyPath: true,\n\t        strokeContainThreshold: 5,\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!fill.colorStops;\n\t            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t            var hasFillPattern = hasFill && !!fill.image;\n\t            var hasStrokePattern = hasStroke && !!stroke.image;\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            } else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            } else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t                path = this.path.beginPath(ctx);\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t                this.buildPath(path, this.shape, false);\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            } else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t            hasFill && path.fill(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t            hasStroke && path.stroke(ctx);\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t            this.restoreTransform(ctx);\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t        buildPath: function (ctx, shapeCfg, inBundle) {\n\t        },\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t            return rect;\n\t        },\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            } else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                } else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t        }\n\t    };\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t        zrUtil.inherits(Sub, Path);\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t        return Sub;\n\t    };\n\t    zrUtil.inherits(Path, Displayable);\n\t    return Path;\n\t});\n\tdefine('zrender/graphic/Gradient', ['require'], function (require) {\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t        this.colorStops = colorStops || [];\n\t    };\n\t    Gradient.prototype = {\n\t        constructor: Gradient,\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t                offset: offset,\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t    return Gradient;\n\t});\n\tdefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Element = require('../Element');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t        this._children = [];\n\t        this.__storage = null;\n\t        this.__dirty = true;\n\t    };\n\t    Group.prototype = {\n\t        constructor: Group,\n\t        isGroup: true,\n\t        type: 'group',\n\t        silent: false,\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t            }\n\t        },\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t                this._children.push(child);\n\t                this._doAdd(child);\n\t            }\n\t            return this;\n\t        },\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t            child.parent = this;\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t        },\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t            child.parent = null;\n\t            if (storage) {\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t            zr && zr.refresh();\n\t            return this;\n\t        },\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t            return this;\n\t        },\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                } else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Group, Element);\n\t    return Group;\n\t});\n\tdefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var zrUtil = require('../core/util');\n\t    var textContain = require('../contain/text');\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t    Text.prototype = {\n\t        constructor: Text,\n\t        type: 'text',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t            if (text) {\n\t                this.setTransform(ctx);\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                    case 'middle':\n\t                        y -= rect.height / 2 - rect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= rect.height - rect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += rect.lineHeight / 2;\n\t                    }\n\t                } else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n\t                switch (textVerticalAlign) {\n\t                case 'middle':\n\t                    rect.y -= rect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    rect.y -= rect.height;\n\t                    break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(Text, Displayable);\n\t    return Text;\n\t});\n\tdefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n\t    var Displayable = require('./Displayable');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var zrUtil = require('../core/util');\n\t    var LRU = require('../core/LRU');\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t    ZImage.prototype = {\n\t        constructor: ZImage,\n\t        type: 'image',\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                } else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                // transform\n\t                this.setTransform(ctx);\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t                } else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t                } else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t                // \n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t                this.restoreTransform(ctx);\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t    zrUtil.inherits(ZImage, Displayable);\n\t    return ZImage;\n\t});\n\tdefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n\t    'use strict';\n\t    return require('../Path').extend({\n\t        type: 'circle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'ring',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'sector',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r0: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t            ctx.closePath();\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n\t    var roundRectHelper = require('../helper/roundRect');\n\t    return require('../Path').extend({\n\t        type: 'rect',\n\t        shape: {\n\t            r: 0,\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            } else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polygon',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n\t    var polyHelper = require('../helper/poly');\n\t    return require('../Path').extend({\n\t        type: 'polyline',\n\t        shape: {\n\t            points: null,\n\t            smooth: false,\n\t            smoothConstraint: null\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'line',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n\t    'use strict';\n\t    var curveTool = require('../../core/curve');\n\t    var vec2 = require('../../core/vector');\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t    var out = [];\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        } else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    return require('../Path').extend({\n\t        type: 'bezier-curve',\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            percent: 1\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t            ctx.moveTo(x1, y1);\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t            } else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t            }\n\t        },\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n\t    return require('../Path').extend({\n\t        type: 'arc',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            startAngle: 0,\n\t            endAngle: Math.PI * 2,\n\t            clockwise: true\n\t        },\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t        this.y = y == null ? 0.5 : y;\n\t        this.r = r == null ? 0.5 : r;\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    RadialGradient.prototype = { constructor: RadialGradient };\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t    return RadialGradient;\n\t});\n\tdefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('../core/util');\n\t    var Gradient = require('./Gradient');\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t        this.y = y == null ? 0 : y;\n\t        this.x2 = x2 == null ? 1 : x2;\n\t        this.y2 = y2 == null ? 0 : y2;\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t        Gradient.call(this, colorStops);\n\t    };\n\t    LinearGradient.prototype = { constructor: LinearGradient };\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t    return LinearGradient;\n\t});\n\tdefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n\t    var Path = require('./Path');\n\t    return Path.extend({\n\t        type: 'compound',\n\t        shape: { paths: null },\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\t});\n\tdefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var matrix = require('./matrix');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t    BoundingRect.prototype = {\n\t        constructor: BoundingRect,\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t        applyTransform: function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        }(),\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t            var m = matrix.create();\n\t            // \n\t            matrix.translate(m, m, [\n\t                -a.x,\n\t                -a.y\n\t            ]);\n\t            matrix.scale(m, m, [\n\t                sx,\n\t                sy\n\t            ]);\n\t            matrix.translate(m, m, [\n\t                b.x,\n\t                b.y\n\t            ]);\n\t            return m;\n\t        },\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t        },\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t    return BoundingRect;\n\t});\n\tdefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t    var util = require('../core/util');\n\t    var BoundingRect = require('../core/BoundingRect');\n\t    var retrieve = util.retrieve;\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t        return width;\n\t    }\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t        switch (textBaseline) {\n\t        case 'bottom':\n\t        case 'alphabetic':\n\t            rect.y -= lineHeight;\n\t            break;\n\t        case 'middle':\n\t            rect.y -= lineHeight / 2;\n\t            break;    // case 'hanging':\n\t                      // case 'top':\n\t        }\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t        case 'end':\n\t        case 'right':\n\t            rect.x -= rect.width;\n\t            break;\n\t        case 'center':\n\t            rect.x -= rect.width / 2;\n\t            break;    // case 'start':\n\t                      // case 'left':\n\t        }\n\t        return rect;\n\t    }\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t        var textHeight = textRect.height;\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t        var textAlign = 'left';\n\t        switch (textPosition) {\n\t        case 'left':\n\t            x -= distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'right':\n\t            x += distance + width;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'top':\n\t            x += width / 2;\n\t            y -= distance + textHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'bottom':\n\t            x += width / 2;\n\t            y += height + distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'inside':\n\t            x += width / 2;\n\t            y += halfHeight;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideLeft':\n\t            x += distance;\n\t            y += halfHeight;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideRight':\n\t            x += width - distance;\n\t            y += halfHeight;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideTop':\n\t            x += width / 2;\n\t            y += distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideBottom':\n\t            x += width / 2;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'center';\n\t            break;\n\t        case 'insideTopLeft':\n\t            x += distance;\n\t            y += distance;\n\t            textAlign = 'left';\n\t            break;\n\t        case 'insideTopRight':\n\t            x += width - distance;\n\t            y += distance;\n\t            textAlign = 'right';\n\t            break;\n\t        case 'insideBottomLeft':\n\t            x += distance;\n\t            y += height - textHeight - distance;\n\t            break;\n\t        case 'insideBottomRight':\n\t            x += width - distance;\n\t            y += height - textHeight - distance;\n\t            textAlign = 'right';\n\t            break;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t        options = options || {};\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n\t        // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t        var textLines = (text + '').split('\\n');\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t            textLines[i] = textLine;\n\t        }\n\t        return textLines.join('\\n');\n\t    }\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t    var textContain = {\n\t            getWidth: getTextWidth,\n\t            getBoundingRect: getTextRect,\n\t            adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t            truncateText: truncateText,\n\t            measureText: function (text, textFont) {\n\t                var ctx = util.getContext();\n\t                ctx.font = textFont || '12px sans-serif';\n\t                return ctx.measureText(text);\n\t            }\n\t        };\n\t    return textContain;\n\t});\n\tdefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n\t    var formatUtil = require('./format');\n\t    var nubmerUtil = require('./number');\n\t    var Model = require('../model/Model');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = {};\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array ? value : value == null ? [] : [value];\n\t    };\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t    modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    modelUtil.LABEL_OPTIONS = [\n\t        'position',\n\t        'show',\n\t        'textStyle',\n\t        'distance',\n\t        'formatter'\n\t    ];\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n\t                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n\t    };\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t                $vars: [\n\t                    'seriesName',\n\t                    'name',\n\t                    'value'\n\t                ]\n\t            };\n\t        },\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && params.value instanceof Array) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t            var formatter = itemModel.get([\n\t                    'label',\n\t                    status,\n\t                    'formatter'\n\t                ]);\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            } else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t                return { exist: obj };\n\t            });\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t            if (i >= result.length) {\n\t                result.push({ option: cptOption });\n\t            }\n\t        });\n\t        return result;\n\t    };\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n\t    };\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t        return [\n\t            mapToArray(mapA),\n\t            mapToArray(mapB)\n\t        ];\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    } else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    } else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({\n\t                            seriesId: i,\n\t                            dataIndex: dataIndices\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t    return modelUtil;\n\t});\n\tdefine('echarts/model/globalDefault', [], function () {\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    return {\n\t        color: [\n\t            '#c23531',\n\t            '#2f4554',\n\t            '#61a0a8',\n\t            '#d48265',\n\t            '#91c7ae',\n\t            '#749f83',\n\t            '#ca8622',\n\t            '#bda29a',\n\t            '#6e7074',\n\t            '#546570',\n\t            '#c4ccd3'\n\t        ],\n\t        textStyle: {\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t        blendMode: null,\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t        animationThreshold: 2000,\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t        hoverLayerThreshold: 3000\n\t    };\n\t});\n\tdefine('echarts/model/mixin/colorPalette', [], function () {\n\t    return {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t            return color;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n\t    'use strict';\n\t    var curve = require('./curve');\n\t    var vec2 = require('./vector');\n\t    var bbox = require('./bbox');\n\t    var BoundingRect = require('./BoundingRect');\n\t    var dpr = require('../config').devicePixelRatio;\n\t    var CMD = {\n\t            M: 1,\n\t            L: 2,\n\t            C: 3,\n\t            Q: 4,\n\t            A: 5,\n\t            Z: 6,\n\t            R: 7\n\t        };\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t        this._len = 0;\n\t        this._ctx = null;\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t        constructor: PathProxy,\n\t        _lineDash: null,\n\t        _dashOffset: 0,\n\t        _dashIdx: 0,\n\t        _dashSum: 0,\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t        beginPath: function (ctx) {\n\t            this._ctx = ctx;\n\t            ctx && ctx.beginPath();\n\t            ctx && (this.dpr = ctx.dpr);\n\t            // Reset\n\t            this._len = 0;\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t                this._dashOffset = 0;\n\t            }\n\t            return this;\n\t        },\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t            this._xi = x;\n\t            this._yi = y;\n\t            return this;\n\t        },\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n\t            this.addData(CMD.L, x, y);\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t            return this;\n\t        },\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t                this._dashIdx = 0;\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t        setData: function (data) {\n\t            var len = data.length;\n\t            if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t            this._len = len;\n\t        },\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && this.data instanceof Float32Array) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t            this._prevCmd = cmd;\n\t        },\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t            var x;\n\t            var y;\n\t            var tmpLen = 0;\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t            while (t <= 1) {\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t                t += lineDash[idx] / bezierLen;\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t            // Finish the last segment and calculate the new offset\n\t            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    min2[0] = x0;\n\t                    min2[1] = y0;\n\t                    max2[0] = x0;\n\t                    max2[1] = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++];\n\t                    var endAngle = data[i++] + startAngle;\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    if (i == 1) {\n\t                        //  arc \n\t                        // \n\t                        x0 = mathCos(startAngle) * rx + cx;\n\t                        y0 = mathSin(startAngle) * ry + cy;\n\t                    }\n\t                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    // Use fromLine\n\t                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                    break;\n\t                case CMD.Z:\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                }\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t        },\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                case CMD.M:\n\t                    x0 = xi = d[i++];\n\t                    y0 = yi = d[i++];\n\t                    ctx.moveTo(xi, yi);\n\t                    break;\n\t                case CMD.L:\n\t                    x = d[i++];\n\t                    y = d[i++];\n\t                    // Not draw too small seg between\n\t                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                        ctx.lineTo(x, y);\n\t                        xi = x;\n\t                        yi = y;\n\t                    }\n\t                    break;\n\t                case CMD.C:\n\t                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.Q:\n\t                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                    xi = d[i - 2];\n\t                    yi = d[i - 1];\n\t                    break;\n\t                case CMD.A:\n\t                    var cx = d[i++];\n\t                    var cy = d[i++];\n\t                    var rx = d[i++];\n\t                    var ry = d[i++];\n\t                    var theta = d[i++];\n\t                    var dTheta = d[i++];\n\t                    var psi = d[i++];\n\t                    var fs = d[i++];\n\t                    var r = rx > ry ? rx : ry;\n\t                    var scaleX = rx > ry ? 1 : rx / ry;\n\t                    var scaleY = rx > ry ? ry / rx : 1;\n\t                    var isEllipse = Math.abs(rx - ry) > 0.001;\n\t                    var endAngle = theta + dTheta;\n\t                    if (isEllipse) {\n\t                        ctx.translate(cx, cy);\n\t                        ctx.rotate(psi);\n\t                        ctx.scale(scaleX, scaleY);\n\t                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                        ctx.scale(1 / scaleX, 1 / scaleY);\n\t                        ctx.rotate(-psi);\n\t                        ctx.translate(-cx, -cy);\n\t                    } else {\n\t                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                    }\n\t                    if (i == 1) {\n\t                        //  arc \n\t                        // \n\t                        x0 = mathCos(theta) * rx + cx;\n\t                        y0 = mathSin(theta) * ry + cy;\n\t                    }\n\t                    xi = mathCos(endAngle) * rx + cx;\n\t                    yi = mathSin(endAngle) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = d[i];\n\t                    y0 = yi = d[i + 1];\n\t                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                    break;\n\t                case CMD.Z:\n\t                    ctx.closePath();\n\t                    xi = x0;\n\t                    yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    PathProxy.CMD = CMD;\n\t    return PathProxy;\n\t});\n\tdefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var vec2 = require('../core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var points = [\n\t            [],\n\t            [],\n\t            []\n\t        ];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t            case M:\n\t                nPoint = 1;\n\t                break;\n\t            case L:\n\t                nPoint = 1;\n\t                break;\n\t            case C:\n\t                nPoint = 3;\n\t                break;\n\t            case Q:\n\t                nPoint = 2;\n\t                break;\n\t            case A:\n\t                var x = m[4];\n\t                var y = m[5];\n\t                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                // cx\n\t                data[i++] += x;\n\t                // cy\n\t                data[i++] += y;\n\t                // Scale rx and ry\n\t                // FIXME Assume psi is 0 here\n\t                data[i++] *= sx;\n\t                data[i++] *= sy;\n\t                // Start angle\n\t                data[i++] += angle;\n\t                // end angle\n\t                data[i++] += angle;\n\t                // FIXME psi\n\t                i += 2;\n\t                j = i;\n\t                break;\n\t            case R:\n\t                // x0, y0\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t                // x1, y1\n\t                p[0] += data[i++];\n\t                p[1] += data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t    return transformPath;\n\t});\n\tdefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = {};\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t            var ret = {\n\t                    main: '',\n\t                    sub: ''\n\t                };\n\t            if (componentType) {\n\t                componentType = componentType.split(TYPE_DELIMITER);\n\t                ret.main = componentType[0] || '';\n\t                ret.sub = componentType[1] || '';\n\t            }\n\t            return ret;\n\t        };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass) {\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                } else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t                if (!componentType.sub) {\n\t                    if (true) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                } else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n\t            }\n\t            return Clazz;\n\t        };\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            } else {\n\t                result.push(obj);\n\t            }\n\t            return result;\n\t        };\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t        entity.parseClassType = parseClassType;\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t        return entity;\n\t    };\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t    };\n\t    return clazz;\n\t});\n\tdefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n\t    var zrUtil = require('../core/util');\n\t    var Style = require('./Style');\n\t    var Element = require('../Element');\n\t    var RectText = require('./mixin/RectText');\n\t    // var Stateful = require('./mixin/Stateful');\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t        opts = opts || {};\n\t        Element.call(this, opts);\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (opts.hasOwnProperty(name) && name !== 'style') {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n\t                                  // Stateful.call(this, opts);\n\t    }\n\t    Displayable.prototype = {\n\t        constructor: Displayable,\n\t        type: 'displayable',\n\t        __dirty: true,\n\t        invisible: false,\n\t        z: 0,\n\t        z2: 0,\n\t        zlevel: 0,\n\t        draggable: false,\n\t        dragging: false,\n\t        silent: false,\n\t        culling: false,\n\t        cursor: 'pointer',\n\t        rectHover: false,\n\t        progressive: -1,\n\t        beforeBrush: function (ctx) {\n\t        },\n\t        afterBrush: function (ctx) {\n\t        },\n\t        brush: function (ctx, prevEl) {\n\t        },\n\t        getBoundingRect: function () {\n\t        },\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this._rect = null;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            } else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t    zrUtil.inherits(Displayable, Element);\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t    return Displayable;\n\t});\n\tdefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n\t    'use strict';\n\t    var CMD = require('../core/PathProxy').CMD;\n\t    var line = require('./line');\n\t    var cubic = require('./cubic');\n\t    var quadratic = require('./quadratic');\n\t    var arc = require('./arc');\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var curve = require('../core/curve');\n\t    var windingLine = require('./windingLine');\n\t    var containStroke = line.containStroke;\n\t    var PI2 = Math.PI * 2;\n\t    var EPSILON = 0.0001;\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t    // \n\t    var roots = [\n\t            -1,\n\t            -1,\n\t            -1\n\t        ];\n\t    var extrema = [\n\t            -1,\n\t            -1\n\t        ];\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                } else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        } else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {\n\t                        // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    } else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            } else {\n\t                // Remove one endpoint.\n\t                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {\n\t                    // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t    // TODO\n\t    // Arc \n\t    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 0.0001) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 0.0001) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        } else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }    //  subpath \n\t                     // if (w !== 0) {\n\t                     //     return true;\n\t                     // }\n\t            }\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t            switch (cmd) {\n\t            case CMD.M:\n\t                // moveTo  subpath, \n\t                //  closePath \n\t                x0 = data[i++];\n\t                y0 = data[i++];\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            case CMD.L:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // NOTE  L, C, Q  NaN\n\t                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.C:\n\t                if (isStroke) {\n\t                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.Q:\n\t                if (isStroke) {\n\t                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t                }\n\t                xi = data[i++];\n\t                yi = data[i++];\n\t                break;\n\t            case CMD.A:\n\t                // TODO Arc \n\t                var cx = data[i++];\n\t                var cy = data[i++];\n\t                var rx = data[i++];\n\t                var ry = data[i++];\n\t                var theta = data[i++];\n\t                var dTheta = data[i++];\n\t                // TODO Arc \n\t                var psi = data[i++];\n\t                var anticlockwise = 1 - data[i++];\n\t                var x1 = Math.cos(theta) * rx + cx;\n\t                var y1 = Math.sin(theta) * ry + cy;\n\t                //  arc \n\t                if (i > 1) {\n\t                    w += windingLine(xi, yi, x1, y1, x, y);\n\t                } else {\n\t                    // \n\t                    x0 = x1;\n\t                    y0 = y1;\n\t                }\n\t                // zr scale, x\n\t                var _x = (x - cx) * ry / rx + cx;\n\t                if (isStroke) {\n\t                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t                }\n\t                xi = Math.cos(theta + dTheta) * rx + cx;\n\t                yi = Math.sin(theta + dTheta) * ry + cy;\n\t                break;\n\t            case CMD.R:\n\t                x0 = xi = data[i++];\n\t                y0 = yi = data[i++];\n\t                var width = data[i++];\n\t                var height = data[i++];\n\t                var x1 = x0 + width;\n\t                var y1 = y0 + height;\n\t                if (isStroke) {\n\t                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // FIXME Clockwise ?\n\t                    w += windingLine(x1, y0, x1, y1, x, y);\n\t                    w += windingLine(x0, y1, x0, y0, x, y);\n\t                }\n\t                break;\n\t            case CMD.Z:\n\t                if (isStroke) {\n\t                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t                        return true;\n\t                    }\n\t                } else {\n\t                    // Close a subpath\n\t                    w += windingLine(xi, yi, x0, y0, x, y);    //  subpath \n\t                                                               // FIXME subpaths may overlap\n\t                                                               // if (w !== 0) {\n\t                                                               //     return true;\n\t                                                               // }\n\t                }\n\t                xi = x0;\n\t                yi = y0;\n\t                break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t    return {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getLineStyle = require('./makeStyleMapper')([\n\t            [\n\t                'lineWidth',\n\t                'width'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'color'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getLineDash: function () {\n\t            var lineType = this.get('type');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                2,\n\t                2\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var Scale = require('./Scale');\n\t    var scaleProto = Scale.prototype;\n\t    var OrdinalScale = Scale.extend({\n\t            type: 'ordinal',\n\t            init: function (data, extent) {\n\t                this._data = data;\n\t                this._extent = extent || [\n\t                    0,\n\t                    data.length - 1\n\t                ];\n\t            },\n\t            parse: function (val) {\n\t                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n\t            },\n\t            contain: function (rank) {\n\t                rank = this.parse(rank);\n\t                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n\t            },\n\t            normalize: function (val) {\n\t                return scaleProto.normalize.call(this, this.parse(val));\n\t            },\n\t            scale: function (val) {\n\t                return Math.round(scaleProto.scale.call(this, val));\n\t            },\n\t            getTicks: function () {\n\t                var ticks = [];\n\t                var extent = this._extent;\n\t                var rank = extent[0];\n\t                while (rank <= extent[1]) {\n\t                    ticks.push(rank);\n\t                    rank++;\n\t                }\n\t                return ticks;\n\t            },\n\t            getLabel: function (n) {\n\t                return this._data[n];\n\t            },\n\t            count: function () {\n\t                return this._extent[1] - this._extent[0] + 1;\n\t            },\n\t            niceTicks: zrUtil.noop,\n\t            niceExtent: zrUtil.noop\n\t        });\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t    return OrdinalScale;\n\t});\n\tdefine('zrender/graphic/Pattern', ['require'], function (require) {\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t    return Pattern;\n\t});\n\tdefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n\t    return {\n\t        getAreaStyle: require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['opacity'],\n\t            ['shadowColor']\n\t        ])\n\t    };\n\t});\n\tdefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n\t    var textContain = require('zrender/contain/text');\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t    return {\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n\t        },\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n\t        },\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n\t    var getItemStyle = require('./makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n\t                5,\n\t                5\n\t            ] : [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/Style', ['require'], function (require) {\n\t    var STYLE_COMMON_PROPS = [\n\t            [\n\t                'shadowBlur',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetX',\n\t                0\n\t            ],\n\t            [\n\t                'shadowOffsetY',\n\t                0\n\t            ],\n\t            [\n\t                'shadowColor',\n\t                '#000'\n\t            ],\n\t            [\n\t                'lineCap',\n\t                'butt'\n\t            ],\n\t            [\n\t                'lineJoin',\n\t                'miter'\n\t            ],\n\t            [\n\t                'miterLimit',\n\t                10\n\t            ]\n\t        ];\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t        return canvasGradient;\n\t    }\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t        return canvasGradient;\n\t    }\n\t    Style.prototype = {\n\t        constructor: Style,\n\t        fill: '#000000',\n\t        stroke: null,\n\t        opacity: 1,\n\t        lineDash: null,\n\t        lineDashOffset: 0,\n\t        shadowBlur: 0,\n\t        shadowOffsetX: 0,\n\t        shadowOffsetY: 0,\n\t        lineWidth: 1,\n\t        strokeNoScale: false,\n\t        text: null,\n\t        textFill: '#000',\n\t        textStroke: null,\n\t        textPosition: 'inside',\n\t        textBaseline: null,\n\t        textAlign: null,\n\t        textVerticalAlign: null,\n\t        textDistance: 5,\n\t        textShadowBlur: 0,\n\t        textShadowOffsetX: 0,\n\t        textShadowOffsetY: 0,\n\t        textTransform: false,\n\t        textRotation: 0,\n\t        blend: null,\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t            if (firstDraw || style.fill !== prevStyle.fill) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t            if (firstDraw || style.blend !== prevStyle.blend) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t            }\n\t        },\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            } else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t    return Style;\n\t});\n\tdefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n\t    var textContain = require('../../contain/text');\n\t    var BoundingRect = require('../../core/BoundingRect');\n\t    var tmpRect = new BoundingRect();\n\t    var RectText = function () {\n\t    };\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t    RectText.prototype = {\n\t        constructor: RectText,\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t            // FIXME\n\t            ctx.save();\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            } else {\n\t                this.setTransform(ctx);\n\t            }\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                    case 'middle':\n\t                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= textRect.height - textRect.lineHeight / 2;\n\t                        break;\n\t                    default:\n\t                        y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            } else {\n\t                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t            var textLines = text.split('\\n');\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t            ctx.restore();\n\t        }\n\t    };\n\t    return RectText;\n\t});\n\tdefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n\t    'use strict';\n\t    var guid = require('./core/guid');\n\t    var Eventful = require('./mixin/Eventful');\n\t    var Transformable = require('./mixin/Transformable');\n\t    var Animatable = require('./mixin/Animatable');\n\t    var zrUtil = require('./core/util');\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t    Element.prototype = {\n\t        type: 'element',\n\t        name: '',\n\t        __zr: null,\n\t        ignore: false,\n\t        clipPath: null,\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t            case 'horizontal':\n\t                dy = 0;\n\t                break;\n\t            case 'vertical':\n\t                dx = 0;\n\t                break;\n\t            }\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [\n\t                    1,\n\t                    0,\n\t                    0,\n\t                    1,\n\t                    0,\n\t                    0\n\t                ];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t        beforeUpdate: function () {\n\t        },\n\t        afterUpdate: function () {\n\t        },\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t        traverse: function (cb, context) {\n\t        },\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            } else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            } else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t            this.dirty(false);\n\t        },\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t                this.dirty(false);\n\t            }\n\t        },\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t    return Element;\n\t});\n\tdefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t                properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\t});\n\tdefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t        this._dimList = [];\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t    Cartesian.prototype = {\n\t        constructor: Cartesian,\n\t        type: 'cartesian',\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(this.getAxes(), function (axis) {\n\t                return axis.scale.type === scaleType;\n\t            });\n\t        },\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t            this._axes[dim] = axis;\n\t            this._dimList.push(dim);\n\t        },\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t            var output = input instanceof Array ? [] : {};\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t            return output;\n\t        }\n\t    };\n\t    return Cartesian;\n\t});\n\tdefine('zrender/core/guid', [], function () {\n\t    var idStart = 2311;\n\t    return function () {\n\t        return idStart++;\n\t    };\n\t});\n\tdefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n\t    'use strict';\n\t    var matrix = require('../core/matrix');\n\t    var vector = require('../core/vector');\n\t    var mIdentity = matrix.identity;\n\t    var EPSILON = 0.00005;\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [\n\t                0,\n\t                0\n\t            ];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t        m = m || matrix.create();\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        } else {\n\t            mIdentity(m);\n\t        }\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            } else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t        var origin = this.origin;\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        } else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    };\n\t    var tmpTransform = [];\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [\n\t                1,\n\t                1\n\t            ];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [\n\t            sx,\n\t            sy\n\t        ];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [\n\t                x,\n\t                y\n\t            ];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t    return Transformable;\n\t});\n\tdefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n\t    'use strict';\n\t    var Animator = require('../animation/Animator');\n\t    var util = require('../core/util');\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = require('../core/log');\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t    Animatable.prototype = {\n\t        constructor: Animatable,\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            } else {\n\t                target = el;\n\t            }\n\t            if (!target) {\n\t                log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t                return;\n\t            }\n\t            var animators = el.animators;\n\t            var animator = new Animator(target, loop);\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            }).done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t            animators.push(animator);\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t            return animator;\n\t        },\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t            return this;\n\t        },\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }    // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }    // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }    // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i].done(done).start(easing);\n\t            }\n\t        },\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t                    } else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                } else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    } else {\n\t                        // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t            }\n\t            return this;\n\t        }\n\t    };\n\t    return Animatable;\n\t});\n\tdefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var clazz = require('./clazz');\n\t    var parseClassType = clazz.parseClassType;\n\t    var base = 0;\n\t    var componentUtil = {};\n\t    var DELIMITER = '_';\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [\n\t            type || '',\n\t            base++,\n\t            Math.random()\n\t        ].join(DELIMITER);\n\t    };\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t        var subTypeDefaulters = {};\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t        return entity;\n\t    };\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n\t            }\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t            zrUtil.each(fullNameList, function (name) {\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t            return {\n\t                graph: graph,\n\t                noEntryList: noEntryList\n\t            };\n\t        }\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {\n\t                    predecessor: [],\n\t                    successor: []\n\t                };\n\t            }\n\t            return graph[name];\n\t        }\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t    return componentUtil;\n\t});\n\tdefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n\t    return {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\t});\n\tdefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n\t    var numberUtil = require('../util/number');\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = require('zrender/core/util');\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t    var normalizedExtent = [\n\t            0,\n\t            1\n\t        ];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [\n\t            0,\n\t            0\n\t        ];\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t    Axis.prototype = {\n\t        constructor: Axis,\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n\t        },\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t            return this.scale.scale(t);\n\t        },\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            } else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t    return Axis;\n\t});\n\tdefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n\t    'use strict';\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('../axisHelper');\n\t    return function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n\t    };\n\t});\n\tdefine('zrender/core/log', ['require', '../config'], function (require) {\n\t    var config = require('../config');\n\t    /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t    return function () {\n\t        if (config.debugMode === 0) {\n\t            return;\n\t        } else if (config.debugMode == 1) {\n\t            for (var k in arguments) {\n\t                throw new Error(arguments[k]);\n\t            }\n\t        } else if (config.debugMode > 1) {\n\t            for (var k in arguments) {\n\t                console.log(arguments[k]);\n\t            }\n\t        }\n\t    };    /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t});\n\tdefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n\t    var Clip = require('./Clip');\n\t    var color = require('../tool/color');\n\t    var util = require('../core/util');\n\t    var isArrayLike = util.isArrayLike;\n\t    var arraySlice = Array.prototype.slice;\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            } else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            } else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        } else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t            }\n\t        } else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t            return arraySlice.call(value);\n\t        }\n\t        return value;\n\t    }\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t        // For vertices morphing\n\t        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function (a, b) {\n\t            return a.time - b.time;\n\t        });\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t            // Check if value is equal, deep check if value is array\n\t            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                } else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            } else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t        if (isValueColor) {\n\t            var rgba = [\n\t                    0,\n\t                    0,\n\t                    0,\n\t                    0\n\t                ];\n\t        }\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            } else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            } else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t            var range = kfPercents[frame + 1] - kfPercents[frame];\n\t            if (range === 0) {\n\t                return;\n\t            } else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    } else {\n\t                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            } else {\n\t                if (isValueArray) {\n\t                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t                } else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t                        value = rgba2String(rgba);\n\t                    } else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    } else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(target, propName, value);\n\t                }\n\t            }\n\t        };\n\t        var clip = new Clip({\n\t                target: animator._target,\n\t                life: trackMaxTime,\n\t                loop: animator._loop,\n\t                delay: animator._delay,\n\t                onframe: onframe,\n\t                ondestroy: oneTrackDone\n\t            });\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t        return clip;\n\t    }\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function (target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t        this._loop = loop || false;\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t        this._clipCount = 0;\n\t        this._delay = 0;\n\t        this._doneList = [];\n\t        this._onframeList = [];\n\t        this._clipList = [];\n\t    };\n\t    Animator.prototype = {\n\t        when: function (time, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        start: function (easing) {\n\t            var self = this;\n\t            var clipCount = 0;\n\t            var oneTrackDone = function () {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        done: function (cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t    return Animator;\n\t});\n\tdefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n\t    'use strict';\n\t    var ComponentModel = require('../../model/Component');\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisModelCreator = require('../axisModelCreator');\n\t    var AxisModel = ComponentModel.extend({\n\t            type: 'cartesian2dAxis',\n\t            axis: null,\n\t            init: function () {\n\t                AxisModel.superApply(this, 'init', arguments);\n\t                this._resetRange();\n\t            },\n\t            mergeOption: function () {\n\t                AxisModel.superApply(this, 'mergeOption', arguments);\n\t                this._resetRange();\n\t            },\n\t            restoreData: function () {\n\t                AxisModel.superApply(this, 'restoreData', arguments);\n\t                this._resetRange();\n\t            },\n\t            setRange: function (rangeStart, rangeEnd) {\n\t                this.option.rangeStart = rangeStart;\n\t                this.option.rangeEnd = rangeEnd;\n\t            },\n\t            getMin: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null ? option.rangeStart : option.min;\n\t            },\n\t            getMax: function () {\n\t                var option = this.option;\n\t                return option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            },\n\t            getNeedCrossZero: function () {\n\t                var option = this.option;\n\t                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n\t            },\n\t            findGridModel: function () {\n\t                return this.ecModel.queryComponents({\n\t                    mainType: 'grid',\n\t                    index: this.get('gridIndex'),\n\t                    id: this.get('gridId')\n\t                })[0];\n\t            },\n\t            _resetRange: function () {\n\t                // rangeStart and rangeEnd is readonly.\n\t                this.option.rangeStart = this.option.rangeEnd = null;\n\t            }\n\t        });\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\t    var extraOption = { offset: 0 };\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t    return AxisModel;\n\t});\n\tdefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n\t    var easingFuncs = require('./easing');\n\t    function Clip(options) {\n\t        this._target = options.target;\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t        this.gap = options.gap || 0;\n\t        this.easing = options.easing || 'Linear';\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t    Clip.prototype = {\n\t        constructor: Clip,\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t            percent = Math.min(percent, 1);\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t            this.fire('frame', schedule);\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart(globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t            return null;\n\t        },\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._needsRemove = false;\n\t        },\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t    return Clip;\n\t});\n\tdefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n\t    var axisDefault = require('./axisDefault');\n\t    var zrUtil = require('zrender/core/util');\n\t    var ComponentModel = require('../model/Component');\n\t    var layout = require('../util/layout');\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = [\n\t            'value',\n\t            'category',\n\t            'time',\n\t            'log'\n\t        ];\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t            BaseAxisModelClass.extend({\n\t                type: axisName + 'Axis.' + axisType,\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t                defaultOption: zrUtil.mergeAll([\n\t                    {},\n\t                    axisDefault[axisType + 'Axis'],\n\t                    extraDefaultOption\n\t                ], true)\n\t            });\n\t        });\n\t        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n\t    };\n\t});\n\tdefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var axisHelper = require('./axisHelper');\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        } else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n\t    }\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n\t    }\n\t    return {\n\t        getFormattedLabels: getFormattedLabels,\n\t        getCategories: getCategories\n\t    };\n\t});\n\tdefine('zrender/animation/easing', [], function () {\n\t    var easing = {\n\t            linear: function (k) {\n\t                return k;\n\t            },\n\t            quadraticIn: function (k) {\n\t                return k * k;\n\t            },\n\t            quadraticOut: function (k) {\n\t                return k * (2 - k);\n\t            },\n\t            quadraticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k;\n\t                }\n\t                return -0.5 * (--k * (k - 2) - 1);\n\t            },\n\t            cubicIn: function (k) {\n\t                return k * k * k;\n\t            },\n\t            cubicOut: function (k) {\n\t                return --k * k * k + 1;\n\t            },\n\t            cubicInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k + 2);\n\t            },\n\t            quarticIn: function (k) {\n\t                return k * k * k * k;\n\t            },\n\t            quarticOut: function (k) {\n\t                return 1 - --k * k * k * k;\n\t            },\n\t            quarticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k;\n\t                }\n\t                return -0.5 * ((k -= 2) * k * k * k - 2);\n\t            },\n\t            quinticIn: function (k) {\n\t                return k * k * k * k * k;\n\t            },\n\t            quinticOut: function (k) {\n\t                return --k * k * k * k * k + 1;\n\t            },\n\t            quinticInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * k * k * k * k * k;\n\t                }\n\t                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t            },\n\t            sinusoidalIn: function (k) {\n\t                return 1 - Math.cos(k * Math.PI / 2);\n\t            },\n\t            sinusoidalOut: function (k) {\n\t                return Math.sin(k * Math.PI / 2);\n\t            },\n\t            sinusoidalInOut: function (k) {\n\t                return 0.5 * (1 - Math.cos(Math.PI * k));\n\t            },\n\t            exponentialIn: function (k) {\n\t                return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t            },\n\t            exponentialOut: function (k) {\n\t                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t            },\n\t            exponentialInOut: function (k) {\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * Math.pow(1024, k - 1);\n\t                }\n\t                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t            },\n\t            circularIn: function (k) {\n\t                return 1 - Math.sqrt(1 - k * k);\n\t            },\n\t            circularOut: function (k) {\n\t                return Math.sqrt(1 - --k * k);\n\t            },\n\t            circularInOut: function (k) {\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t                }\n\t                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t            },\n\t            elasticIn: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            },\n\t            elasticOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t            },\n\t            elasticInOut: function (k) {\n\t                var s;\n\t                var a = 0.1;\n\t                var p = 0.4;\n\t                if (k === 0) {\n\t                    return 0;\n\t                }\n\t                if (k === 1) {\n\t                    return 1;\n\t                }\n\t                if (!a || a < 1) {\n\t                    a = 1;\n\t                    s = p / 4;\n\t                } else {\n\t                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t                }\n\t                if ((k *= 2) < 1) {\n\t                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t                }\n\t                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t            },\n\t            backIn: function (k) {\n\t                var s = 1.70158;\n\t                return k * k * ((s + 1) * k - s);\n\t            },\n\t            backOut: function (k) {\n\t                var s = 1.70158;\n\t                return --k * k * ((s + 1) * k + s) + 1;\n\t            },\n\t            backInOut: function (k) {\n\t                var s = 1.70158 * 1.525;\n\t                if ((k *= 2) < 1) {\n\t                    return 0.5 * (k * k * ((s + 1) * k - s));\n\t                }\n\t                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t            },\n\t            bounceIn: function (k) {\n\t                return 1 - easing.bounceOut(1 - k);\n\t            },\n\t            bounceOut: function (k) {\n\t                if (k < 1 / 2.75) {\n\t                    return 7.5625 * k * k;\n\t                } else if (k < 2 / 2.75) {\n\t                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t                } else if (k < 2.5 / 2.75) {\n\t                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t                } else {\n\t                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t                }\n\t            },\n\t            bounceInOut: function (k) {\n\t                if (k < 0.5) {\n\t                    return easing.bounceIn(k * 2) * 0.5;\n\t                }\n\t                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t            }\n\t        };\n\t    return easing;\n\t});\n\tdefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var defaultOption = {\n\t            show: true,\n\t            zlevel: 0,\n\t            z: 0,\n\t            inverse: false,\n\t            name: '',\n\t            nameLocation: 'end',\n\t            nameRotate: null,\n\t            nameTruncate: {\n\t                maxWidth: null,\n\t                ellipsis: '...',\n\t                placeholder: '.'\n\t            },\n\t            nameTextStyle: {},\n\t            nameGap: 15,\n\t            silent: false,\n\t            triggerEvent: false,\n\t            tooltip: { show: false },\n\t            axisLine: {\n\t                show: true,\n\t                onZero: true,\n\t                lineStyle: {\n\t                    color: '#333',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            axisTick: {\n\t                show: true,\n\t                inside: false,\n\t                length: 5,\n\t                lineStyle: { width: 1 }\n\t            },\n\t            axisLabel: {\n\t                show: true,\n\t                inside: false,\n\t                rotate: 0,\n\t                margin: 8,\n\t                textStyle: { fontSize: 12 }\n\t            },\n\t            splitLine: {\n\t                show: true,\n\t                lineStyle: {\n\t                    color: ['#ccc'],\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            splitArea: {\n\t                show: false,\n\t                areaStyle: {\n\t                    color: [\n\t                        'rgba(250,250,250,0.3)',\n\t                        'rgba(200,200,200,0.3)'\n\t                    ]\n\t                }\n\t            }\n\t        };\n\t    var categoryAxis = zrUtil.merge({\n\t            boundaryGap: true,\n\t            splitLine: { show: false },\n\t            axisTick: {\n\t                alignWithLabel: false,\n\t                interval: 'auto'\n\t            },\n\t            axisLabel: { interval: 'auto' }\n\t        }, defaultOption);\n\t    var valueAxis = zrUtil.merge({\n\t            boundaryGap: [\n\t                0,\n\t                0\n\t            ],\n\t            splitNumber: 5\n\t        }, defaultOption);\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t            scale: true,\n\t            min: 'dataMin',\n\t            max: 'dataMax'\n\t        }, valueAxis);\n\t    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n\t    logAxis.scale = true;\n\t    return {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\t});\n\tdefine('zrender/config', [], function () {\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t            debugMode: 0,\n\t            devicePixelRatio: dpr\n\t        };\n\t    return config;\n\t});\n\tdefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n\t    'use strict';\n\t    var List = require('../../data/List');\n\t    var completeDimensions = require('../../data/helper/completeDimensions');\n\t    var zrUtil = require('zrender/core/util');\n\t    var modelUtil = require('../../util/model');\n\t    var CoordinateSystem = require('../../CoordinateSystem');\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t        if (true) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n\t                'x',\n\t                'y'\n\t            ];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t        var list = new List(dimensions, seriesModel);\n\t        var nameList = createNameList(axesInfo, data);\n\t        var categories = {};\n\t        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t        return list;\n\t    }\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n\t    }\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t            cartesian2d: function (data, seriesModel, ecModel) {\n\t                var axesModels = zrUtil.map([\n\t                        'xAxis',\n\t                        'yAxis'\n\t                    ], function (name) {\n\t                        return ecModel.queryComponents({\n\t                            mainType: name,\n\t                            index: seriesModel.get(name + 'Index'),\n\t                            id: seriesModel.get(name + 'Id')\n\t                        })[0];\n\t                    });\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t                if (true) {\n\t                    if (!xAxisModel) {\n\t                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n\t                    }\n\t                    if (!yAxisModel) {\n\t                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n\t                    }\n\t                }\n\t                var xAxisType = xAxisModel.get('type');\n\t                var yAxisType = yAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'x',\n\t                            type: getDimTypeByAxis(xAxisType),\n\t                            stackable: isStackable(xAxisType)\n\t                        },\n\t                        {\n\t                            name: 'y',\n\t                            type: getDimTypeByAxis(yAxisType),\n\t                            stackable: isStackable(yAxisType)\n\t                        }\n\t                    ];\n\t                var isXAxisCateogry = xAxisType === 'category';\n\t                var isYAxisCategory = yAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'x',\n\t                    'y',\n\t                    'z'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isXAxisCateogry) {\n\t                    categoryAxesModels.x = xAxisModel;\n\t                }\n\t                if (isYAxisCategory) {\n\t                    categoryAxesModels.y = yAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            polar: function (data, seriesModel, ecModel) {\n\t                var polarModel = ecModel.queryComponents({\n\t                        mainType: 'polar',\n\t                        index: seriesModel.get('polarIndex'),\n\t                        id: seriesModel.get('polarId')\n\t                    })[0];\n\t                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t                if (true) {\n\t                    if (!angleAxisModel) {\n\t                        throw new Error('angleAxis option not found');\n\t                    }\n\t                    if (!radiusAxisModel) {\n\t                        throw new Error('radiusAxis option not found');\n\t                    }\n\t                }\n\t                var radiusAxisType = radiusAxisModel.get('type');\n\t                var angleAxisType = angleAxisModel.get('type');\n\t                var dimensions = [\n\t                        {\n\t                            name: 'radius',\n\t                            type: getDimTypeByAxis(radiusAxisType),\n\t                            stackable: isStackable(radiusAxisType)\n\t                        },\n\t                        {\n\t                            name: 'angle',\n\t                            type: getDimTypeByAxis(angleAxisType),\n\t                            stackable: isStackable(angleAxisType)\n\t                        }\n\t                    ];\n\t                var isAngleAxisCateogry = angleAxisType === 'category';\n\t                var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t                completeDimensions(dimensions, data, [\n\t                    'radius',\n\t                    'angle',\n\t                    'value'\n\t                ]);\n\t                var categoryAxesModels = {};\n\t                if (isRadiusAxisCateogry) {\n\t                    categoryAxesModels.radius = radiusAxisModel;\n\t                }\n\t                if (isAngleAxisCateogry) {\n\t                    categoryAxesModels.angle = angleAxisModel;\n\t                }\n\t                return {\n\t                    dimensions: dimensions,\n\t                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n\t                    categoryAxesModels: categoryAxesModels\n\t                };\n\t            },\n\t            geo: function (data, seriesModel, ecModel) {\n\t                // TODO Region\n\t                // \n\t                return {\n\t                    dimensions: completeDimensions([\n\t                        { name: 'lng' },\n\t                        { name: 'lat' }\n\t                    ], data, [\n\t                        'lng',\n\t                        'lat',\n\t                        'value'\n\t                    ])\n\t                };\n\t            }\n\t        };\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                } else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t        return nameList;\n\t    }\n\t    return createListFromArray;\n\t});\n\tdefine('zrender/core/curve', ['require', './vector'], function (require) {\n\t    'use strict';\n\t    var vec2 = require('./vector');\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 0.0001;\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1 - p0);\n\t        var d = p0 - val;\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t        var n = 0;\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            } else {\n\t                var t1 = -c / b;\n\t                //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = B * B - 4 * A * C;\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;\n\t                // t1, a is not zero\n\t                var t2 = -K / 2;\n\t                // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                } else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                } else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t            d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        } else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            } else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        } else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            } else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                } else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t    return {\n\t        cubicAt: cubicAt,\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t        cubicRootAt: cubicRootAt,\n\t        cubicExtrema: cubicExtrema,\n\t        cubicSubdivide: cubicSubdivide,\n\t        cubicProjectPoint: cubicProjectPoint,\n\t        quadraticAt: quadraticAt,\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t        quadraticRootAt: quadraticRootAt,\n\t        quadraticExtremum: quadraticExtremum,\n\t        quadraticSubdivide: quadraticSubdivide,\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\t});\n\tdefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n\t    var vec2 = require('./vector');\n\t    var curve = require('./curve');\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function (points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % PI2;\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % PI2;\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        } else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t    return bbox;\n\t});\n\tdefine('echarts/data/DataDiffer', ['require'], function (require) {\n\t    'use strict';\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t    DataDiffer.prototype = {\n\t        constructor: DataDiffer,\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    } else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                } else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    } else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            } else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t    return DataDiffer;\n\t});\n\tdefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n\t                dimensions[i] = guessOrdinal(data, i) ? {\n\t                    type: 'ordinal',\n\t                    name: name\n\t                } : name;\n\t            }\n\t        }\n\t        return dimensions;\n\t    }\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var value = retrieveValue(data[i]);\n\t                if (!zrUtil.isArray(value)) {\n\t                    return false;\n\t                }\n\t                var value = value[dimIndex];\n\t                if (value != null && isFinite(value)) {\n\t                    return false;\n\t                } else if (zrUtil.isString(value) && value !== '-') {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        };\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n\t    }\n\t    return completeDimensions;\n\t});\n\tdefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/line', [], function () {\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t                return false;\n\t            }\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t            } else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n\t    var curve = require('../core/curve');\n\t    return {\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/arc', ['require', './util'], function (require) {\n\t    var normalizeRadian = require('./util').normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t            if (d - _l > r || d + _l < r) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/util', ['require'], function (require) {\n\t    var PI2 = Math.PI * 2;\n\t    return {\n\t        normalizeRadian: function (angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/contain/windingLine', [], function () {\n\t    return function windingLine(x0, y0, x1, y1, x, y) {\n\t        if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t        var x_ = t * (x1 - x0) + x0;\n\t        return x_ > x ? dir : 0;\n\t    };\n\t});\n\tdefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n\t    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n\t            [\n\t                'fill',\n\t                'color'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'borderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'borderWidth'\n\t            ],\n\t            [\n\t                'stroke',\n\t                'barBorderColor'\n\t            ],\n\t            [\n\t                'lineWidth',\n\t                'barBorderWidth'\n\t            ],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]);\n\t    return {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\t});\n\tdefine('zrender/core/LRU', ['require'], function (require) {\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t        this._len = 0;\n\t    };\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        } else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        } else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        } else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t        this._list = new LinkedList();\n\t        this._map = {};\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t    var LRUProto = LRU.prototype;\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t            return entry.value;\n\t        }\n\t    };\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t    return LRU;\n\t});\n\tdefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n\t    var smoothSpline = require('./smoothSpline');\n\t    var smoothBezier = require('./smoothBezier');\n\t    return {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t                    }\n\t                } else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t    }\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    return function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t            var w = pos - idx;\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            } else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n\t    var vec2 = require('../../core/vector');\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    return function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [\n\t                Infinity,\n\t                Infinity\n\t            ];\n\t            max = [\n\t                -Infinity,\n\t                -Infinity\n\t            ];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            } else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                } else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t        return cps;\n\t    };\n\t});\n\tdefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n\t    return {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            } else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                } else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                } else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                } else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            } else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\t});\n\tdefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var env = require('./core/env');\n\t    var Group = require('./container/Group');\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = require('./core/timsort');\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t        this._roots = [];\n\t        this._displayList = [];\n\t        this._displayListLen = 0;\n\t    };\n\t    Storage.prototype = {\n\t        constructor: Storage,\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t            el.beforeUpdate();\n\t            if (el.__dirty) {\n\t                el.update();\n\t            }\n\t            el.afterUpdate();\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath  group \n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                } else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t            } else {\n\t                el.__clipPaths = clipPaths;\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t                return;\n\t            }\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t            var el;\n\t            if (typeof elId == 'string') {\n\t                el = this._elements[elId];\n\t            } else {\n\t                el = elId;\n\t            }\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t            this._elements[el.id] = el;\n\t            return this;\n\t        },\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t        dispose: function () {\n\t            this._elements = this._renderList = this._roots = null;\n\t        },\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t    return Storage;\n\t});\n\tdefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var util = require('./core/util');\n\t    var Draggable = require('./mixin/Draggable');\n\t    var Eventful = require('./mixin/Eventful');\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t    function EmptyProxy() {\n\t    }\n\t    EmptyProxy.prototype.dispose = function () {\n\t    };\n\t    var handlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function (storage, painter, proxy) {\n\t        Eventful.call(this);\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t        // Attach handler\n\t        proxy.handler = this;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t        Draggable.call(this);\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t    Handler.prototype = {\n\t        constructor: Handler,\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t            this._hovered = hovered;\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t            this.trigger('globalout', { event: event });\n\t        },\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t        dispose: function () {\n\t            this.proxy.dispose();\n\t            this.storage = this.proxy = this.painter = null;\n\t        },\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t            var el = targetEl;\n\t            while (el) {\n\t                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t                el.trigger(eventName, eventPacket);\n\t                el = el.parent;\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof layer[eventHandler] == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t        findHover: function (x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0; i--) {\n\t                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Common handlers\n\t    util.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            } else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            } else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t    return Handler;\n\t});\n\tdefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n\t    'use strict';\n\t    var util = require('../core/util');\n\t    var Dispatcher = require('../core/event').Dispatcher;\n\t    var requestAnimationFrame = require('./requestAnimationFrame');\n\t    var Animator = require('./Animator');\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t        options = options || {};\n\t        this.stage = options.stage || {};\n\t        this.onframe = options.onframe || function () {\n\t        };\n\t        // private properties\n\t        this._clips = [];\n\t        this._running = false;\n\t        this._time;\n\t        this._pausedTime;\n\t        this._pauseStart;\n\t        this._paused = false;\n\t        Dispatcher.call(this);\n\t    };\n\t    Animation.prototype = {\n\t        constructor: Animation,\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        removeClip: function (clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t        _update: function () {\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                } else {\n\t                    i++;\n\t                }\n\t            }\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t            this._time = time;\n\t            this.onframe(delta);\n\t            this.trigger('frame', delta);\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t        _startLoop: function () {\n\t            var self = this;\n\t            this._running = true;\n\t            function step() {\n\t                if (self._running) {\n\t                    requestAnimationFrame(step);\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t            requestAnimationFrame(step);\n\t        },\n\t        start: function () {\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t            this._startLoop();\n\t        },\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += new Date().getTime() - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t            return animator;\n\t        }\n\t    };\n\t    util.mixin(Animation, Dispatcher);\n\t    return Animation;\n\t});\n\tdefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n\t    var eventTool = require('../core/event');\n\t    var zrUtil = require('../core/util');\n\t    var Eventful = require('../mixin/Eventful');\n\t    var env = require('../core/env');\n\t    var GestureMgr = require('../core/GestureMgr');\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t    var TOUCH_CLICK_DELAY = 300;\n\t    var mouseHandlerNames = [\n\t            'click',\n\t            'dblclick',\n\t            'mousewheel',\n\t            'mouseout',\n\t            'mouseup',\n\t            'mousedown',\n\t            'mousemove'\n\t        ];\n\t    var touchHandlerNames = [\n\t            'touchstart',\n\t            'touchend',\n\t            'touchmove'\n\t        ];\n\t    function eventNameFix(name) {\n\t        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t    }\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t        stage === 'start' && gestureMgr.clear();\n\t        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n\t        stage === 'end' && gestureMgr.clear();\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t    var domHandlers = {\n\t            mousemove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                this.trigger('mousemove', event);\n\t            },\n\t            mouseout: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                var element = event.toElement || event.relatedTarget;\n\t                if (element != this.dom) {\n\t                    while (element && element.nodeType != 9) {\n\t                        // rootdommouseOut\n\t                        if (element === this.dom) {\n\t                            return;\n\t                        }\n\t                        element = element.parentNode;\n\t                    }\n\t                }\n\t                this.trigger('mouseout', event);\n\t            },\n\t            touchstart: function (event) {\n\t                // Default mouse behaviour should not be disabled here.\n\t                // For example, page may needs to be slided.\n\t                event = normalizeEvent(this.dom, event);\n\t                this._lastTouchMoment = new Date();\n\t                processGesture(this, event, 'start');\n\t                // findHover\n\t                // this._mobileFindFixed(event);\n\t                // Trigger mousemove and mousedown\n\t                domHandlers.mousemove.call(this, event);\n\t                domHandlers.mousedown.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchmove: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'change');\n\t                // Mouse move should always be triggered no matter whether\n\t                // there is gestrue event, because mouse move and pinch may\n\t                // be used at the same time.\n\t                domHandlers.mousemove.call(this, event);\n\t                setTouchTimer(this);\n\t            },\n\t            touchend: function (event) {\n\t                event = normalizeEvent(this.dom, event);\n\t                processGesture(this, event, 'end');\n\t                domHandlers.mouseup.call(this, event);\n\t                // click event should always be triggered no matter whether\n\t                // there is gestrue event. System click can not be prevented.\n\t                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                    domHandlers.click.call(this, event);\n\t                }\n\t                setTouchTimer(this);\n\t            }\n\t        };\n\t    // Common handlers\n\t    zrUtil.each([\n\t        'click',\n\t        'mousedown',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'dblclick'\n\t    ], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t        this.dom = dom;\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t        this._handlers = {};\n\t        initDomHandler(this);\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t    return HandlerDomProxy;\n\t});\n\tdefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n\t    'use strict';\n\t    var config = require('./config');\n\t    var util = require('./core/util');\n\t    var log = require('./core/log');\n\t    var BoundingRect = require('./core/BoundingRect');\n\t    var timsort = require('./core/timsort');\n\t    var Layer = require('./Layer');\n\t    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t            return false;\n\t        }\n\t        return true;\n\t    }\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) {\n\t            // Can both be null or undefined\n\t            return false;\n\t        }\n\t        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n\t        opts = opts || {};\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t        var rootStyle = root.style;\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t            root.innerHTML = '';\n\t        }\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t            var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t            root.appendChild(domRoot);\n\t        } else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t        this.pathToImage = this._createPathToImage();\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t        this._hoverElements = [];\n\t    };\n\t    Painter.prototype = {\n\t        constructor: Painter,\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t        refresh: function (paintAll) {\n\t            var list = this.storage.getDisplayList(true);\n\t            var zlevelList = this._zlevelList;\n\t            this._paintList(list, paintAll);\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t            this.refreshHover();\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t            return this;\n\t        },\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                    style: el.style,\n\t                    shape: el.shape\n\t                });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(100000);\n\t            }\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t        _startProgessive: function () {\n\t            var self = this;\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    } else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t        _paintList: function (list, paintAll) {\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t            this._updateLayerStatus(list);\n\t            this._clearProgressive();\n\t            this.eachBuildinLayer(preProcessLayer);\n\t            this._doPaintList(list, paintAll);\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t            // var invTransform = [];\n\t            var scope;\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var elFrame = el.__frame;\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t                    // Reset scope\n\t                    scope = {};\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t                    if (!currentLayer.isBuildin) {\n\t                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t                    }\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                } else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t                var clipPaths = el.__clipPaths;\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t                this.insertLayer(zlevel, layer);\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t            return layer;\n\t        },\n\t        insertLayer: function (zlevel, layer) {\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            } else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                } else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            layersMap[zlevel] = layer;\n\t        },\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t        _updateLayerStatus: function (list) {\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                } else {\n\t                    el.__frame = -1;\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t            // \n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                } else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t                var layer = this._layers[zlevel];\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t            domRoot.style.display = '';\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t                this.refresh(true);\n\t            }\n\t            this._width = width;\n\t            this._height = height;\n\t            return this;\n\t        },\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t            this.root = this.storage = this._domRoot = this._layers = null;\n\t        },\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t            var displayList = this.storage.getDisplayList(true);\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t            return imageLayer.dom;\n\t        },\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n\t        },\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n\t        },\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t            var pathTransform = {\n\t                    position: path.position,\n\t                    rotation: path.rotation,\n\t                    scale: path.scale\n\t                };\n\t            path.position = [\n\t                0,\n\t                0,\n\t                0\n\t            ];\n\t            path.rotation = 0;\n\t            path.scale = [\n\t                1,\n\t                1\n\t            ];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t            var ImageShape = require('./graphic/Image');\n\t            var imgShape = new ImageShape({\n\t                    id: id,\n\t                    style: {\n\t                        x: 0,\n\t                        y: 0,\n\t                        image: canvas\n\t                    }\n\t                });\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t            return imgShape;\n\t        },\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(id, e, width, height, me.dpr);\n\t            };\n\t        }\n\t    };\n\t    return Painter;\n\t});\n\tdefine('zrender/mixin/Draggable', ['require'], function (require) {\n\t    function Draggable() {\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n\t                                                      // this._draggingTarget = null;\n\t                                                      // this._x = 0;\n\t                                                      // this._y = 0;\n\t    }\n\t    Draggable.prototype = {\n\t        constructor: Draggable,\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t    };\n\t    return Draggable;\n\t});\n\tdefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n\t    'use strict';\n\t    var Eventful = require('../mixin/Eventful');\n\t    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t            left: 0,\n\t            top: 0\n\t        };\n\t    }\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t    /**\n\t     * domtouch\n\t     */\n\t    function normalizeEvent(el, e) {\n\t        e = e || window.event;\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        } else {\n\t            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t        return e;\n\t    }\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        } else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        } else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2 ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        } : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t    return {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t        stop: stop,\n\t        Dispatcher: Eventful\n\t    };\n\t});\n\tdefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n\t    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t        setTimeout(func, 16);\n\t    };\n\t});\n\tdefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n\t    'use strict';\n\t    var eventUtil = require('./event');\n\t    var GestureMgr = function () {\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t    GestureMgr.prototype = {\n\t        constructor: GestureMgr,\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t            if (!touches) {\n\t                return;\n\t            }\n\t            var trackItem = {\n\t                    points: [],\n\t                    touches: [],\n\t                    target: target,\n\t                    event: event\n\t                };\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([\n\t                    pos.zrX,\n\t                    pos.zrY\n\t                ]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t            this._track.push(trackItem);\n\t        },\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t    var recognizers = {\n\t            pinch: function (track, event) {\n\t                var trackLen = track.length;\n\t                if (!trackLen) {\n\t                    return;\n\t                }\n\t                var pinchEnd = (track[trackLen - 1] || {}).points;\n\t                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                    !isFinite(pinchScale) && (pinchScale = 1);\n\t                    event.pinchScale = pinchScale;\n\t                    var pinchCenter = center(pinchEnd);\n\t                    event.pinchX = pinchCenter[0];\n\t                    event.pinchY = pinchCenter[1];\n\t                    return {\n\t                        type: 'pinch',\n\t                        target: track[0].target,\n\t                        event: event\n\t                    };\n\t                }\n\t            }    // Only pinch currently.\n\t        };\n\t    return GestureMgr;\n\t});\n\tdefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n\t    var util = require('./core/util');\n\t    var config = require('./config');\n\t    var Style = require('./graphic/Style');\n\t    var Pattern = require('./graphic/Pattern');\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function (id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }    // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t        var domStyle = dom.style;\n\t        if (domStyle) {\n\t            // Not in node\n\t            dom.onselectstart = returnFalse;\n\t            // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t        this.painter = painter;\n\t        this.config = null;\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t    Layer.prototype = {\n\t        constructor: Layer,\n\t        elCount: 0,\n\t        __dirty: true,\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t            var dpr = this.dpr;\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t            }\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }    // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t    return Layer;\n\t});\n\tdefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var POSSIBLE_STYLES = [\n\t            'areaStyle',\n\t            'lineStyle',\n\t            'nodeStyle',\n\t            'linkStyle',\n\t            'chordStyle',\n\t            'label',\n\t            'labelLine'\n\t        ];\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    } else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    return function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    } else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    return {\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var graphic = require('../../util/graphic');\n\t    var AxisBuilder = require('./AxisBuilder');\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t    var axisBuilderAttrs = [\n\t            'axisLine',\n\t            'axisLabel',\n\t            'axisTick',\n\t            'axisName'\n\t        ];\n\t    var selfBuilderAttrs = [\n\t            'splitArea',\n\t            'splitLine'\n\t        ];\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t    var AxisView = require('../../echarts').extendComponentView({\n\t            type: 'axis',\n\t            render: function (axisModel, ecModel) {\n\t                this.group.removeAll();\n\t                var oldAxisGroup = this._axisGroup;\n\t                this._axisGroup = new graphic.Group();\n\t                this.group.add(this._axisGroup);\n\t                if (!axisModel.get('show')) {\n\t                    return;\n\t                }\n\t                var gridModel = axisModel.findGridModel();\n\t                var layout = layoutAxis(gridModel, axisModel);\n\t                var axisBuilder = new AxisBuilder(axisModel, layout);\n\t                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t                this._axisGroup.add(axisBuilder.getGroup());\n\t                zrUtil.each(selfBuilderAttrs, function (name) {\n\t                    if (axisModel.get(name + '.show')) {\n\t                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                    }\n\t                }, this);\n\t                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t            },\n\t            _splitLine: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitLineModel = axisModel.getModel('splitLine');\n\t                var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t                var lineColors = lineStyleModel.get('color');\n\t                var lineInterval = getInterval(splitLineModel, labelInterval);\n\t                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var isHorizontal = axis.isHorizontal();\n\t                var lineCount = 0;\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var p1 = [];\n\t                var p2 = [];\n\t                // Simple optimization\n\t                // Batching the lines if color are the same\n\t                var lineStyle = lineStyleModel.getLineStyle();\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    if (isHorizontal) {\n\t                        p1[0] = tickCoord;\n\t                        p1[1] = gridRect.y;\n\t                        p2[0] = tickCoord;\n\t                        p2[1] = gridRect.y + gridRect.height;\n\t                    } else {\n\t                        p1[0] = gridRect.x;\n\t                        p1[1] = tickCoord;\n\t                        p2[0] = gridRect.x + gridRect.width;\n\t                        p2[1] = tickCoord;\n\t                    }\n\t                    var colorIndex = lineCount++ % lineColors.length;\n\t                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'line_' + ticks[i],\n\t                        shape: {\n\t                            x1: p1[0],\n\t                            y1: p1[1],\n\t                            x2: p2[0],\n\t                            y2: p2[1]\n\t                        },\n\t                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            _splitArea: function (axisModel, gridModel, labelInterval) {\n\t                var axis = axisModel.axis;\n\t                var splitAreaModel = axisModel.getModel('splitArea');\n\t                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t                var areaColors = areaStyleModel.get('color');\n\t                var gridRect = gridModel.coordinateSystem.getRect();\n\t                var ticksCoords = axis.getTicksCoords();\n\t                var ticks = axis.scale.getTicks();\n\t                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t                var count = 0;\n\t                var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t                var areaStyle = areaStyleModel.getAreaStyle();\n\t                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t                for (var i = 1; i < ticksCoords.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t                    var x;\n\t                    var y;\n\t                    var width;\n\t                    var height;\n\t                    if (axis.isHorizontal()) {\n\t                        x = prevX;\n\t                        y = gridRect.y;\n\t                        width = tickCoord - x;\n\t                        height = gridRect.height;\n\t                    } else {\n\t                        x = gridRect.x;\n\t                        y = prevY;\n\t                        width = gridRect.width;\n\t                        height = tickCoord - y;\n\t                    }\n\t                    var colorIndex = count++ % areaColors.length;\n\t                    this._axisGroup.add(new graphic.Rect({\n\t                        anid: 'area_' + ticks[i],\n\t                        shape: {\n\t                            x: x,\n\t                            y: y,\n\t                            width: width,\n\t                            height: height\n\t                        },\n\t                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n\t                        silent: true\n\t                    }));\n\t                    prevX = x + width;\n\t                    prevY = y + height;\n\t                }\n\t            }\n\t        });\n\t    AxisView.extend({ type: 'xAxis' });\n\t    AxisView.extend({ type: 'yAxis' });\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [\n\t                rect.x,\n\t                rect.x + rect.width,\n\t                rect.y,\n\t                rect.y + rect.height\n\t            ];\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t        var posMap = {\n\t                x: {\n\t                    top: rectBound[2] - axisOffset,\n\t                    bottom: rectBound[3] + axisOffset\n\t                },\n\t                y: {\n\t                    left: rectBound[0] - axisOffset,\n\t                    right: rectBound[1] + axisOffset\n\t                }\n\t            };\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {\n\t                top: -1,\n\t                bottom: 1,\n\t                left: -1,\n\t                right: 1\n\t            };\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t        return layout;\n\t    }\n\t});\n\tdefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n\t    'use strict';\n\t    var textContain = require('zrender/contain/text');\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t        // \n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t        // \n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n\t            // \n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            } else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            } else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                } else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t    return function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            } else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n\t                    var y3 = y2;\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [\n\t                        [\n\t                            x1,\n\t                            y1\n\t                        ],\n\t                        [\n\t                            x2,\n\t                            y2\n\t                        ],\n\t                        [\n\t                            x3,\n\t                            y3\n\t                        ]\n\t                    ];\n\t                }\n\t                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\t});\n\tdefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n\t    var zrUtil = require('zrender/core/util');\n\t    var formatUtil = require('../../util/format');\n\t    var graphic = require('../../util/graphic');\n\t    var Model = require('../../model/Model');\n\t    var numberUtil = require('../../util/number');\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = require('zrender/core/vector');\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t    var PI = Math.PI;\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = { componentType: axisModel.mainType };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t        // Default value\n\t        zrUtil.defaults(opt, {\n\t            labelOffset: 0,\n\t            nameDirection: 1,\n\t            tickDirection: 1,\n\t            labelDirection: 1,\n\t            silent: true\n\t        });\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t                position: opt.position.slice(),\n\t                rotation: opt.rotation\n\t            });\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t    AxisBuilder.prototype = {\n\t        constructor: AxisBuilder,\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t    };\n\t    var builders = {\n\t            axisLine: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisLine.show')) {\n\t                    return;\n\t                }\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var matrix = this._transform;\n\t                var pt1 = [\n\t                        extent[0],\n\t                        0\n\t                    ];\n\t                var pt2 = [\n\t                        extent[1],\n\t                        0\n\t                    ];\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line',\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n\t                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                    silent: true,\n\t                    z2: 1\n\t                })));\n\t            },\n\t            axisTick: function () {\n\t                var axisModel = this.axisModel;\n\t                if (!axisModel.get('axisTick.show')) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var tickModel = axisModel.getModel('axisTick');\n\t                var opt = this.opt;\n\t                var lineStyleModel = tickModel.getModel('lineStyle');\n\t                var tickLen = tickModel.get('length');\n\t                var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t                var ticks = axis.scale.getTicks();\n\t                var pt1 = [];\n\t                var pt2 = [];\n\t                var matrix = this._transform;\n\t                for (var i = 0; i < ticksCoords.length; i++) {\n\t                    // Only ordinal scale support tick interval\n\t                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                        continue;\n\t                    }\n\t                    var tickCoord = ticksCoords[i];\n\t                    pt1[0] = tickCoord;\n\t                    pt1[1] = 0;\n\t                    pt2[0] = tickCoord;\n\t                    pt2[1] = opt.tickDirection * tickLen;\n\t                    if (matrix) {\n\t                        v2ApplyTransform(pt1, pt1, matrix);\n\t                        v2ApplyTransform(pt2, pt2, matrix);\n\t                    }\n\t                    // Tick line, Not use group transform to have better line draw\n\t                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                        anid: 'tick_' + ticks[i],\n\t                        shape: {\n\t                            x1: pt1[0],\n\t                            y1: pt1[1],\n\t                            x2: pt2[0],\n\t                            y2: pt2[1]\n\t                        },\n\t                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n\t                        z2: 2,\n\t                        silent: true\n\t                    })));\n\t                }\n\t            },\n\t            axisLabel: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t                if (!show) {\n\t                    return;\n\t                }\n\t                var axis = axisModel.axis;\n\t                var labelModel = axisModel.getModel('axisLabel');\n\t                var textStyleModel = labelModel.getModel('textStyle');\n\t                var labelMargin = labelModel.get('margin');\n\t                var ticks = axis.scale.getTicks();\n\t                var labels = axisModel.getFormattedLabels();\n\t                // Special label rotate.\n\t                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t                // To radian.\n\t                labelRotation = labelRotation * PI / 180;\n\t                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t                var categoryData = axisModel.get('data');\n\t                var textEls = [];\n\t                var silent = isSilent(axisModel);\n\t                var triggerEvent = axisModel.get('triggerEvent');\n\t                for (var i = 0; i < ticks.length; i++) {\n\t                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                        continue;\n\t                    }\n\t                    var itemTextStyleModel = textStyleModel;\n\t                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n\t                    }\n\t                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n\t                    var tickCoord = axis.dataToCoord(ticks[i]);\n\t                    var pos = [\n\t                            tickCoord,\n\t                            opt.labelOffset + opt.labelDirection * labelMargin\n\t                        ];\n\t                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t                    var textEl = new graphic.Text({\n\t                            anid: 'label_' + ticks[i],\n\t                            style: {\n\t                                text: labels[i],\n\t                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                                textFont: itemTextStyleModel.getFont(),\n\t                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                            },\n\t                            position: pos,\n\t                            rotation: labelLayout.rotation,\n\t                            silent: silent,\n\t                            z2: 10\n\t                        });\n\t                    // Pack data for mouse event\n\t                    if (triggerEvent) {\n\t                        textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                        textEl.eventData.targetType = 'axisLabel';\n\t                        textEl.eventData.value = labelBeforeFormat;\n\t                    }\n\t                    // FIXME\n\t                    this._dumbGroup.add(textEl);\n\t                    textEl.updateTransform();\n\t                    textEls.push(textEl);\n\t                    this.group.add(textEl);\n\t                    textEl.decomposeTransform();\n\t                }\n\t                function isTwoLabelOverlapped(current, next) {\n\t                    var firstRect = current && current.getBoundingRect().clone();\n\t                    var nextRect = next && next.getBoundingRect().clone();\n\t                    if (firstRect && nextRect) {\n\t                        firstRect.applyTransform(current.getLocalTransform());\n\t                        nextRect.applyTransform(next.getLocalTransform());\n\t                        return firstRect.intersect(nextRect);\n\t                    }\n\t                }\n\t                if (axis.type !== 'category') {\n\t                    // If min or max are user set, we need to check\n\t                    // If the tick on min(max) are overlap on their neighbour tick\n\t                    // If they are overlapped, we need to hide the min(max) tick label\n\t                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                        var firstLabel = textEls[0];\n\t                        var nextLabel = textEls[1];\n\t                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                            firstLabel.ignore = true;\n\t                        }\n\t                    }\n\t                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                        var lastLabel = textEls[textEls.length - 1];\n\t                        var prevLabel = textEls[textEls.length - 2];\n\t                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                            lastLabel.ignore = true;\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            axisName: function () {\n\t                var opt = this.opt;\n\t                var axisModel = this.axisModel;\n\t                var name = retrieve(opt.axisName, axisModel.get('name'));\n\t                if (!name) {\n\t                    return;\n\t                }\n\t                var nameLocation = axisModel.get('nameLocation');\n\t                var nameDirection = opt.nameDirection;\n\t                var textStyleModel = axisModel.getModel('nameTextStyle');\n\t                var gap = axisModel.get('nameGap') || 0;\n\t                var extent = this.axisModel.axis.getExtent();\n\t                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t                var pos = [\n\t                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n\t                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t                    ];\n\t                var labelLayout;\n\t                var nameRotation = axisModel.get('nameRotate');\n\t                if (nameRotation != null) {\n\t                    nameRotation = nameRotation * PI / 180;    // To radian.\n\t                }\n\t                var axisNameAvailableWidth;\n\t                if (nameLocation === 'middle') {\n\t                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n\t                } else {\n\t                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n\t                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                    if (axisNameAvailableWidth != null) {\n\t                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n\t                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                    }\n\t                }\n\t                var textFont = textStyleModel.getFont();\n\t                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t                var ellipsis = truncateOpt.ellipsis;\n\t                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n\t                        minChar: 2,\n\t                        placeholder: truncateOpt.placeholder\n\t                    }) : name;\n\t                var tooltipOpt = axisModel.get('tooltip', true);\n\t                var mainType = axisModel.mainType;\n\t                var formatterParams = {\n\t                        componentType: mainType,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    };\n\t                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t                var textEl = new graphic.Text({\n\t                        anid: 'name',\n\t                        __fullText: name,\n\t                        __truncatedText: truncatedText,\n\t                        style: {\n\t                            text: truncatedText,\n\t                            textFont: textFont,\n\t                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n\t                            textAlign: labelLayout.textAlign,\n\t                            textVerticalAlign: labelLayout.verticalAlign\n\t                        },\n\t                        position: pos,\n\t                        rotation: labelLayout.rotation,\n\t                        silent: isSilent(axisModel),\n\t                        z2: 1,\n\t                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n\t                            content: name,\n\t                            formatter: function () {\n\t                                return name;\n\t                            },\n\t                            formatterParams: formatterParams\n\t                        }, tooltipOpt) : null\n\t                    });\n\t                if (axisModel.get('triggerEvent')) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisName';\n\t                    textEl.eventData.name = name;\n\t                }\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t                this.group.add(textEl);\n\t                textEl.decomposeTransform();\n\t            }\n\t        };\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        if (isRadianAroundZero(rotationDiff)) {\n\t            // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI)) {\n\t            // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            } else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        } else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            } else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n\t    }\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t            var rawTick;\n\t            var scale = axis.scale;\n\t            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n\t        };\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t            var interval = model.get('interval');\n\t            if (interval == null || interval == 'auto') {\n\t                interval = labelInterval;\n\t            }\n\t            return interval;\n\t        };\n\t    return AxisBuilder;\n\t});\n\tdefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\n\tdefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\n\tvar echarts = require('echarts');\n\t\n\techarts.graphic = require('echarts/util/graphic');\n\techarts.number = require('echarts/util/number');\n\techarts.format = require('echarts/util/format');\n\t\n\t\n\trequire('echarts/chart/bar');\n\t\n\trequire('echarts/chart/pie');\n\t\n\t\n\trequire('echarts/component/grid');\n\t\n\trequire('echarts/component/title');\n\t\n\t\n\t\n\t\n\treturn echarts;\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/2.3e4fb8105425511f3d57.js\n **/","<template>\r\n    <div id=\"create\" v-if=\"!$loadingRouteData\">\r\n        <div class=\"quest\">\r\n            <div class=\"quest-title\">\r\n                <h2 v-text=\"questionnaire.title\" class=\"quest-title_preview\"></h2>\r\n            </div>\r\n            <div v-for=\"questItem in questionnaire.questItemList\" class=\"questItem-data\" track-by=\"$index\">\r\n                <div class=\"chart\" v-echarts=\"questItem\"></div>\r\n            </div>\r\n        </div>\r\n        <p class=\"preview-deadline\">{{new Date(questionnaire.deadline).toLocaleDateString()}}</p>\r\n    </div>\r\n</template>\r\n<script>\r\n    import echarts from '../echarts'\r\n\r\n    export default{\r\n        data() {\r\n            return {\r\n                typeMap: {\r\n                    radio: '',\r\n                    checkbox: '',\r\n                    textarea: ''\r\n                }\r\n            }\r\n        },\r\n        vuex: {\r\n            getters: {\r\n                questionnaire: state => state.currentQuestionnaire,\r\n                questionnaireList: state => state.questionnaireList\r\n            },\r\n            actions: {\r\n                setCurrentQuest({dispatch}, item) {\r\n                    dispatch(\"SET_QUEST\", item)\r\n                }\r\n            }\r\n        },\r\n        route: {\r\n            data({to, next}) {\r\n                let id = to.params.questId\r\n                if(!this.questionnaire) {\r\n                    this.questionnaireList.forEach(item => {\r\n                        if(parseInt(item.id) === parseInt(id)) {\r\n                            this.setCurrentQuest(item)\r\n                            return\r\n                        }\r\n                    })\r\n                }\r\n                // \r\n                next()\r\n            }\r\n        },\r\n        directives: {\r\n            'echarts': {\r\n                bind: function() {\r\n                    let self = this\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance = echarts.init(self.el)\r\n                    })\r\n                },\r\n                update: function(newVal, oldVal) {\r\n                    let self = this\r\n                    let seriesData = []\r\n                    let option = {}\r\n                    // \r\n                    if(newVal.type !== 'textarea') {\r\n                        newVal.selections.forEach(item => {\r\n                            seriesData.push(parseInt(Math.random()*100))\r\n                        })\r\n                        option = {\r\n                            grid: {\r\n                                top: 40,\r\n                                bottom: 25\r\n                            },\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            yAxis: {\r\n\r\n                            },\r\n                            xAxis: {\r\n                                data: newVal.selections\r\n                            },\r\n                            series:[{\r\n                                type: 'bar',\r\n                                data: seriesData\r\n                            }]\r\n                        }\r\n                    } else {\r\n                        seriesData.push(parseInt(Math.random()*100))\r\n                        seriesData.push(100 - seriesData[0])\r\n                        option = {\r\n                            title: {\r\n                                text: self.vm.typeMap[newVal.type] + '.' +  newVal.title,\r\n                                textAlign: \"left\"\r\n                            },\r\n                            series : [{\r\n                                type: 'pie',\r\n                                radius: \"60%\",\r\n                                data: [\r\n                                    {name: '', value: seriesData[0]},\r\n                                    {name: '', value: seriesData[1]}\r\n                                ]\r\n                            }]\r\n                        }\r\n                    }\r\n                    this.vm.$nextTick(function() {\r\n                        self.instance.setOption(option)\r\n                    })\r\n                    \r\n                },\r\n                unbind: function() {\r\n                    this.instance.dispose()\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style lang=\"less\">\r\n    #create{\r\n        .preview-deadline{\r\n            font-size: .14rem;\r\n            margin-top: .2rem;\r\n            text-align: center;\r\n        }\r\n        .quest-title_preview{\r\n            text-align: center;\r\n            letter-spacing: .05rem;\r\n            font-size: .28rem;\r\n            font-weight: bold;\r\n        }\r\n         .questItem-data{\r\n            margin: .1rem 0;\r\n            border: 1px solid #ccc;\r\n            border-radius: .03rem;\r\n        } \r\n        .chart{\r\n            min-height: 2rem;\r\n            width: 4rem;\r\n            margin: 0 auto;\r\n        }\r\n    }\r\n</style>\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** Data.vue?c8856686\n **/","exports = module.exports = require(\"./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:700}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/Data.vue\"],\"names\":[],\"mappings\":\"AAAA,0BAA0B,iBAAiB,iBAAiB,iBAAiB,CAAC,6BAA6B,kBAAkB,sBAAsB,iBAAiB,eAAgB,CAAC,wBAAwB,eAAe,sBAAsB,oBAAoB,CAAC,eAAe,gBAAgB,WAAW,aAAa,CAAC\",\"file\":\"Data.vue\",\"sourcesContent\":[\"#create .preview-deadline{font-size:.14rem;margin-top:.2rem;text-align:center}#create .quest-title_preview{text-align:center;letter-spacing:.05rem;font-size:.28rem;font-weight:bold}#create .questItem-data{margin:.1rem 0;border:1px solid #ccc;border-radius:.03rem}#create .chart{min-height:2rem;width:4rem;margin:0 auto}\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/css-loader/0.23.1/css-loader?sourceMap!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader?sourceMap!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 23\n ** module chunks = 2\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/.npminstall/vue-style-loader/1.0.0/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/less-loader/2.2.3/less-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/extract-text-webpack-plugin/1.0.1/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/.npminstall/vue-style-loader/1.0.0/vue-style-loader!./~/.npminstall/css-loader/0.23.1/css-loader?sourceMap!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./~/.npminstall/less-loader/2.2.3/less-loader?sourceMap!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./src/components/Data.vue\n ** module id = 27\n ** module chunks = 2\n **/","module.exports = \" <div id=create v-if=!$loadingRouteData> <div class=quest> <div class=quest-title> <h2 v-text=questionnaire.title class=quest-title_preview></h2> </div> <div v-for=\\\"questItem in questionnaire.questItemList\\\" class=questItem-data track-by=$index> <div class=chart v-echarts=questItem></div> </div> </div> <p class=preview-deadline>{{new Date(questionnaire.deadline).toLocaleDateString()}}</p> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/vue-html-loader/1.2.3/vue-html-loader!./~/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./src/components/Data.vue\n ** module id = 34\n ** module chunks = 2\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../../node_modules/.npminstall/extract-text-webpack-plugin/1.0.1/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!less-loader?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Data.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=script&index=0!./Data.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=template&index=0!./Data.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/Data.vue\n ** module id = 41\n ** module chunks = 2\n **/","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.echarts = factory();\n    }\n}(this, function () {var require, define;\n(function () {\n    var mods = {};\n\n    define = function (id, deps, factory) {\n        mods[id] = {\n            id: id,\n            deps: deps,\n            factory: factory,\n            defined: 0,\n            exports: {},\n            require: createRequire(id)\n        };\n    };\n\n    require = createRequire('');\n\n    function normalize(id, baseId) {\n        if (!baseId) {\n            return id;\n        }\n\n        if (id.indexOf('.') === 0) {\n            var basePath = baseId.split('/');\n            var namePath = id.split('/');\n            var baseLen = basePath.length - 1;\n            var nameLen = namePath.length;\n            var cutBaseTerms = 0;\n            var cutNameTerms = 0;\n\n            pathLoop: for (var i = 0; i < nameLen; i++) {\n                switch (namePath[i]) {\n                    case '..':\n                        if (cutBaseTerms < baseLen) {\n                            cutBaseTerms++;\n                            cutNameTerms++;\n                        }\n                        else {\n                            break pathLoop;\n                        }\n                        break;\n                    case '.':\n                        cutNameTerms++;\n                        break;\n                    default:\n                        break pathLoop;\n                }\n            }\n\n            basePath.length = baseLen - cutBaseTerms;\n            namePath = namePath.slice(cutNameTerms);\n\n            return basePath.concat(namePath).join('/');\n        }\n\n        return id;\n    }\n\n    function createRequire(baseId) {\n        var cacheMods = {};\n\n        function localRequire(id, callback) {\n            if (typeof id === 'string') {\n                var exports = cacheMods[id];\n                if (!exports) {\n                    exports = getModExports(normalize(id, baseId));\n                    cacheMods[id] = exports;\n                }\n\n                return exports;\n            }\n            else if (id instanceof Array) {\n                callback = callback || function () {};\n                callback.apply(this, getModsExports(id, callback, baseId));\n            }\n        };\n\n        return localRequire;\n    }\n\n    function getModsExports(ids, factory, baseId) {\n        var es = [];\n        var mod = mods[baseId];\n\n        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {\n            var id = normalize(ids[i], baseId);\n            var arg;\n            switch (id) {\n                case 'require':\n                    arg = (mod && mod.require) || require;\n                    break;\n                case 'exports':\n                    arg = mod.exports;\n                    break;\n                case 'module':\n                    arg = mod;\n                    break;\n                default:\n                    arg = getModExports(id);\n            }\n            es.push(arg);\n        }\n\n        return es;\n    }\n\n    function getModExports(id) {\n        var mod = mods[id];\n        if (!mod) {\n            throw new Error('No ' + id);\n        }\n\n        if (!mod.defined) {\n            var factory = mod.factory;\n            var factoryReturn = factory.apply(\n                this,\n                getModsExports(mod.deps || [], factory, id)\n            );\n            if (typeof factoryReturn !== 'undefined') {\n                mod.exports = factoryReturn;\n            }\n            mod.defined = 1;\n        }\n\n        return mod.exports;\n    }\n}());\ndefine('echarts/chart/pie', ['require', 'zrender/core/util', '../echarts', './pie/PieSeries', './pie/PieView', '../action/createDataSelectAction', '../visual/dataColor', './pie/pieLayout', '../processor/dataFilter'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n    require('../action/createDataSelectAction')('pie', [\n        {\n            type: 'pieToggleSelect',\n            event: 'pieselectchanged',\n            method: 'toggleSelected'\n        },\n        {\n            type: 'pieSelect',\n            event: 'pieselected',\n            method: 'select'\n        },\n        {\n            type: 'pieUnSelect',\n            event: 'pieunselected',\n            method: 'unSelect'\n        }\n    ]);\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n    echarts.registerLayout(zrUtil.curry(require('./pie/pieLayout'), 'pie'));\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n});\ndefine('echarts/chart/bar', ['require', 'zrender/core/util', '../coord/cartesian/Grid', './bar/BarSeries', './bar/BarView', '../layout/barGrid', '../echarts', '../component/grid'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    require('../coord/cartesian/Grid');\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n    // In case developer forget to include grid component\n    require('../component/grid');\n});\ndefine('echarts/component/title', ['require', '../echarts', '../util/graphic', '../util/layout'], function (require) {\n    'use strict';\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n    // Model\n    echarts.extendComponentModel({\n        type: 'title',\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n        defaultOption: {\n            zlevel: 0,\n            z: 6,\n            show: true,\n            text: '',\n            target: 'blank',\n            subtext: '',\n            subtarget: 'blank',\n            left: 0,\n            top: 0,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderColor: '#ccc',\n            borderWidth: 0,\n            padding: 5,\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: { color: '#aaa' }\n        }\n    });\n    // View\n    echarts.extendComponentView({\n        type: 'title',\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n            if (!titleModel.get('show')) {\n                return;\n            }\n            var group = this.group;\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n            var textEl = new graphic.Text({\n                    style: {\n                        text: titleModel.get('text'),\n                        textFont: textStyleModel.getFont(),\n                        fill: textStyleModel.getTextColor()\n                    },\n                    z2: 10\n                });\n            var textRect = textEl.getBoundingRect();\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                    style: {\n                        text: subText,\n                        textFont: subtextStyleModel.getFont(),\n                        fill: subtextStyleModel.getTextColor(),\n                        y: textRect.height + titleModel.get('itemGap'),\n                        textBaseline: 'top'\n                    },\n                    z2: 10\n                });\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding'));\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                } else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                } else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n                textBaseline = textBaseline || 'top';\n            }\n            group.attr('position', [\n                layoutRect.x,\n                layoutRect.y\n            ]);\n            var alignStyle = {\n                    textAlign: textAlign,\n                    textVerticalAlign: textBaseline\n                };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle([\n                    'color',\n                    'opacity'\n                ]);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                    shape: {\n                        x: groupRect.x - padding[3],\n                        y: groupRect.y - padding[0],\n                        width: groupRect.width + padding[1] + padding[3],\n                        height: groupRect.height + padding[0] + padding[2]\n                    },\n                    style: style,\n                    silent: true\n                });\n            graphic.subPixelOptimizeRect(rect);\n            group.add(rect);\n        }\n    });\n});\ndefine('echarts/component/grid', ['require', '../util/graphic', 'zrender/core/util', '../echarts', '../coord/cartesian/Grid', './axis'], function (require) {\n    'use strict';\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var echarts = require('../echarts');\n    require('../coord/cartesian/Grid');\n    require('./axis');\n    // Grid view\n    echarts.extendComponentView({\n        type: 'grid',\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),\n                    silent: true\n                }));\n            }\n        }\n    });\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n});\ndefine('echarts/scale/Time', ['require', 'zrender/core/util', '../util/number', '../util/format', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var IntervalScale = require('./Interval');\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    };\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n            type: 'time',\n            getLabel: function (val) {\n                var stepLvl = this._stepLvl;\n                var date = new Date(val);\n                return formatUtil.formatTime(stepLvl[0], date);\n            },\n            niceExtent: function (approxTickNum, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    // Expand extent\n                    extent[0] -= ONE_DAY;\n                    extent[1] += ONE_DAY;\n                }\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (extent[1] === -Infinity && extent[0] === Infinity) {\n                    var d = new Date();\n                    extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                    extent[0] = extent[1] - ONE_DAY;\n                }\n                this.niceTicks(approxTickNum);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n                }\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                var approxInterval = span / approxTickNum;\n                var scaleLevelsLen = scaleLevels.length;\n                var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n                var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n                var interval = level[2];\n                // Same with interval scale if span is much larger than 1 year\n                if (level[0] === 'year') {\n                    var yearSpan = span / interval;\n                    // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                    // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                    var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n                    interval *= yearStep;\n                }\n                var niceExtent = [\n                        mathCeil(extent[0] / interval) * interval,\n                        mathFloor(extent[1] / interval) * interval\n                    ];\n                this._stepLvl = level;\n                // Interval will be used in getTicks\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            parse: function (val) {\n                // val might be float.\n                return +numberUtil.parseDate(val);\n            }\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n    // Steps from d3\n    var scaleLevels = [\n            [\n                'hh:mm:ss',\n                1,\n                ONE_SECOND\n            ],\n            [\n                'hh:mm:ss',\n                5,\n                ONE_SECOND * 5\n            ],\n            [\n                'hh:mm:ss',\n                10,\n                ONE_SECOND * 10\n            ],\n            [\n                'hh:mm:ss',\n                15,\n                ONE_SECOND * 15\n            ],\n            [\n                'hh:mm:ss',\n                30,\n                ONE_SECOND * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_MINUTE\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                5,\n                ONE_MINUTE * 5\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                10,\n                ONE_MINUTE * 10\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                15,\n                ONE_MINUTE * 15\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                30,\n                ONE_MINUTE * 30\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                1,\n                ONE_HOUR\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                2,\n                ONE_HOUR * 2\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                6,\n                ONE_HOUR * 6\n            ],\n            [\n                'hh:mm\\nMM-dd',\n                12,\n                ONE_HOUR * 12\n            ],\n            [\n                'MM-dd\\nyyyy',\n                1,\n                ONE_DAY\n            ],\n            [\n                'week',\n                7,\n                ONE_DAY * 7\n            ],\n            [\n                'month',\n                1,\n                ONE_DAY * 31\n            ],\n            [\n                'quarter',\n                3,\n                ONE_DAY * 380 / 4\n            ],\n            [\n                'half-year',\n                6,\n                ONE_DAY * 380 / 2\n            ],\n            [\n                'year',\n                1,\n                ONE_DAY * 380\n            ]\n        ];\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n    return TimeScale;\n});\ndefine('echarts/echarts', ['require', 'zrender/core/env', './model/Global', './ExtensionAPI', './CoordinateSystem', './model/OptionManager', './model/Component', './model/Series', './view/Component', './view/Chart', './util/graphic', 'zrender', 'zrender/core/util', 'zrender/tool/color', 'zrender/mixin/Eventful', 'zrender/core/timsort', './visual/seriesColor', './preprocessor/backwardCompat', './loading/default', './data/List', './model/Model', './util/number', './util/format', 'zrender/core/matrix', 'zrender/core/vector'], function (require) {\n    var env = require('zrender/core/env');\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/core/util');\n    var colorTool = require('zrender/tool/color');\n    var Eventful = require('zrender/mixin/Eventful');\n    var timsort = require('zrender/core/timsort');\n    var each = zrUtil.each;\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n    var OPTION_UPDATED = '_optionUpdated';\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio\n        });\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n        Eventful.call(this);\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n        // Init mouse events\n        this._initEvents();\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n    var echartsProto = ECharts.prototype;\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            this[IN_MAIN_PROCESS] = true;\n            updateMethods.prepareAndUpdate.call(this);\n            this[IN_MAIN_PROCESS] = false;\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n        this._model.setOption(option, optionPreprocessorFuncs);\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        } else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({ mainType: componentType }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n        var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = opts && opts.pixelRatio || 1;\n            for (var id in instances) {\n                var chart = instances[id];\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            }\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                        style: {\n                            x: item.left * dpr - left,\n                            y: item.top * dpr - top,\n                            image: item.dom\n                        }\n                    });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        } else {\n            return this.getDataURL(opts);\n        }\n    };\n    var updateMethods = {\n            update: function (payload) {\n                // console.time && console.time('update');\n                var ecModel = this._model;\n                var api = this._api;\n                var coordSysMgr = this._coordSysMgr;\n                var zr = this._zr;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                // Fixme First time update ?\n                ecModel.restoreData();\n                // TODO\n                // Save total ecModel here for undo/redo (after restoring data and before processing data).\n                // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n                // Create new coordinate system each update\n                // In LineView may save the old coordinate system and use it to get the orignal point\n                coordSysMgr.create(this._model, this._api);\n                processData.call(this, ecModel, api);\n                stackSeriesData.call(this, ecModel);\n                coordSysMgr.update(ecModel, api);\n                doVisualEncoding.call(this, ecModel, payload);\n                doRender.call(this, ecModel, payload);\n                // Set background\n                var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n                var painter = zr.painter;\n                // TODO all use clearColor ?\n                if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                    zr.configLayer(0, { clearColor: backgroundColor });\n                } else {\n                    // In IE8\n                    if (!env.canvasSupported) {\n                        var colorArr = colorTool.parse(backgroundColor);\n                        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                        if (colorArr[3] === 0) {\n                            backgroundColor = 'transparent';\n                        }\n                    }\n                    if (backgroundColor.colorStops || backgroundColor.image) {\n                        // Gradient background\n                        // FIXME Fixed layer\n                        zr.configLayer(0, { clearColor: backgroundColor });\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n                        this._dom.style.background = 'transparent';\n                    } else {\n                        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                            zr.configLayer(0, { clearColor: null });\n                        }\n                        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n                        this._dom.style.background = backgroundColor;\n                    }\n                }    // console.time && console.timeEnd('update');\n            },\n            updateView: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n            },\n            updateVisual: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                ecModel.eachSeries(function (seriesModel) {\n                    seriesModel.getData().clearAllVisual();\n                });\n                doVisualEncoding.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n            },\n            updateLayout: function (payload) {\n                var ecModel = this._model;\n                // update before setOption\n                if (!ecModel) {\n                    return;\n                }\n                doLayout.call(this, ecModel, payload);\n                invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n            },\n            highlight: function (payload) {\n                toggleHighlight.call(this, 'highlight', payload);\n            },\n            downplay: function (payload) {\n                toggleHighlight.call(this, 'downplay', payload);\n            },\n            prepareAndUpdate: function (payload) {\n                var ecModel = this._model;\n                prepareView.call(this, 'component', ecModel);\n                prepareView.call(this, 'chart', ecModel);\n                updateMethods.update.call(this, payload);\n            }\n        };\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n        ecModel.eachComponent({\n            mainType: 'series',\n            query: payload\n        }, function (seriesModel, index) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            if (chartView && chartView.__alive) {\n                chartView[method](seriesModel, ecModel, this._api, payload);\n            }\n        }, this);\n    }\n    /**\n     * Resize the chart\n     */\n    echartsProto.resize = function () {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n        this[IN_MAIN_PROCESS] = true;\n        this._zr.resize();\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n        this[IN_MAIN_PROCESS] = false;\n        this._flushPendingActions();\n    };\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (true) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n        zr.add(el);\n    };\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n        this[IN_MAIN_PROCESS] = true;\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            } else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        } else {\n            eventObj = eventObjBatch[0];\n        }\n        this[IN_MAIN_PROCESS] = false;\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n        this._flushPendingActions();\n    };\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n            updateZ(componentModel, component);\n        }, this);\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n            updateZ(seriesModel, chart);\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            } else {\n                model = componentType;\n            }\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                } else {\n                    // Error\n                    return;\n                }\n            }\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            } else {\n                i++;\n            }\n        }\n    }\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n            updateZ(componentModel, componentView);\n        }, this);\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n            chartView.group.silent = !!seriesModel.get('silent');\n            updateZ(seriesModel, chartView);\n            updateProgressiveAndBlend(seriesModel, chartView);\n        }, this);\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n    var MOUSE_EVENT_NAMES = [\n            'click',\n            'dblclick',\n            'mouseover',\n            'mouseout',\n            'mousemove',\n            'mousedown',\n            'mouseup',\n            'globalout'\n        ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }    // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    this.trigger(eveName, el.eventData);\n                }\n            }, this);\n        }, this);\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (true) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n        var api = this._api;\n        var ecModel = this._model;\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n        // Dispose after all views disposed\n        this._zr.dispose();\n        delete instances[this.id];\n    };\n    zrUtil.mixin(ECharts, Eventful);\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (true) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n    var instances = {};\n    var connectedGroups = {};\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n            version: '3.2.3',\n            dependencies: { zrender: '3.1.3' }\n        };\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n                    for (var id in instances) {\n                        var otherChart = instances[id];\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    }\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (true) {\n            // Check version\n            if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {\n                throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        enableConnect(chart);\n        return chart;\n    };\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || 'g_' + groupIdBase++;\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        } else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if (chart instanceof ECharts && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [\n                actionInfo,\n                actionInfo = { event: eventName }\n            ][0];\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n        if (!actions[actionType]) {\n            actions[actionType] = {\n                action: action,\n                actionInfo: actionInfo\n            };\n        }\n        eventActionMap[eventName] = actionType;\n    };\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/core/matrix');\n    echarts.vector = require('zrender/core/vector');\n    echarts.color = require('zrender/tool/color');\n    echarts.util = {};\n    each([\n        'map',\n        'each',\n        'filter',\n        'indexOf',\n        'inherits',\n        'reduce',\n        'filter',\n        'bind',\n        'curry',\n        'isArray',\n        'isString',\n        'isObject',\n        'isFunction',\n        'extend',\n        'defaults'\n    ], function (name) {\n        echarts.util[name] = zrUtil[name];\n    });\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n    return echarts;\n});\ndefine('echarts/scale/Log', ['require', 'zrender/core/util', './Scale', '../util/number', './Interval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n    var mathLog = Math.log;\n    var LogScale = Scale.extend({\n            type: 'log',\n            base: 10,\n            getTicks: function () {\n                return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                    return numberUtil.round(mathPow(this.base, val));\n                }, this);\n            },\n            getLabel: intervalScaleProto.getLabel,\n            scale: function (val) {\n                val = scaleProto.scale.call(this, val);\n                return mathPow(this.base, val);\n            },\n            setExtent: function (start, end) {\n                var base = this.base;\n                start = mathLog(start) / mathLog(base);\n                end = mathLog(end) / mathLog(base);\n                intervalScaleProto.setExtent.call(this, start, end);\n            },\n            getExtent: function () {\n                var base = this.base;\n                var extent = scaleProto.getExtent.call(this);\n                extent[0] = mathPow(base, extent[0]);\n                extent[1] = mathPow(base, extent[1]);\n                return extent;\n            },\n            unionExtent: function (extent) {\n                var base = this.base;\n                extent[0] = mathLog(extent[0]) / mathLog(base);\n                extent[1] = mathLog(extent[1]) / mathLog(base);\n                scaleProto.unionExtent.call(this, extent);\n            },\n            niceTicks: function (approxTickNum) {\n                approxTickNum = approxTickNum || 10;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (span === Infinity || span <= 0) {\n                    return;\n                }\n                var interval = numberUtil.quantity(span);\n                var err = approxTickNum / span * interval;\n                // Filter ticks to get closer to the desired count.\n                if (err <= 0.5) {\n                    interval *= 10;\n                }\n                // Interval should be integer\n                while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                    interval *= 10;\n                }\n                var niceExtent = [\n                        numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                        numberUtil.round(mathFloor(extent[1] / interval) * interval)\n                    ];\n                this._interval = interval;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: intervalScaleProto.niceExtent\n        });\n    zrUtil.each([\n        'contain',\n        'normalize'\n    ], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n    LogScale.create = function () {\n        return new LogScale();\n    };\n    return LogScale;\n});\ndefine('echarts/chart/pie/PieView', ['require', '../../util/graphic', 'zrender/core/util', '../../view/Chart'], function (require) {\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n        data.each(function (idx) {\n            toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n        });\n    }\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [\n                dx * offset,\n                dy * offset\n            ];\n        hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);\n    }\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n        graphic.Group.call(this);\n        var sector = new graphic.Sector({ z2: 2 });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n        this.updateData(data, idx, true);\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n    }\n    var piePieceProto = PiePiece.prototype;\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))\n        };\n    }\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n        var sector = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel, idx);\n        } else {\n            graphic.updateProps(sector, { shape: sectorShape }, seriesModel, idx);\n        }\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n        sector.useStyle(zrUtil.defaults({\n            lineJoin: 'bevel',\n            fill: visualColor\n        }, itemStyleModel.getModel('normal').getItemStyle()));\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n        // Toggle selected\n        toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n        }\n        this._updateLabel(data, idx);\n        graphic.setHoverStyle(this);\n    };\n    piePieceProto._updateLabel = function (data, idx) {\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ],\n                    [\n                        labelLayout.x,\n                        labelLayout.y\n                    ]\n                ]\n            }\n        }, seriesModel, idx);\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [\n                labelLayout.x,\n                labelLayout.y\n            ],\n            z2: 10\n        });\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({ smooth: smooth });\n    };\n    zrUtil.inherits(PiePiece, graphic.Group);\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n            type: 'pie',\n            init: function () {\n                var sectorGroup = new graphic.Group();\n                this._sectorGroup = sectorGroup;\n            },\n            render: function (seriesModel, ecModel, api, payload) {\n                if (payload && payload.from === this.uid) {\n                    return;\n                }\n                var data = seriesModel.getData();\n                var oldData = this._data;\n                var group = this.group;\n                var hasAnimation = ecModel.get('animation');\n                var isFirstRender = !oldData;\n                var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n                var selectedMode = seriesModel.get('selectedMode');\n                data.diff(oldData).add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    data.setItemGraphicEl(idx, piePiece);\n                    group.add(piePiece);\n                }).update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n                    piePiece.updateData(data, newIdx);\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                }).remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                }).execute();\n                if (hasAnimation && isFirstRender && data.count() > 0) {\n                    var shape = data.getItemLayout(0);\n                    var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n                    var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                    group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n                }\n                this._data = data;\n            },\n            _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n                var clipPath = new graphic.Sector({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r0: 0,\n                            r: r,\n                            startAngle: startAngle,\n                            endAngle: startAngle,\n                            clockwise: clockwise\n                        }\n                    });\n                graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);\n                return clipPath;\n            }\n        });\n    return Pie;\n});\ndefine('echarts/chart/pie/PieSeries', ['require', '../../data/List', 'zrender/core/util', '../../util/model', '../../data/helper/completeDimensions', '../../component/helper/selectableMixin', '../../echarts'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n    var PieSeries = require('../../echarts').extendSeriesModel({\n            type: 'series.pie',\n            init: function (option) {\n                PieSeries.superApply(this, 'init', arguments);\n                // Enable legend selection for each data item\n                // Use a function instead of direct access because data reference may changed\n                this.legendDataProvider = function () {\n                    return this._dataBeforeProcessed;\n                };\n                this.updateSelectedMap(option.data);\n                this._defaultLabelLine(option);\n            },\n            mergeOption: function (newOption) {\n                PieSeries.superCall(this, 'mergeOption', newOption);\n                this.updateSelectedMap(this.option.data);\n            },\n            getInitialData: function (option, ecModel) {\n                var dimensions = completeDimensions(['value'], option.data);\n                var list = new List(dimensions, this);\n                list.initData(option.data);\n                return list;\n            },\n            getDataParams: function (dataIndex) {\n                var data = this._data;\n                var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n                var sum = data.getSum('value');\n                // FIXME toFixed?\n                //\n                // Percent is 0 if sum is 0\n                params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n                params.$vars.push('percent');\n                return params;\n            },\n            _defaultLabelLine: function (option) {\n                // Extend labelLine emphasis\n                modelUtil.defaultEmphasis(option.labelLine, ['show']);\n                var labelLineNormalOpt = option.labelLine.normal;\n                var labelLineEmphasisOpt = option.labelLine.emphasis;\n                // Not show label line if `label.normal.show = false`\n                labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n                labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n            },\n            defaultOption: {\n                zlevel: 0,\n                z: 2,\n                legendHoverLink: true,\n                hoverAnimation: true,\n                center: [\n                    '50%',\n                    '50%'\n                ],\n                radius: [\n                    0,\n                    '75%'\n                ],\n                clockwise: true,\n                startAngle: 90,\n                minAngle: 0,\n                selectedOffset: 10,\n                avoidLabelOverlap: true,\n                label: {\n                    normal: {\n                        rotate: false,\n                        show: true,\n                        position: 'outer'\n                    },\n                    emphasis: {}\n                },\n                labelLine: {\n                    normal: {\n                        show: true,\n                        length: 15,\n                        length2: 15,\n                        smooth: false,\n                        lineStyle: {\n                            width: 1,\n                            type: 'solid'\n                        }\n                    }\n                },\n                itemStyle: {\n                    normal: { borderWidth: 1 },\n                    emphasis: {}\n                },\n                animationEasing: 'cubicOut',\n                data: []\n            }\n        });\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n    return PieSeries;\n});\ndefine('echarts/action/createDataSelectAction', ['require', '../echarts', 'zrender/core/util'], function (require) {\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/core/util');\n    return function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent({\n                    mainType: 'series',\n                    subType: seriesType,\n                    query: payload\n                }, function (seriesModel) {\n                    if (seriesModel[actionInfo.method]) {\n                        seriesModel[actionInfo.method](payload.name);\n                    }\n                    var data = seriesModel.getData();\n                    // Create selected map\n                    data.each(function (idx) {\n                        var name = data.getName(idx);\n                        selected[name] = seriesModel.isSelected(name) || false;\n                    });\n                });\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n});\ndefine('zrender/core/util', ['require'], function (require) {\n    // mergeDate\n    var BUILTIN_OBJECT = {\n            '[object Function]': 1,\n            '[object RegExp]': 1,\n            '[object Date]': 1,\n            '[object Error]': 1,\n            '[object CanvasGradient]': 1,\n            '[object CanvasPattern]': 1,\n            '[object Image]': 1\n        };\n    var objToString = Object.prototype.toString;\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n    /**\n     * @param {*} source\n     * @return {*} \n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            } else if (!isBuildInObject(source) && !isDom(source)) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n            return result;\n        }\n        return source;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                } else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {\n        }\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n        defaults(target, source, overlay);\n    }\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (!data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        } else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        } else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        } else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || !!value && type == 'object';\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1 && typeof value.nodeName == 'string';\n    }\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n    var util = {\n            inherits: inherits,\n            mixin: mixin,\n            clone: clone,\n            merge: merge,\n            mergeAll: mergeAll,\n            extend: extend,\n            defaults: defaults,\n            getContext: getContext,\n            createCanvas: createCanvas,\n            indexOf: indexOf,\n            slice: slice,\n            find: find,\n            isArrayLike: isArrayLike,\n            each: each,\n            map: map,\n            reduce: reduce,\n            filter: filter,\n            bind: bind,\n            curry: curry,\n            isArray: isArray,\n            isString: isString,\n            isObject: isObject,\n            isFunction: isFunction,\n            isBuildInObject: isBuildInObject,\n            isDom: isDom,\n            retrieve: retrieve,\n            assert: assert,\n            noop: function () {\n            }\n        };\n    return util;\n});\ndefine('echarts/visual/dataColor', ['require'], function (require) {\n    return function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    } else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n});\ndefine('echarts/chart/pie/pieLayout', ['require', '../../util/number', './labelLayout', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/core/util');\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n    return function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n            if (!zrUtil.isArray(radius)) {\n                radius = [\n                    0,\n                    radius\n                ];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [\n                    center,\n                    center\n                ];\n            }\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n            var data = seriesModel.getData();\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n            var clockwise = seriesModel.get('clockwise');\n            var roseType = seriesModel.get('roseType');\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : value * unitRadian;\n                } else {\n                    angle = PI2 / (data.count() || 1);\n                }\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                } else {\n                    valueSumLargerThanMinAngle += value;\n                }\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType ? numberUtil.linearMap(value, extent, [\n                        r0,\n                        r\n                    ]) : r\n                });\n                currentAngle = endAngle;\n            }, true);\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 0.001) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                } else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n});\ndefine('echarts/processor/dataFilter', [], function () {\n    return function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({ mainType: 'legend' });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n});\ndefine('echarts/coord/cartesian/Grid', ['require', 'exports', '../../util/layout', '../../coord/axisHelper', 'zrender/core/util', './Cartesian2D', './Axis2D', './GridModel', '../../CoordinateSystem'], function (require, factory) {\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n    var zrUtil = require('zrender/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n    var each = zrUtil.each;\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n    //  GridModel, AxisModel \n    require('./GridModel');\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : rect = singleRect;\n            }\n        }\n        return rect;\n    }\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n        this._initCartesian(gridModel, ecModel, api);\n        this._model = gridModel;\n    }\n    var gridProto = Grid.prototype;\n    gridProto.type = 'grid';\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n    gridProto.update = function (ecModel, api) {\n        var axesMap = this._axesMap;\n        this._updateScale(ecModel, this._model);\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                var axis = axes[idx];\n                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n        var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        this._rect = gridRect;\n        var axesList = this._axesList;\n        adjustAxes();\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        } else if (axis.position === 'left') {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n            adjustAxes();\n        }\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [\n                        0,\n                        gridRect.width\n                    ] : [\n                        0,\n                        gridRect.height\n                    ];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    return axesMapOnDim[name];\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        } else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n                left: false,\n                right: false,\n                top: false,\n                bottom: false\n            };\n        var axesMap = {\n                x: {},\n                y: {}\n            };\n        var axesCount = {\n                x: 0,\n                y: 0\n            };\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n        this._axesMap = axesMap;\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n                cartesian.grid = this;\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                } else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n                var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [\n                        0,\n                        0\n                    ], axisModel.get('type'), axisPosition);\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n                axis.onZero = axisModel.get('axisLine.onZero');\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n                // Inject axisModel into axis\n                axis.model = axisModel;\n                // Inject grid info axis\n                axis.grid = this;\n                // Index of axis, can be used as key\n                axis.index = idx;\n                this._axesList.push(axis);\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n                    return;\n                }\n                var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));\n            });\n        }\n    };\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n            return coord + coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n        axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n            return coord - coordBase;\n        } : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n    }\n    var axesTypes = [\n            'xAxis',\n            'yAxis'\n        ];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = ecModel.queryComponents({\n                    mainType: axisType,\n                    index: seriesModel.get(axisType + 'Index'),\n                    id: seriesModel.get(axisType + 'Id')\n                })[0];\n            if (true) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n            gridModel.coordinateSystem = grid;\n            grids.push(grid);\n        });\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n            var gridModel = xAxisModel.findGridModel();\n            if (true) {\n                if (!gridModel) {\n                    throw new Error('Grid \"' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n            var grid = gridModel.coordinateSystem;\n            seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        });\n        return grids;\n    };\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n    return Grid;\n});\ndefine('echarts/chart/bar/BarSeries', ['require', '../../model/Series', '../helper/createListFromArray'], function (require) {\n    'use strict';\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n    return SeriesModel.extend({\n        type: 'series.bar',\n        dependencies: [\n            'grid',\n            'polar'\n        ],\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [\n                NaN,\n                NaN\n            ];\n        },\n        brushSelector: 'rect',\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            barMinHeight: 0,\n            itemStyle: {\n                normal: {},\n                emphasis: {}\n            }\n        }\n    });\n});\ndefine('echarts/chart/bar/BarView', ['require', 'zrender/core/util', '../../util/graphic', '../../model/Model', './barItemStyle', '../../echarts'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n    return require('../../echarts').extendChartView({\n        type: 'bar',\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n            return this.group;\n        },\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var enableAnimation = seriesModel.get('animation');\n            var barBorderWidthQuery = [\n                    'itemStyle',\n                    'normal',\n                    'barBorderWidth'\n                ];\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData).add(function (dataIndex) {\n                // \n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n                var rect = createRect(dataIndex);\n                data.setItemGraphicEl(dataIndex, rect);\n                group.add(rect);\n            }).update(function (newIndex, oldIndex) {\n                var rect = oldData.getItemGraphicEl(oldIndex);\n                // \n                if (!data.hasValue(newIndex)) {\n                    group.remove(rect);\n                    return;\n                }\n                if (!rect) {\n                    rect = createRect(newIndex, true);\n                }\n                var layout = data.getItemLayout(newIndex);\n                var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n                graphic.updateProps(rect, { shape: layout }, seriesModel, newIndex);\n                data.setItemGraphicEl(newIndex, rect);\n                // Add back\n                group.add(rect);\n            }).remove(function (idx) {\n                var rect = oldData.getItemGraphicEl(idx);\n                if (rect) {\n                    // Not show text when animating\n                    rect.style.text = '';\n                    graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, idx, function () {\n                        group.remove(rect);\n                    });\n                }\n            }).execute();\n            this._updateStyle(seriesModel, data, isHorizontal);\n            this._data = data;\n        },\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n                rect.useStyle(zrUtil.defaults({\n                    fill: color,\n                    opacity: opacity\n                }, itemStyleModel.getBarItemStyle()));\n                var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);\n                } else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, { shape: { width: 0 } }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            } else {\n                group.removeAll();\n            }\n        }\n    });\n});\ndefine('echarts/layout/barGrid', ['require', 'zrender/core/util', '../util/number'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                    bandWidth: bandWidth,\n                    remainedWidth: bandWidth,\n                    autoWidthCount: 0,\n                    categoryGap: '20%',\n                    gap: '30%',\n                    stacks: {}\n                };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n            var stackId = getSeriesStackId(seriesModel);\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n            var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n            var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            barGap != null && (columnsOnAxis.gap = barGap);\n            barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n        var result = {};\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n            result[coordSysName] = {};\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n        return result;\n    }\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n        var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n            }));\n        var lastStackCoords = {};\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n            var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n            data.each(valueAxis.dim, function (value, idx) {\n                // \n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart,\n                        n: valueAxisStart\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var x, y, width, height;\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoord;\n                    height = columnWidth;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                } else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoord;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n        }, this);\n    }\n    return barLayoutGrid;\n});\ndefine('echarts/util/graphic', ['require', 'zrender/core/util', 'zrender/tool/path', 'zrender/graphic/Path', 'zrender/tool/color', 'zrender/core/matrix', 'zrender/core/vector', 'zrender/graphic/Gradient', 'zrender/container/Group', 'zrender/graphic/Image', 'zrender/graphic/Text', 'zrender/graphic/shape/Circle', 'zrender/graphic/shape/Sector', 'zrender/graphic/shape/Ring', 'zrender/graphic/shape/Polygon', 'zrender/graphic/shape/Polyline', 'zrender/graphic/shape/Rect', 'zrender/graphic/shape/Line', 'zrender/graphic/shape/BezierCurve', 'zrender/graphic/shape/Arc', 'zrender/graphic/CompoundPath', 'zrender/graphic/LinearGradient', 'zrender/graphic/RadialGradient', 'zrender/core/BoundingRect'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var pathTool = require('zrender/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/graphic/Path');\n    var colorTool = require('zrender/tool/color');\n    var matrix = require('zrender/core/matrix');\n    var vector = require('zrender/core/vector');\n    var Gradient = require('zrender/graphic/Gradient');\n    var graphic = {};\n    graphic.Group = require('zrender/container/Group');\n    graphic.Image = require('zrender/graphic/Image');\n    graphic.Text = require('zrender/graphic/Text');\n    graphic.Circle = require('zrender/graphic/shape/Circle');\n    graphic.Sector = require('zrender/graphic/shape/Sector');\n    graphic.Ring = require('zrender/graphic/shape/Ring');\n    graphic.Polygon = require('zrender/graphic/shape/Polygon');\n    graphic.Polyline = require('zrender/graphic/shape/Polyline');\n    graphic.Rect = require('zrender/graphic/shape/Rect');\n    graphic.Line = require('zrender/graphic/shape/Line');\n    graphic.BezierCurve = require('zrender/graphic/shape/BezierCurve');\n    graphic.Arc = require('zrender/graphic/shape/Arc');\n    graphic.CompoundPath = require('zrender/graphic/CompoundPath');\n    graphic.LinearGradient = require('zrender/graphic/LinearGradient');\n    graphic.RadialGradient = require('zrender/graphic/RadialGradient');\n    graphic.BoundingRect = require('zrender/core/BoundingRect');\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                } else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n    graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n        var pathRect = path.getBoundingRect();\n        var m = pathRect.calculateTransform(rect);\n        path.applyTransform(m);\n    };\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n        shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n        return param;\n    };\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n            el.__normalStl = normalStyle;\n            el.__hoverStlDirty = false;\n        }\n    }\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n        cacheElementStl(el);\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        } else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n        el.__isHover = true;\n    }\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        } else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n        el.__isHover = false;\n    }\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleEnterHover(child);\n            }\n        }) : doSingleEnterHover(el);\n    }\n    function doLeaveHover(el) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleLeaveHover(child);\n            }\n        }) : doSingleLeaveHover(el);\n    }\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group' ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                setElementHoverStl(child, hoverStyle);\n            }\n        }) : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n    };\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel && (animatableModel.ifEnableAnimation ? animatableModel.ifEnableAnimation() : animatableModel.getShallow('animation'));\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb) : (el.attr(props), cb && cb());\n        } else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n        return mat;\n    };\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n        var vertex = [\n                direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n                direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n            ];\n        vertex = graphic.applyTransform(vertex, transform, invert);\n        return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n    };\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                    position: vector.clone(el.position),\n                    rotation: el.rotation\n                };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }    // else {\n                     //     if (el.previousProps) {\n                     //         graphic.updateProps\n                     //     }\n                     // }\n            }\n        });\n    };\n    return graphic;\n});\ndefine('echarts/component/axis', ['require', '../coord/cartesian/AxisModel', './axis/AxisView'], function (require) {\n    'use strict';\n    require('../coord/cartesian/AxisModel');\n    require('./axis/AxisView');\n});\ndefine('echarts/util/layout', ['require', 'zrender/core/util', 'zrender/core/BoundingRect', './number', './format'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var BoundingRect = require('zrender/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n    var layout = {};\n    var LOCATION_PARAMS = [\n            'left',\n            'right',\n            'top',\n            'bottom',\n            'width',\n            'height'\n        ];\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            } else {\n                var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                } else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n            if (child.newline) {\n                return;\n            }\n            position[0] = x;\n            position[1] = y;\n            orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n        });\n    }\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            } else {\n                height = containerHeight * 0.8;\n            }\n        }\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n            left = containerWidth / 2 - width / 2 - margin[3];\n            break;\n        case 'right':\n            left = containerWidth - width - horizontalMargin;\n            break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n            top = containerHeight / 2 - height / 2 - margin[0];\n            break;\n        case 'bottom':\n            top = containerHeight - height - verticalMargin;\n            break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (group, positionInfo, containerRect, margin) {\n        var groupRect = group.getBoundingRect();\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n        positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = [\n                'width',\n                'left',\n                'right'\n            ];\n        // Order by priority.\n        var vNames = [\n                'height',\n                'top',\n                'bottom'\n            ];\n        // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }    // Case: newOption: {width: ..., right: ...},\n                 // Than we can make sure user only want those two, and ignore\n                 // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            } else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n    return layout;\n});\ndefine('echarts/util/number', ['require'], function (require) {\n    var number = {};\n    var RADIAN_EPSILON = 0.0001;\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n        if (subDomain === 0) {\n            return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n        }\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                } else if (val >= domain[1]) {\n                    return range[1];\n                }\n            } else {\n                if (val >= domain[0]) {\n                    return range[0];\n                } else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        } else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function (percent, all) {\n        switch (percent) {\n        case 'center':\n        case 'middle':\n            percent = '50%';\n            break;\n        case 'left':\n        case 'top':\n            percent = '0%';\n            break;\n        case 'right':\n        case 'bottom':\n            percent = '100%';\n            break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n            return parseFloat(percent);\n        }\n        return percent == null ? NaN : +percent;\n    };\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // PENDING\n        return +(+x).toFixed(precision);\n    };\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(-dataQuantity + sizeQuantity, 0);\n    };\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        } else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n        return new Date(Math.round(value));\n    };\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10;\n        // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) {\n                nf = 1;\n            } else if (f < 2.5) {\n                nf = 2;\n            } else if (f < 4) {\n                nf = 3;\n            } else if (f < 7) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        } else {\n            if (f < 1) {\n                nf = 1;\n            } else if (f < 2) {\n                nf = 2;\n            } else if (f < 3) {\n                nf = 3;\n            } else if (f < 5) {\n                nf = 5;\n            } else {\n                nf = 10;\n            }\n        }\n        return nf * exp10;\n    };\n    return number;\n});\ndefine('echarts/util/format', ['require', 'zrender/core/util', './number', 'zrender/contain/text'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/contain/text');\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n    };\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function (match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof val === 'number') {\n            return [\n                val,\n                val,\n                val,\n                val\n            ];\n        } else if (len === 2) {\n            // vertical | horizontal\n            return [\n                val[0],\n                val[1],\n                val[0],\n                val[1]\n            ];\n        } else if (len === 3) {\n            // top | horizontal | bottom\n            return [\n                val[0],\n                val[1],\n                val[2],\n                val[1]\n            ];\n        }\n        return val;\n    };\n    formatUtil.encodeHTML = function (source) {\n        return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    };\n    var TPL_VAR_ALIAS = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g'\n        ];\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);\n            }\n        }\n        return tpl;\n    };\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? '0' + str : str;\n    };\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n            tpl = 'MM-dd\\nyyyy';\n        }\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n        tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n        return tpl;\n    };\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n    formatUtil.truncateText = textContain.truncateText;\n    return formatUtil;\n});\ndefine('echarts/scale/Interval', ['require', '../util/number', '../util/format', './Scale'], function (require) {\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n            type: 'interval',\n            _interval: 0,\n            setExtent: function (start, end) {\n                var thisExtent = this._extent;\n                //start,end may be a Number like '25',so...\n                if (!isNaN(start)) {\n                    thisExtent[0] = parseFloat(start);\n                }\n                if (!isNaN(end)) {\n                    thisExtent[1] = parseFloat(end);\n                }\n            },\n            unionExtent: function (other) {\n                var extent = this._extent;\n                other[0] < extent[0] && (extent[0] = other[0]);\n                other[1] > extent[1] && (extent[1] = other[1]);\n                // unionExtent may called by it's sub classes\n                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n            },\n            getInterval: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                return this._interval;\n            },\n            setInterval: function (interval) {\n                this._interval = interval;\n                // Dropped auto calculated niceExtent and use user setted extent\n                // We assume user wan't to set both interval, min, max to get a better result\n                this._niceExtent = this._extent.slice();\n            },\n            getTicks: function () {\n                if (!this._interval) {\n                    this.niceTicks();\n                }\n                var interval = this._interval;\n                var extent = this._extent;\n                var ticks = [];\n                // Consider this case: using dataZoom toolbox, zoom and zoom.\n                var safeLimit = 10000;\n                if (interval) {\n                    var niceExtent = this._niceExtent;\n                    var precision = getPrecisionSafe(interval) + 2;\n                    if (extent[0] < niceExtent[0]) {\n                        ticks.push(extent[0]);\n                    }\n                    var tick = niceExtent[0];\n                    while (tick <= niceExtent[1]) {\n                        ticks.push(tick);\n                        // Avoid rounding error\n                        tick = roundingErrorFix(tick + interval, precision);\n                        if (ticks.length > safeLimit) {\n                            return [];\n                        }\n                    }\n                    if (extent[1] > niceExtent[1]) {\n                        ticks.push(extent[1]);\n                    }\n                }\n                return ticks;\n            },\n            getTicksLabels: function () {\n                var labels = [];\n                var ticks = this.getTicks();\n                for (var i = 0; i < ticks.length; i++) {\n                    labels.push(this.getLabel(ticks[i]));\n                }\n                return labels;\n            },\n            getLabel: function (data) {\n                return formatUtil.addCommas(data);\n            },\n            niceTicks: function (splitNumber) {\n                splitNumber = splitNumber || 5;\n                var extent = this._extent;\n                var span = extent[1] - extent[0];\n                if (!isFinite(span)) {\n                    return;\n                }\n                // User may set axis min 0 and data are all negative\n                // FIXME If it needs to reverse ?\n                if (span < 0) {\n                    span = -span;\n                    extent.reverse();\n                }\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceSpan = numberUtil.nice(span, false);\n                var step = roundingErrorFix(numberUtil.nice(span / splitNumber, true), Math.max(getPrecisionSafe(extent[0]), getPrecisionSafe(extent[1])) + 2);\n                var precision = getPrecisionSafe(step) + 2;\n                // Niced extent inside original extent\n                var niceExtent = [\n                        roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                        roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n                    ];\n                this._interval = step;\n                this._niceExtent = niceExtent;\n            },\n            niceExtent: function (splitNumber, fixMin, fixMax) {\n                var extent = this._extent;\n                // If extent start and end are same, expand them\n                if (extent[0] === extent[1]) {\n                    if (extent[0] !== 0) {\n                        // Expand extent\n                        var expandSize = extent[0];\n                        // In the fowllowing case\n                        //      Axis has been fixed max 100\n                        //      Plus data are all 100 and axis extent are [100, 100].\n                        // Extend to the both side will cause expanded max is larger than fixed max.\n                        // So only expand to the smaller side.\n                        if (!fixMax) {\n                            extent[1] += expandSize / 2;\n                            extent[0] -= expandSize / 2;\n                        } else {\n                            extent[0] -= expandSize / 2;\n                        }\n                    } else {\n                        extent[1] = 1;\n                    }\n                }\n                var span = extent[1] - extent[0];\n                // If there are no data and extent are [Infinity, -Infinity]\n                if (!isFinite(span)) {\n                    extent[0] = 0;\n                    extent[1] = 1;\n                }\n                this.niceTicks(splitNumber);\n                // var extent = this._extent;\n                var interval = this._interval;\n                if (!fixMin) {\n                    extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n                }\n                if (!fixMax) {\n                    extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n                }\n            }\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n    return IntervalScale;\n});\ndefine('zrender/core/env', [], function () {\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            canvasSupported: true\n        };\n    } else {\n        env = detect(navigator.userAgent);\n    }\n    return env;\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/);\n        // IE 12 and 12+\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox)\n            browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            canvasSupported: document.createElement('canvas').getContext ? true : false,\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)\n        };\n    }\n});\ndefine('echarts/ExtensionAPI', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var echartsAPIList = [\n            'getDom',\n            'getZr',\n            'getWidth',\n            'getHeight',\n            'dispatchAction',\n            'isDisposed',\n            'on',\n            'off',\n            'getDataURL',\n            'getConnectedDataURL',\n            'getModel',\n            'getOption'\n        ];\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n    return ExtensionAPI;\n});\ndefine('echarts/model/Global', ['require', 'zrender/core/util', '../util/model', './Model', './Component', './globalDefault', './mixin/colorPalette'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n    var ComponentModel = require('./Component');\n    var globalDefault = require('./globalDefault');\n    var OPTION_INNER_KEY = '\u0000_ec_inner';\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n            constructor: GlobalModel,\n            init: function (option, parentModel, theme, optionManager) {\n                theme = theme || {};\n                this.option = null;\n                // Mark as not initialized.\n                /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n                this._theme = new Model(theme);\n                /**\n             * @type {module:echarts/model/OptionManager}\n             */\n                this._optionManager = optionManager;\n            },\n            setOption: function (option, optionPreprocessorFuncs) {\n                zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n                this._optionManager.setOption(option, optionPreprocessorFuncs);\n                this.resetOption();\n            },\n            resetOption: function (type) {\n                var optionChanged = false;\n                var optionManager = this._optionManager;\n                if (!type || type === 'recreate') {\n                    var baseOption = optionManager.mountOption(type === 'recreate');\n                    if (!this.option || type === 'recreate') {\n                        initBase.call(this, baseOption);\n                    } else {\n                        this.restoreData();\n                        this.mergeOption(baseOption);\n                    }\n                    optionChanged = true;\n                }\n                if (type === 'timeline' || type === 'media') {\n                    this.restoreData();\n                }\n                if (!type || type === 'recreate' || type === 'timeline') {\n                    var timelineOption = optionManager.getTimelineOption(this);\n                    timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n                }\n                if (!type || type === 'recreate' || type === 'media') {\n                    var mediaOptions = optionManager.getMediaOption(this, this._api);\n                    if (mediaOptions.length) {\n                        each(mediaOptions, function (mediaOption) {\n                            this.mergeOption(mediaOption, optionChanged = true);\n                        }, this);\n                    }\n                }\n                return optionChanged;\n            },\n            mergeOption: function (newOption) {\n                var option = this.option;\n                var componentsMap = this._componentsMap;\n                var newCptTypes = [];\n                //  component model  merge\n                each(newOption, function (componentOption, mainType) {\n                    if (componentOption == null) {\n                        return;\n                    }\n                    if (!ComponentModel.hasClass(mainType)) {\n                        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n                    } else {\n                        newCptTypes.push(mainType);\n                    }\n                });\n                // FIXME OPTION \n                ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n                this._seriesIndices = this._seriesIndices || [];\n                function visitComponent(mainType, dependencies) {\n                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n                    var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);\n                    makeKeyInfo(mainType, mapResult);\n                    var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n                    option[mainType] = [];\n                    componentsMap[mainType] = [];\n                    each(mapResult, function (resultItem, index) {\n                        var componentModel = resultItem.exist;\n                        var newCptOption = resultItem.option;\n                        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');\n                        // Consider where is no new option and should be merged using {},\n                        // see removeEdgeAndAdd in topologicalTravel and\n                        // ComponentModel.getAllClassMainTypes.\n                        if (!newCptOption) {\n                            componentModel.mergeOption({}, this);\n                            componentModel.optionUpdated({}, false);\n                        } else {\n                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n                            if (componentModel && componentModel instanceof ComponentModelClass) {\n                                componentModel.mergeOption(newCptOption, this);\n                                componentModel.optionUpdated(newCptOption, false);\n                            } else {\n                                // PENDING Global as parent ?\n                                var extraOpt = zrUtil.extend({\n                                        dependentModels: dependentModels,\n                                        componentIndex: index\n                                    }, resultItem.keyInfo);\n                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n                                componentModel.init(newCptOption, this, this, extraOpt);\n                                // Call optionUpdated after init.\n                                // newCptOption has been used as componentModel.option\n                                // and may be merged with theme and default, so pass null\n                                // to avoid confusion.\n                                componentModel.optionUpdated(null, true);\n                            }\n                        }\n                        componentsMap[mainType][index] = componentModel;\n                        option[mainType][index] = componentModel.option;\n                    }, this);\n                    // Backup series for filtering.\n                    if (mainType === 'series') {\n                        this._seriesIndices = createSeriesIndices(componentsMap.series);\n                    }\n                }\n            },\n            getOption: function () {\n                var option = zrUtil.clone(this.option);\n                each(option, function (opts, mainType) {\n                    if (ComponentModel.hasClass(mainType)) {\n                        var opts = modelUtil.normalizeToArray(opts);\n                        for (var i = opts.length - 1; i >= 0; i--) {\n                            // Remove options with inner id.\n                            if (modelUtil.isIdInner(opts[i])) {\n                                opts.splice(i, 1);\n                            }\n                        }\n                        option[mainType] = opts;\n                    }\n                });\n                delete option[OPTION_INNER_KEY];\n                return option;\n            },\n            getTheme: function () {\n                return this._theme;\n            },\n            getComponent: function (mainType, idx) {\n                var list = this._componentsMap[mainType];\n                if (list) {\n                    return list[idx || 0];\n                }\n            },\n            queryComponents: function (condition) {\n                var mainType = condition.mainType;\n                if (!mainType) {\n                    return [];\n                }\n                var index = condition.index;\n                var id = condition.id;\n                var name = condition.name;\n                var cpts = this._componentsMap[mainType];\n                if (!cpts || !cpts.length) {\n                    return [];\n                }\n                var result;\n                if (index != null) {\n                    if (!isArray(index)) {\n                        index = [index];\n                    }\n                    result = filter(map(index, function (idx) {\n                        return cpts[idx];\n                    }), function (val) {\n                        return !!val;\n                    });\n                } else if (id != null) {\n                    var isIdArray = isArray(id);\n                    result = filter(cpts, function (cpt) {\n                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n                    });\n                } else if (name != null) {\n                    var isNameArray = isArray(name);\n                    result = filter(cpts, function (cpt) {\n                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n                    });\n                } else {\n                    // Return all components with mainType\n                    result = cpts;\n                }\n                return filterBySubType(result, condition);\n            },\n            findComponents: function (condition) {\n                var query = condition.query;\n                var mainType = condition.mainType;\n                var queryCond = getQueryCond(query);\n                var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];\n                return doFilter(filterBySubType(result, condition));\n                function getQueryCond(q) {\n                    var indexAttr = mainType + 'Index';\n                    var idAttr = mainType + 'Id';\n                    var nameAttr = mainType + 'Name';\n                    return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {\n                        mainType: mainType,\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    } : null;\n                }\n                function doFilter(res) {\n                    return condition.filter ? filter(res, condition.filter) : res;\n                }\n            },\n            eachComponent: function (mainType, cb, context) {\n                var componentsMap = this._componentsMap;\n                if (typeof mainType === 'function') {\n                    context = cb;\n                    cb = mainType;\n                    each(componentsMap, function (components, componentType) {\n                        each(components, function (component, index) {\n                            cb.call(context, componentType, component, index);\n                        });\n                    });\n                } else if (zrUtil.isString(mainType)) {\n                    each(componentsMap[mainType], cb, context);\n                } else if (isObject(mainType)) {\n                    var queryResult = this.findComponents(mainType);\n                    each(queryResult, cb, context);\n                }\n            },\n            getSeriesByName: function (name) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.name === name;\n                });\n            },\n            getSeriesByIndex: function (seriesIndex) {\n                return this._componentsMap.series[seriesIndex];\n            },\n            getSeriesByType: function (subType) {\n                var series = this._componentsMap.series;\n                return filter(series, function (oneSeries) {\n                    return oneSeries.subType === subType;\n                });\n            },\n            getSeries: function () {\n                return this._componentsMap.series.slice();\n            },\n            eachSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    cb.call(context, series, rawSeriesIndex);\n                }, this);\n            },\n            eachRawSeries: function (cb, context) {\n                each(this._componentsMap.series, cb, context);\n            },\n            eachSeriesByType: function (subType, cb, context) {\n                assertSeriesInitialized(this);\n                each(this._seriesIndices, function (rawSeriesIndex) {\n                    var series = this._componentsMap.series[rawSeriesIndex];\n                    if (series.subType === subType) {\n                        cb.call(context, series, rawSeriesIndex);\n                    }\n                }, this);\n            },\n            eachRawSeriesByType: function (subType, cb, context) {\n                return each(this.getSeriesByType(subType), cb, context);\n            },\n            isSeriesFiltered: function (seriesModel) {\n                assertSeriesInitialized(this);\n                return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n            },\n            filterSeries: function (cb, context) {\n                assertSeriesInitialized(this);\n                var filteredSeries = filter(this._componentsMap.series, cb, context);\n                this._seriesIndices = createSeriesIndices(filteredSeries);\n            },\n            restoreData: function () {\n                var componentsMap = this._componentsMap;\n                this._seriesIndices = createSeriesIndices(componentsMap.series);\n                var componentTypes = [];\n                each(componentsMap, function (components, componentType) {\n                    componentTypes.push(componentType);\n                });\n                ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                });\n            }\n        });\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        for (var name in theme) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof theme[name] === 'object') {\n                    option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);\n                } else {\n                    if (option[name] == null) {\n                        option[name] = theme[name];\n                    }\n                }\n            }\n        }\n    }\n    function initBase(baseOption) {\n        baseOption = baseOption;\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n        mergeTheme(baseOption, this._theme.option);\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n        this.mergeOption(baseOption);\n    }\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n        return ret;\n    }\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n        // Ensure that each id is distinct.\n        var idMap = {};\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n            zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));\n            opt && opt.id != null && (idMap[opt.id] = item);\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {\n                    mainType: mainType,\n                    subType: subType\n                };\n            }\n        });\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n            if (!isObject(opt)) {\n                return;\n            }\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\u0000-';\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            } else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            } else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\u0000' + keyInfo.name + '\u0000' + idNum++;\n                } while (idMap[keyInfo.id]);\n            }\n            idMap[keyInfo.id] = item;\n        });\n    }\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n            return cpt.subType === condition.subType;\n        }) : components;\n    }\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (true) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n    return GlobalModel;\n});\ndefine('echarts/model/OptionManager', ['require', 'zrender/core/util', '../util/model', './Component'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n    var QUERY_REG = /^(min|max)?(.+)$/;\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n    OptionManager.prototype = {\n        constructor: OptionManager,\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n            // FIXME\n            //  timeline options  media baseOption\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n            this._newBaseOption = newParsedOption.baseOption;\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            } else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n            // TODO\n            // resetclone\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n            return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n        },\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n                }\n            }\n            return option;\n        },\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n                });\n            }\n            // Otherwise return nothing.\n            this._currentMediaIndices = indices;\n            return result;\n        }\n    };\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    } else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n        // Preprocess.\n        each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n            return media.option;\n        })), function (option) {\n            each(optionPreprocessorFuncs, function (preProcess) {\n                preProcess(option, isNew);\n            });\n        });\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n                width: ecWidth,\n                height: ecHeight,\n                aspectratio: ecWidth / ecHeight\n            };\n        var applicatable = true;\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n        return applicatable;\n    }\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        } else if (operator === 'max') {\n            return real <= expect;\n        } else {\n            // Equals\n            return real === expect;\n        }\n    }\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n            var oldCptOpt = oldOption[mainType];\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            } else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n                });\n            }\n        });\n    }\n    return OptionManager;\n});\ndefine('echarts/CoordinateSystem', ['require'], function (require) {\n    'use strict';\n    var coordinateSystemCreators = {};\n    function CoordinateSystemManager() {\n        this._coordinateSystems = [];\n    }\n    CoordinateSystemManager.prototype = {\n        constructor: CoordinateSystemManager,\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            for (var type in coordinateSystemCreators) {\n                var list = coordinateSystemCreators[type].create(ecModel, api);\n                list && (coordinateSystems = coordinateSystems.concat(list));\n            }\n            this._coordinateSystems = coordinateSystems;\n        },\n        update: function (ecModel, api) {\n            var coordinateSystems = this._coordinateSystems;\n            for (var i = 0; i < coordinateSystems.length; i++) {\n                // FIXME MUST have\n                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);\n            }\n        }\n    };\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n    return CoordinateSystemManager;\n});\ndefine('echarts/model/Series', ['require', 'zrender/core/util', '../util/format', '../util/model', './Component', './mixin/colorPalette', 'zrender/core/env'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/core/env');\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n    var SeriesModel = ComponentModel.extend({\n            type: 'series.__base__',\n            seriesIndex: 0,\n            coordinateSystem: null,\n            defaultOption: null,\n            legendDataProvider: null,\n            visualColorAccessPath: 'itemStyle.normal.color',\n            init: function (option, parentModel, ecModel, extraOpt) {\n                /**\n             * @type {number}\n             * @readOnly\n             */\n                this.seriesIndex = this.componentIndex;\n                this.mergeDefaultAndTheme(option, ecModel);\n                /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n                this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n                // If we reverse the order (make this._data firstly, and then make\n                // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n                // cause this._data.graph.data !== this._data when using\n                // module:echarts/data/Graph or module:echarts/data/Tree.\n                // See module:echarts/data/helper/linkList\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n                zrUtil.merge(option, this.getDefaultOption());\n                // Default label emphasis `position` and `show`\n                // FIXME Set label in mergeOption\n                modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n                this.fillDataTextStyle(option.data);\n            },\n            mergeOption: function (newSeriesOption, ecModel) {\n                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n                this.fillDataTextStyle(newSeriesOption.data);\n                var data = this.getInitialData(newSeriesOption, ecModel);\n                // TODO Merge data?\n                if (data) {\n                    this._data = data;\n                    this._dataBeforeProcessed = data.cloneShallow();\n                }\n            },\n            fillDataTextStyle: function (data) {\n                // Default data label emphasis `position` and `show`\n                // FIXME Tree structure data ?\n                // FIXME Performance ?\n                if (data) {\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] && data[i].label) {\n                            modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                        }\n                    }\n                }\n            },\n            getInitialData: function () {\n            },\n            getData: function (dataType) {\n                return dataType == null ? this._data : this._data.getLinkedData(dataType);\n            },\n            setData: function (data) {\n                this._data = data;\n            },\n            getRawData: function () {\n                return this._dataBeforeProcessed;\n            },\n            coordDimToDataDim: function (coordDim) {\n                return [coordDim];\n            },\n            dataDimToCoordDim: function (dataDim) {\n                return dataDim;\n            },\n            getBaseAxis: function () {\n                var coordSys = this.coordinateSystem;\n                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n            },\n            formatTooltip: function (dataIndex, multipleSeries, dataType) {\n                function formatArrayValue(value) {\n                    return zrUtil.map(value, function (val, idx) {\n                        var dimInfo = data.getDimensionInfo(idx);\n                        var dimType = dimInfo && dimInfo.type;\n                        if (dimType === 'ordinal') {\n                            return val;\n                        } else if (dimType === 'time') {\n                            return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                        } else {\n                            return addCommas(val);\n                        }\n                    }).filter(function (val) {\n                        return !!val;\n                    }).join(', ');\n                }\n                var data = this._data;\n                var value = this.getRawValue(dataIndex);\n                var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value);\n                var name = data.getName(dataIndex);\n                var color = data.getItemVisual(dataIndex, 'color');\n                var colorEl = '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n                var seriesName = this.name;\n                // FIXME\n                if (seriesName === '\u0000-') {\n                    // Not show '-'\n                    seriesName = '';\n                }\n                return !multipleSeries ? (seriesName && encodeHTML(seriesName) + '<br />') + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;\n            },\n            ifEnableAnimation: function () {\n                if (env.node) {\n                    return false;\n                }\n                var animationEnabled = this.getShallow('animation');\n                if (animationEnabled) {\n                    if (this.getData().count() > this.getShallow('animationThreshold')) {\n                        animationEnabled = false;\n                    }\n                }\n                return animationEnabled;\n            },\n            restoreData: function () {\n                this._data = this._dataBeforeProcessed.cloneShallow();\n            },\n            getColorFromPalette: function (name, scope) {\n                var ecModel = this.ecModel;\n                // PENDING\n                var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n                if (!color) {\n                    color = ecModel.getColorFromPalette(name, scope);\n                }\n                return color;\n            },\n            getAxisTooltipDataIndex: null\n        });\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n    return SeriesModel;\n});\ndefine('echarts/model/Component', ['require', './Model', 'zrender/core/util', '../util/component', '../util/clazz', '../util/layout', './mixin/boxLayout'], function (require) {\n    var Model = require('./Model');\n    var zrUtil = require('zrender/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n            type: 'component',\n            id: '',\n            name: '',\n            mainType: '',\n            subType: '',\n            componentIndex: 0,\n            defaultOption: null,\n            ecModel: null,\n            dependentModels: [],\n            uid: null,\n            layoutMode: null,\n            $constructor: function (option, parentModel, ecModel, extraOpt) {\n                Model.call(this, option, parentModel, ecModel, extraOpt);\n                // Set dependentModels, componentIndex, name, id, mainType, subType.\n                zrUtil.extend(this, extraOpt);\n                this.uid = componentUtil.getUID('componentModel');\n            },\n            init: function (option, parentModel, ecModel, extraOpt) {\n                this.mergeDefaultAndTheme(option, ecModel);\n            },\n            mergeDefaultAndTheme: function (option, ecModel) {\n                var layoutMode = this.layoutMode;\n                var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                var themeModel = ecModel.getTheme();\n                zrUtil.merge(option, themeModel.get(this.mainType));\n                zrUtil.merge(option, this.getDefaultOption());\n                if (layoutMode) {\n                    layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                }\n            },\n            mergeOption: function (option) {\n                zrUtil.merge(this.option, option, true);\n                var layoutMode = this.layoutMode;\n                if (layoutMode) {\n                    layout.mergeLayoutParam(this.option, option, layoutMode);\n                }\n            },\n            optionUpdated: function (newCptOption, isInit) {\n            },\n            getDefaultOption: function () {\n                if (!this.hasOwnProperty('__defaultOption')) {\n                    var optList = [];\n                    var Class = this.constructor;\n                    while (Class) {\n                        var opt = Class.prototype.defaultOption;\n                        opt && optList.push(opt);\n                        Class = Class.superClass;\n                    }\n                    var defaultOption = {};\n                    for (var i = optList.length - 1; i >= 0; i--) {\n                        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                    }\n                    this.__defaultOption = defaultOption;\n                }\n                return this.__defaultOption;\n            }\n        });\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n    //         this.uid = componentUtil.getUID('componentModel');\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n    return ComponentModel;\n});\ndefine('echarts/view/Component', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n    Component.prototype = {\n        constructor: Component,\n        init: function (ecModel, api) {\n        },\n        render: function (componentModel, ecModel, api, payload) {\n        },\n        dispose: function () {\n        }\n    };\n    var componentProto = Component.prototype;\n    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n    };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });\n    return Component;\n});\ndefine('echarts/view/Chart', ['require', 'zrender/container/Group', '../util/component', '../util/clazz'], function (require) {\n    var Group = require('zrender/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    function Chart() {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n    Chart.prototype = {\n        type: 'chart',\n        init: function (ecModel, api) {\n        },\n        render: function (seriesModel, ecModel, api, payload) {\n        },\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n        dispose: function () {\n        }\n    };\n    var chartProto = Chart.prototype;\n    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n    };\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = payload && payload.dataIndex;\n        var name = payload && payload.name;\n        if (dataIndex != null) {\n            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];\n            for (var i = 0, len = dataIndices.length; i < len; i++) {\n                elSetState(data.getItemGraphicEl(dataIndices[i]), state);\n            }\n        } else if (name) {\n            var names = name instanceof Array ? name : [name];\n            for (var i = 0, len = names.length; i < len; i++) {\n                var dataIndex = data.indexOfName(names[i]);\n                elSetState(data.getItemGraphicEl(dataIndex), state);\n            }\n        } else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart);\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });\n    return Chart;\n});\ndefine('zrender/zrender', ['require', './core/guid', './core/env', './Handler', './Storage', './animation/Animation', './dom/HandlerProxy', './Painter'], function (require) {\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n    var useVML = !env.canvasSupported;\n    var painterCtors = { canvas: require('./Painter') };\n    var instances = {};\n    // ZRendermap\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        } else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n        return zrender;\n    };\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n    function delInstance(id) {\n        delete instances[id];\n    }\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function (id, dom, opts) {\n        opts = opts || {};\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n        /**\n         * @type {string}\n         */\n        this.id = id;\n        var self = this;\n        var storage = new Storage();\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        } else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n        this.storage = storage;\n        this.painter = painter;\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n            oldDelFromMap.call(storage, elId);\n            el && el.removeSelfFromZr(self);\n        };\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n            el.addSelfToZr(self);\n        };\n    };\n    ZRender.prototype = {\n        constructor: ZRender,\n        getId: function () {\n            return this.id;\n        },\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n        refresh: function () {\n            this._needsRefresh = true;\n        },\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n        resize: function () {\n            this.painter.resize();\n            this.handler.resize();\n        },\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n        getWidth: function () {\n            return this.painter.getWidth();\n        },\n        getHeight: function () {\n            return this.painter.getHeight();\n        },\n        pathToImage: function (e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n        on: function (eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n        off: function (eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n        dispose: function () {\n            this.animation.stop();\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n            this.animation = this.storage = this.painter = this.handler = null;\n            delInstance(this.id);\n        }\n    };\n    return zrender;\n});\ndefine('zrender/mixin/Eventful', ['require'], function (require) {\n    var arrySlice = Array.prototype.slice;\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n    Eventful.prototype = {\n        constructor: Eventful,\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n            return this;\n        },\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n            if (!handler || !event) {\n                return this;\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n            return this;\n        },\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n        off: function (event, handler) {\n            var _h = this._$handlers;\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            } else {\n                delete _h[event];\n            }\n            return this;\n        },\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(_h[i]['ctx']);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        },\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(ctx);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(ctx, args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(ctx, args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(ctx, args);\n                        break;\n                    }\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            return this;\n        }\n    };\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n    return Eventful;\n});\ndefine('zrender/tool/color', ['require'], function (require) {\n    var kCSSColorTable = {\n            'transparent': [\n                0,\n                0,\n                0,\n                0\n            ],\n            'aliceblue': [\n                240,\n                248,\n                255,\n                1\n            ],\n            'antiquewhite': [\n                250,\n                235,\n                215,\n                1\n            ],\n            'aqua': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'aquamarine': [\n                127,\n                255,\n                212,\n                1\n            ],\n            'azure': [\n                240,\n                255,\n                255,\n                1\n            ],\n            'beige': [\n                245,\n                245,\n                220,\n                1\n            ],\n            'bisque': [\n                255,\n                228,\n                196,\n                1\n            ],\n            'black': [\n                0,\n                0,\n                0,\n                1\n            ],\n            'blanchedalmond': [\n                255,\n                235,\n                205,\n                1\n            ],\n            'blue': [\n                0,\n                0,\n                255,\n                1\n            ],\n            'blueviolet': [\n                138,\n                43,\n                226,\n                1\n            ],\n            'brown': [\n                165,\n                42,\n                42,\n                1\n            ],\n            'burlywood': [\n                222,\n                184,\n                135,\n                1\n            ],\n            'cadetblue': [\n                95,\n                158,\n                160,\n                1\n            ],\n            'chartreuse': [\n                127,\n                255,\n                0,\n                1\n            ],\n            'chocolate': [\n                210,\n                105,\n                30,\n                1\n            ],\n            'coral': [\n                255,\n                127,\n                80,\n                1\n            ],\n            'cornflowerblue': [\n                100,\n                149,\n                237,\n                1\n            ],\n            'cornsilk': [\n                255,\n                248,\n                220,\n                1\n            ],\n            'crimson': [\n                220,\n                20,\n                60,\n                1\n            ],\n            'cyan': [\n                0,\n                255,\n                255,\n                1\n            ],\n            'darkblue': [\n                0,\n                0,\n                139,\n                1\n            ],\n            'darkcyan': [\n                0,\n                139,\n                139,\n                1\n            ],\n            'darkgoldenrod': [\n                184,\n                134,\n                11,\n                1\n            ],\n            'darkgray': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkgreen': [\n                0,\n                100,\n                0,\n                1\n            ],\n            'darkgrey': [\n                169,\n                169,\n                169,\n                1\n            ],\n            'darkkhaki': [\n                189,\n                183,\n                107,\n                1\n            ],\n            'darkmagenta': [\n                139,\n                0,\n                139,\n                1\n            ],\n            'darkolivegreen': [\n                85,\n                107,\n                47,\n                1\n            ],\n            'darkorange': [\n                255,\n                140,\n                0,\n                1\n            ],\n            'darkorchid': [\n                153,\n                50,\n                204,\n                1\n            ],\n            'darkred': [\n                139,\n                0,\n                0,\n                1\n            ],\n            'darksalmon': [\n                233,\n                150,\n                122,\n                1\n            ],\n            'darkseagreen': [\n                143,\n                188,\n                143,\n                1\n            ],\n            'darkslateblue': [\n                72,\n                61,\n                139,\n                1\n            ],\n            'darkslategray': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkslategrey': [\n                47,\n                79,\n                79,\n                1\n            ],\n            'darkturquoise': [\n                0,\n                206,\n                209,\n                1\n            ],\n            'darkviolet': [\n                148,\n                0,\n                211,\n                1\n            ],\n            'deeppink': [\n                255,\n                20,\n                147,\n                1\n            ],\n            'deepskyblue': [\n                0,\n                191,\n                255,\n                1\n            ],\n            'dimgray': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dimgrey': [\n                105,\n                105,\n                105,\n                1\n            ],\n            'dodgerblue': [\n                30,\n                144,\n                255,\n                1\n            ],\n            'firebrick': [\n                178,\n                34,\n                34,\n                1\n            ],\n            'floralwhite': [\n                255,\n                250,\n                240,\n                1\n            ],\n            'forestgreen': [\n                34,\n                139,\n                34,\n                1\n            ],\n            'fuchsia': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'gainsboro': [\n                220,\n                220,\n                220,\n                1\n            ],\n            'ghostwhite': [\n                248,\n                248,\n                255,\n                1\n            ],\n            'gold': [\n                255,\n                215,\n                0,\n                1\n            ],\n            'goldenrod': [\n                218,\n                165,\n                32,\n                1\n            ],\n            'gray': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'green': [\n                0,\n                128,\n                0,\n                1\n            ],\n            'greenyellow': [\n                173,\n                255,\n                47,\n                1\n            ],\n            'grey': [\n                128,\n                128,\n                128,\n                1\n            ],\n            'honeydew': [\n                240,\n                255,\n                240,\n                1\n            ],\n            'hotpink': [\n                255,\n                105,\n                180,\n                1\n            ],\n            'indianred': [\n                205,\n                92,\n                92,\n                1\n            ],\n            'indigo': [\n                75,\n                0,\n                130,\n                1\n            ],\n            'ivory': [\n                255,\n                255,\n                240,\n                1\n            ],\n            'khaki': [\n                240,\n                230,\n                140,\n                1\n            ],\n            'lavender': [\n                230,\n                230,\n                250,\n                1\n            ],\n            'lavenderblush': [\n                255,\n                240,\n                245,\n                1\n            ],\n            'lawngreen': [\n                124,\n                252,\n                0,\n                1\n            ],\n            'lemonchiffon': [\n                255,\n                250,\n                205,\n                1\n            ],\n            'lightblue': [\n                173,\n                216,\n                230,\n                1\n            ],\n            'lightcoral': [\n                240,\n                128,\n                128,\n                1\n            ],\n            'lightcyan': [\n                224,\n                255,\n                255,\n                1\n            ],\n            'lightgoldenrodyellow': [\n                250,\n                250,\n                210,\n                1\n            ],\n            'lightgray': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightgreen': [\n                144,\n                238,\n                144,\n                1\n            ],\n            'lightgrey': [\n                211,\n                211,\n                211,\n                1\n            ],\n            'lightpink': [\n                255,\n                182,\n                193,\n                1\n            ],\n            'lightsalmon': [\n                255,\n                160,\n                122,\n                1\n            ],\n            'lightseagreen': [\n                32,\n                178,\n                170,\n                1\n            ],\n            'lightskyblue': [\n                135,\n                206,\n                250,\n                1\n            ],\n            'lightslategray': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightslategrey': [\n                119,\n                136,\n                153,\n                1\n            ],\n            'lightsteelblue': [\n                176,\n                196,\n                222,\n                1\n            ],\n            'lightyellow': [\n                255,\n                255,\n                224,\n                1\n            ],\n            'lime': [\n                0,\n                255,\n                0,\n                1\n            ],\n            'limegreen': [\n                50,\n                205,\n                50,\n                1\n            ],\n            'linen': [\n                250,\n                240,\n                230,\n                1\n            ],\n            'magenta': [\n                255,\n                0,\n                255,\n                1\n            ],\n            'maroon': [\n                128,\n                0,\n                0,\n                1\n            ],\n            'mediumaquamarine': [\n                102,\n                205,\n                170,\n                1\n            ],\n            'mediumblue': [\n                0,\n                0,\n                205,\n                1\n            ],\n            'mediumorchid': [\n                186,\n                85,\n                211,\n                1\n            ],\n            'mediumpurple': [\n                147,\n                112,\n                219,\n                1\n            ],\n            'mediumseagreen': [\n                60,\n                179,\n                113,\n                1\n            ],\n            'mediumslateblue': [\n                123,\n                104,\n                238,\n                1\n            ],\n            'mediumspringgreen': [\n                0,\n                250,\n                154,\n                1\n            ],\n            'mediumturquoise': [\n                72,\n                209,\n                204,\n                1\n            ],\n            'mediumvioletred': [\n                199,\n                21,\n                133,\n                1\n            ],\n            'midnightblue': [\n                25,\n                25,\n                112,\n                1\n            ],\n            'mintcream': [\n                245,\n                255,\n                250,\n                1\n            ],\n            'mistyrose': [\n                255,\n                228,\n                225,\n                1\n            ],\n            'moccasin': [\n                255,\n                228,\n                181,\n                1\n            ],\n            'navajowhite': [\n                255,\n                222,\n                173,\n                1\n            ],\n            'navy': [\n                0,\n                0,\n                128,\n                1\n            ],\n            'oldlace': [\n                253,\n                245,\n                230,\n                1\n            ],\n            'olive': [\n                128,\n                128,\n                0,\n                1\n            ],\n            'olivedrab': [\n                107,\n                142,\n                35,\n                1\n            ],\n            'orange': [\n                255,\n                165,\n                0,\n                1\n            ],\n            'orangered': [\n                255,\n                69,\n                0,\n                1\n            ],\n            'orchid': [\n                218,\n                112,\n                214,\n                1\n            ],\n            'palegoldenrod': [\n                238,\n                232,\n                170,\n                1\n            ],\n            'palegreen': [\n                152,\n                251,\n                152,\n                1\n            ],\n            'paleturquoise': [\n                175,\n                238,\n                238,\n                1\n            ],\n            'palevioletred': [\n                219,\n                112,\n                147,\n                1\n            ],\n            'papayawhip': [\n                255,\n                239,\n                213,\n                1\n            ],\n            'peachpuff': [\n                255,\n                218,\n                185,\n                1\n            ],\n            'peru': [\n                205,\n                133,\n                63,\n                1\n            ],\n            'pink': [\n                255,\n                192,\n                203,\n                1\n            ],\n            'plum': [\n                221,\n                160,\n                221,\n                1\n            ],\n            'powderblue': [\n                176,\n                224,\n                230,\n                1\n            ],\n            'purple': [\n                128,\n                0,\n                128,\n                1\n            ],\n            'red': [\n                255,\n                0,\n                0,\n                1\n            ],\n            'rosybrown': [\n                188,\n                143,\n                143,\n                1\n            ],\n            'royalblue': [\n                65,\n                105,\n                225,\n                1\n            ],\n            'saddlebrown': [\n                139,\n                69,\n                19,\n                1\n            ],\n            'salmon': [\n                250,\n                128,\n                114,\n                1\n            ],\n            'sandybrown': [\n                244,\n                164,\n                96,\n                1\n            ],\n            'seagreen': [\n                46,\n                139,\n                87,\n                1\n            ],\n            'seashell': [\n                255,\n                245,\n                238,\n                1\n            ],\n            'sienna': [\n                160,\n                82,\n                45,\n                1\n            ],\n            'silver': [\n                192,\n                192,\n                192,\n                1\n            ],\n            'skyblue': [\n                135,\n                206,\n                235,\n                1\n            ],\n            'slateblue': [\n                106,\n                90,\n                205,\n                1\n            ],\n            'slategray': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'slategrey': [\n                112,\n                128,\n                144,\n                1\n            ],\n            'snow': [\n                255,\n                250,\n                250,\n                1\n            ],\n            'springgreen': [\n                0,\n                255,\n                127,\n                1\n            ],\n            'steelblue': [\n                70,\n                130,\n                180,\n                1\n            ],\n            'tan': [\n                210,\n                180,\n                140,\n                1\n            ],\n            'teal': [\n                0,\n                128,\n                128,\n                1\n            ],\n            'thistle': [\n                216,\n                191,\n                216,\n                1\n            ],\n            'tomato': [\n                255,\n                99,\n                71,\n                1\n            ],\n            'turquoise': [\n                64,\n                224,\n                208,\n                1\n            ],\n            'violet': [\n                238,\n                130,\n                238,\n                1\n            ],\n            'wheat': [\n                245,\n                222,\n                179,\n                1\n            ],\n            'white': [\n                255,\n                255,\n                255,\n                1\n            ],\n            'whitesmoke': [\n                245,\n                245,\n                245,\n                1\n            ],\n            'yellow': [\n                255,\n                255,\n                0,\n                1\n            ],\n            'yellowgreen': [\n                154,\n                205,\n                50,\n                1\n            ]\n        };\n    function clampCssByte(i) {\n        // Clamp to integer 0 .. 255.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n    function clampCssAngle(i) {\n        // Clamp to integer 0 .. 360.\n        i = Math.round(i);\n        // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n    function clampCssFloat(f) {\n        // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n    function parseCssInt(str) {\n        // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n    function parseCssFloat(str) {\n        // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        } else if (h > 1) {\n            h -= 1;\n        }\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n        }\n        return m1;\n    }\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();    // dup.\n        }\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 4095)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 3840) >> 4 | (iv & 3840) >> 8,\n                    iv & 240 | (iv & 240) >> 4,\n                    iv & 15 | (iv & 15) << 4,\n                    1\n                ];\n            } else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);\n                // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 16777215)) {\n                    return;    // Covers NaN.\n                }\n                return [\n                    (iv & 16711680) >> 16,\n                    (iv & 65280) >> 8,\n                    iv & 255,\n                    1\n                ];\n            }\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;\n            // To allow case fallthrough.\n            switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    return;\n                }\n                alpha = parseCssFloat(params.pop());\n            // jshint ignore:line\n            // Fall through.\n            case 'rgb':\n                if (params.length !== 3) {\n                    return;\n                }\n                return [\n                    parseCssInt(params[0]),\n                    parseCssInt(params[1]),\n                    parseCssInt(params[2]),\n                    alpha\n                ];\n            case 'hsla':\n                if (params.length !== 4) {\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                return hsla2rgba(params);\n            case 'hsl':\n                if (params.length !== 3) {\n                    return;\n                }\n                return hsla2rgba(params);\n            default:\n                return;\n            }\n        }\n        return;\n    }\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;\n        // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        var rgba = [\n                clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n                clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n            ];\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n        return rgba;\n    }\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n        var vMin = Math.min(R, G, B);\n        // Min. value of RGB\n        var vMax = Math.max(R, G, B);\n        // Max. value of RGB\n        var delta = vMax - vMin;\n        // Delta RGB value\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        } else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            } else {\n                S = delta / (2 - vMax - vMin);\n            }\n            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            } else if (G === vMax) {\n                H = 1 / 3 + deltaR - deltaB;\n            } else if (B === vMax) {\n                H = 2 / 3 + deltaG - deltaR;\n            }\n            if (H < 0) {\n                H += 1;\n            }\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n        var hsla = [\n                H * 360,\n                S,\n                L\n            ];\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n        return hsla;\n    }\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                } else {\n                    colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n        }\n    }\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        out = out || [\n            0,\n            0,\n            0,\n            0\n        ];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n        var color = stringify([\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ], 'rgba');\n        return fullOutput ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        } : color;\n    }\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n    return {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n});\ndefine('zrender/core/timsort', [], function () {\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    function minRunLength(n) {\n        var r = 0;\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n        return n + r;\n    }\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (runHi === hi) {\n            return 1;\n        }\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n            reverseRun(array, lo, runHi);\n        } else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n        return runHi - lo;\n    }\n    function reverseRun(array, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n        for (; start < hi; start++) {\n            var pivot = array[start];\n            var left = lo;\n            var right = start;\n            var mid;\n            while (left < right) {\n                mid = left + right >>> 1;\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            var n = start - left;\n            switch (n) {\n            case 3:\n                array[left + 3] = array[left + 2];\n            case 2:\n                array[left + 2] = array[left + 1];\n            case 1:\n                array[left + 1] = array[left];\n                break;\n            default:\n                while (n > 0) {\n                    array[left + n] = array[left + n - 1];\n                    n--;\n                }\n            }\n            array[left] = pivot;\n        }\n    }\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        } else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            } else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        } else {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            } else {\n                lastOffset = m + 1;\n            }\n        }\n        return offset;\n    }\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n        length = array.length;\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n        var tmp = [];\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n        runStart = [];\n        runLength = [];\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                } else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n                mergeAt(n);\n            }\n        }\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n            runLength[i] = length1 + length2;\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n            stackSize--;\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n            if (length1 === 0) {\n                return;\n            }\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n            if (length2 === 0) {\n                return;\n            }\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            } else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n            array[dest++] = array[cursor2++];\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = array[cursor2++];\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            minGallop < 1 && (minGallop = 1);\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            } else if (length1 === 0) {\n                throw new Error();    // throw new Error('mergeLow preconditions were not respected');\n            } else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n        function mergeHigh(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n            array[dest--] = array[cursor1--];\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n                return;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n                return;\n            }\n            var _minGallop = minGallop;\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    } else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = tmp[cursor2--];\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = array[cursor1--];\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n            } else if (length2 === 0) {\n                throw new Error();    // throw new Error('mergeHigh preconditions were not respected');\n            } else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n        var remaining = hi - lo;\n        if (remaining < 2) {\n            return;\n        }\n        var runLength = 0;\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n        var ts = new TimSort(array, compare);\n        var minRun = minRunLength(remaining);\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n        ts.forceMergeRuns();\n    }\n    return sort;\n});\ndefine('echarts/visual/seriesColor', ['require', 'zrender/graphic/Gradient'], function (require) {\n    var Gradient = require('zrender/graphic/Gradient');\n    return function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));\n            // Default color\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n                    });\n                }\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n});\ndefine('echarts/preprocessor/backwardCompat', ['require', 'zrender/core/util', './helper/compatStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var compatStyle = require('./helper/compatStyle');\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n    var LAYOUT_PROPERTIES = [\n            [\n                'x',\n                'left'\n            ],\n            [\n                'y',\n                'top'\n            ],\n            [\n                'x2',\n                'right'\n            ],\n            [\n                'y2',\n                'bottom'\n            ]\n        ];\n    var COMPATITABLE_COMPONENTS = [\n            'grid',\n            'geo',\n            'parallel',\n            'legend',\n            'toolbox',\n            'title',\n            'visualMap',\n            'dataZoom',\n            'timeline'\n        ];\n    var COMPATITABLE_SERIES = [\n            'bar',\n            'boxplot',\n            'candlestick',\n            'chord',\n            'effectScatter',\n            'funnel',\n            'gauge',\n            'lines',\n            'graph',\n            'heatmap',\n            'line',\n            'map',\n            'parallel',\n            'pie',\n            'radar',\n            'sankey',\n            'scatter',\n            'treemap'\n        ];\n    var each = zrUtil.each;\n    return function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n            var seriesType = seriesOpt.type;\n            compatStyle(seriesOpt);\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n});\ndefine('echarts/loading/default', ['require', '../util/graphic', 'zrender/core/util'], function (require) {\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    return function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n                style: { fill: opts.maskColor },\n                zlevel: opts.zlevel,\n                z: 10000\n            });\n        var arc = new graphic.Arc({\n                shape: {\n                    startAngle: -PI / 2,\n                    endAngle: -PI / 2 + 0.1,\n                    r: 10\n                },\n                style: {\n                    stroke: opts.color,\n                    lineCap: 'round',\n                    lineWidth: 5\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        var labelRect = new graphic.Rect({\n                style: {\n                    fill: 'none',\n                    text: opts.text,\n                    textPosition: 'right',\n                    textDistance: 10,\n                    textFill: opts.textColor\n                },\n                zlevel: opts.zlevel,\n                z: 10001\n            });\n        arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');\n        arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n});\ndefine('zrender/core/matrix', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n            create: function () {\n                var out = new ArrayCtor(6);\n                matrix.identity(out);\n                return out;\n            },\n            identity: function (out) {\n                out[0] = 1;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n                out[4] = 0;\n                out[5] = 0;\n                return out;\n            },\n            copy: function (out, m) {\n                out[0] = m[0];\n                out[1] = m[1];\n                out[2] = m[2];\n                out[3] = m[3];\n                out[4] = m[4];\n                out[5] = m[5];\n                return out;\n            },\n            mul: function (out, m1, m2) {\n                // Consider matrix.mul(m, m2, m);\n                // where out is the same as m2.\n                // So use temp variable to escape error.\n                var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n                var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n                var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n                var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n                var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n                var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n                out[0] = out0;\n                out[1] = out1;\n                out[2] = out2;\n                out[3] = out3;\n                out[4] = out4;\n                out[5] = out5;\n                return out;\n            },\n            translate: function (out, a, v) {\n                out[0] = a[0];\n                out[1] = a[1];\n                out[2] = a[2];\n                out[3] = a[3];\n                out[4] = a[4] + v[0];\n                out[5] = a[5] + v[1];\n                return out;\n            },\n            rotate: function (out, a, rad) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var st = Math.sin(rad);\n                var ct = Math.cos(rad);\n                out[0] = aa * ct + ab * st;\n                out[1] = -aa * st + ab * ct;\n                out[2] = ac * ct + ad * st;\n                out[3] = -ac * st + ct * ad;\n                out[4] = ct * atx + st * aty;\n                out[5] = ct * aty - st * atx;\n                return out;\n            },\n            scale: function (out, a, v) {\n                var vx = v[0];\n                var vy = v[1];\n                out[0] = a[0] * vx;\n                out[1] = a[1] * vy;\n                out[2] = a[2] * vx;\n                out[3] = a[3] * vy;\n                out[4] = a[4] * vx;\n                out[5] = a[5] * vy;\n                return out;\n            },\n            invert: function (out, a) {\n                var aa = a[0];\n                var ac = a[2];\n                var atx = a[4];\n                var ab = a[1];\n                var ad = a[3];\n                var aty = a[5];\n                var det = aa * ad - ab * ac;\n                if (!det) {\n                    return null;\n                }\n                det = 1 / det;\n                out[0] = ad * det;\n                out[1] = -ab * det;\n                out[2] = -ac * det;\n                out[3] = aa * det;\n                out[4] = (ac * aty - ad * atx) * det;\n                out[5] = (ab * atx - aa * aty) * det;\n                return out;\n            }\n        };\n    return matrix;\n});\ndefine('echarts/model/Model', ['require', 'zrender/core/util', '../util/clazz', './mixin/lineStyle', './mixin/areaStyle', './mixin/textStyle', './mixin/itemStyle'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazzUtil = require('../util/clazz');\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;    // Simple optimization\n                                 // if (this.init) {\n                                 //     if (arguments.length <= 4) {\n                                 //         this.init(option, parentModel, ecModel, extraOpt);\n                                 //     }\n                                 //     else {\n                                 //         this.init.apply(this, arguments);\n                                 //     }\n                                 // }\n    }\n    Model.prototype = {\n        constructor: Model,\n        init: null,\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = obj && typeof obj === 'object' ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);\n            return model;\n        },\n        isEmpty: function () {\n            return this.option == null;\n        },\n        restoreData: function () {\n        },\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n    return Model;\n});\ndefine('echarts/data/List', ['require', '../model/Model', './DataDiffer', 'zrender/core/util', '../util/model'], function (require) {\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;\n    var dataCtors = {\n            'float': Float64Array,\n            'int': Int32Array,\n            'ordinal': Array,\n            'number': Array,\n            'time': Array\n        };\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n    var TRANSFERABLE_PROPERTIES = [\n            'stackedOn',\n            'hasItemOption',\n            '_nameList',\n            '_idList',\n            '_rawData'\n        ];\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n        dimensions = dimensions || [\n            'x',\n            'y'\n        ];\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    type: 'number'\n                };\n            } else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n    var listProto = List.prototype;\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        this._rawData = data;\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n        var idList = [];\n        var nameRepeatCount = {};\n        nameList = nameList || [];\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);\n        };\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n            indices.push(idx);\n        }\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n        return values;\n    };\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = dimInfo && dimInfo.stackable && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return this._extent[dim + !!stack] = [\n                min,\n                max\n            ];\n        } else {\n            return [\n                Infinity,\n                -Infinity\n            ];\n        }\n    };\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            } else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (diff <= maxDistance && (dist < minDist || dist === minDist && diff > 0)) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n    };\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n            case 0:\n                cb.call(context, i);\n                break;\n            case 1:\n                cb.call(context, this.get(dims[0], i, stack), i);\n                break;\n            case 2:\n                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                break;\n            default:\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dims[k], i, stack);\n                }\n                // Index\n                value[k] = i;\n                cb.apply(context, value);\n            }\n        }\n    };\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n        context = context || this;\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n            } else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n        this.indices = newIndices;\n        // Reset data extent\n        this._extent = {};\n        return this;\n    };\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n            } else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n        var storage = list._storage;\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n        return list;\n    };\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n        return list;\n    };\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n            return otherIdList[idx] || idx + '';\n        }, function (idx) {\n            return idList[idx] || idx + '';\n        });\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n    };\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n        this._graphicEls[idx] = el;\n    };\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n        // FIXME\n        list._storage = this._storage;\n        transferProperties(list, this);\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n        return list;\n    };\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = [\n        'cloneShallow',\n        'downSample',\n        'map'\n    ];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n    return List;\n});\ndefine('zrender/core/vector', [], function () {\n    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n            create: function (x, y) {\n                var out = new ArrayCtor(2);\n                if (x == null) {\n                    x = 0;\n                }\n                if (y == null) {\n                    y = 0;\n                }\n                out[0] = x;\n                out[1] = y;\n                return out;\n            },\n            copy: function (out, v) {\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            clone: function (v) {\n                var out = new ArrayCtor(2);\n                out[0] = v[0];\n                out[1] = v[1];\n                return out;\n            },\n            set: function (out, a, b) {\n                out[0] = a;\n                out[1] = b;\n                return out;\n            },\n            add: function (out, v1, v2) {\n                out[0] = v1[0] + v2[0];\n                out[1] = v1[1] + v2[1];\n                return out;\n            },\n            scaleAndAdd: function (out, v1, v2, a) {\n                out[0] = v1[0] + v2[0] * a;\n                out[1] = v1[1] + v2[1] * a;\n                return out;\n            },\n            sub: function (out, v1, v2) {\n                out[0] = v1[0] - v2[0];\n                out[1] = v1[1] - v2[1];\n                return out;\n            },\n            len: function (v) {\n                return Math.sqrt(this.lenSquare(v));\n            },\n            lenSquare: function (v) {\n                return v[0] * v[0] + v[1] * v[1];\n            },\n            mul: function (out, v1, v2) {\n                out[0] = v1[0] * v2[0];\n                out[1] = v1[1] * v2[1];\n                return out;\n            },\n            div: function (out, v1, v2) {\n                out[0] = v1[0] / v2[0];\n                out[1] = v1[1] / v2[1];\n                return out;\n            },\n            dot: function (v1, v2) {\n                return v1[0] * v2[0] + v1[1] * v2[1];\n            },\n            scale: function (out, v, s) {\n                out[0] = v[0] * s;\n                out[1] = v[1] * s;\n                return out;\n            },\n            normalize: function (out, v) {\n                var d = vector.len(v);\n                if (d === 0) {\n                    out[0] = 0;\n                    out[1] = 0;\n                } else {\n                    out[0] = v[0] / d;\n                    out[1] = v[1] / d;\n                }\n                return out;\n            },\n            distance: function (v1, v2) {\n                return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n            },\n            distanceSquare: function (v1, v2) {\n                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n            },\n            negate: function (out, v) {\n                out[0] = -v[0];\n                out[1] = -v[1];\n                return out;\n            },\n            lerp: function (out, v1, v2, t) {\n                out[0] = v1[0] + t * (v2[0] - v1[0]);\n                out[1] = v1[1] + t * (v2[1] - v1[1]);\n                return out;\n            },\n            applyTransform: function (out, v, m) {\n                var x = v[0];\n                var y = v[1];\n                out[0] = m[0] * x + m[2] * y + m[4];\n                out[1] = m[1] * x + m[3] * y + m[5];\n                return out;\n            },\n            min: function (out, v1, v2) {\n                out[0] = Math.min(v1[0], v2[0]);\n                out[1] = Math.min(v1[1], v2[1]);\n                return out;\n            },\n            max: function (out, v1, v2) {\n                out[0] = Math.max(v1[0], v2[0]);\n                out[1] = Math.max(v1[1], v2[1]);\n                return out;\n            }\n        };\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n    return vector;\n});\ndefine('echarts/scale/Scale', ['require', '../util/clazz'], function (require) {\n    var clazzUtil = require('../util/clazz');\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [\n            Infinity,\n            -Infinity\n        ];\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n        this.init && this.init.apply(this, arguments);\n    }\n    var scaleProto = Scale.prototype;\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);    // not setExtent because in log axis it may transformed to power\n                                                           // this.setExtent(extent[0], extent[1]);\n    };\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });\n    return Scale;\n});\ndefine('echarts/coord/axisHelper', ['require', '../scale/Ordinal', '../scale/Interval', '../scale/Time', '../scale/Log', '../scale/Scale', '../util/number', 'zrender/core/util', 'zrender/contain/text'], function (require) {\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/core/util');\n    var textContain = require('zrender/contain/text');\n    var axisHelper = {};\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [\n                    0,\n                    0\n                ];\n            } else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [\n                boundaryGap || 0,\n                boundaryGap || 0\n            ];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [\n            min,\n            max\n        ];\n    };\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);\n            scale.niceExtent(splitNumber);\n        }\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function (model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n            // Buildin scale\n            case 'category':\n                return new OrdinalScale(model.getCategories(), [\n                    Infinity,\n                    -Infinity\n                ]);\n            case 'value':\n                return new IntervalScale();\n            // Extended scale, like time and log\n            default:\n                return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !(min > 0 && max > 0 || min < 0 && max < 0);\n    };\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }    // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            } else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            }(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        } else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);\n            }, this);\n        } else {\n            return labels;\n        }\n    };\n    return axisHelper;\n});\ndefine('echarts/coord/cartesian/Cartesian2D', ['require', 'zrender/core/util', './Cartesian'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var Cartesian = require('./Cartesian');\n    function Cartesian2D(name) {\n        Cartesian.call(this, name);\n    }\n    Cartesian2D.prototype = {\n        constructor: Cartesian2D,\n        type: 'cartesian2d',\n        dimensions: [\n            'x',\n            'y'\n        ],\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n        },\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n        },\n        dataToPoints: function (data, stack) {\n            return data.mapArray([\n                'x',\n                'y'\n            ], function (x, y) {\n                return this.dataToPoint([\n                    x,\n                    y\n                ]);\n            }, stack, this);\n        },\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n    zrUtil.inherits(Cartesian2D, Cartesian);\n    return Cartesian2D;\n});\ndefine('echarts/coord/cartesian/Axis2D', ['require', 'zrender/core/util', '../Axis', './axisLabelInterval'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n    Axis2D.prototype = {\n        constructor: Axis2D,\n        index: 0,\n        onZero: false,\n        model: null,\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n            }\n        },\n        toLocalCoord: null,\n        toGlobalCoord: null\n    };\n    zrUtil.inherits(Axis2D, Axis);\n    return Axis2D;\n});\ndefine('echarts/coord/cartesian/GridModel', ['require', './AxisModel', '../../model/Component'], function (require) {\n    'use strict';\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n    return ComponentModel.extend({\n        type: 'grid',\n        dependencies: [\n            'xAxis',\n            'yAxis'\n        ],\n        layoutMode: 'box',\n        coordinateSystem: null,\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            containLabel: false,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n});\ndefine('zrender/tool/path', ['require', '../graphic/Path', '../core/PathProxy', './transformPath', '../core/matrix'], function (require) {\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n    // command chars\n    var cc = [\n            'm',\n            'M',\n            'l',\n            'L',\n            'v',\n            'V',\n            'h',\n            'H',\n            'z',\n            'Z',\n            'c',\n            'C',\n            'q',\n            'Q',\n            't',\n            'T',\n            's',\n            'S',\n            'a',\n            'A'\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n    var vMag = function (v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function (u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function (u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n    };\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180);\n        var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;\n        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n        var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n        var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n        var theta = vAngle([\n                1,\n                0\n            ], [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ]);\n        var u = [\n                (xp - cxp) / rx,\n                (yp - cyp) / ry\n            ];\n        var v = [\n                (-1 * xp - cxp) / rx,\n                (-1 * yp - cyp) / ry\n            ];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n        // command string\n        var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n                var x1 = cpx;\n                var y1 = cpy;\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                }\n            }\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n            prevCmd = cmd;\n        }\n        path.toStatic();\n        return path;\n    }\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n        return opts;\n    }\n    return {\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n            return pathBundle;\n        }\n    };\n});\ndefine('zrender/graphic/Path', ['require', './Displayable', '../core/util', '../core/PathProxy', '../contain/path', './Pattern'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n    var abs = Math.abs;\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n    Path.prototype = {\n        constructor: Path,\n        type: 'path',\n        __dirtyPath: true,\n        strokeContainThreshold: 5,\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!fill.colorStops;\n            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n            var hasFillPattern = hasFill && !!fill.image;\n            var hasStrokePattern = hasStroke && !!stroke.image;\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            } else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            } else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n            var ctxLineDash = !!ctx.setLineDash;\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n                path = this.path.beginPath(ctx);\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n                this.buildPath(path, this.shape, false);\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            } else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n            hasFill && path.fill(ctx);\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            hasStroke && path.stroke(ctx);\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n            this.restoreTransform(ctx);\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n        buildPath: function (ctx, shapeCfg, inBundle) {\n        },\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n            return rect;\n        },\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            } else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                } else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n        }\n    };\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n            defaults.init && defaults.init.call(this, opts);\n        };\n        zrUtil.inherits(Sub, Path);\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n        return Sub;\n    };\n    zrUtil.inherits(Path, Displayable);\n    return Path;\n});\ndefine('zrender/graphic/Gradient', ['require'], function (require) {\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n        this.colorStops = colorStops || [];\n    };\n    Gradient.prototype = {\n        constructor: Gradient,\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n                offset: offset,\n                color: color\n            });\n        }\n    };\n    return Gradient;\n});\ndefine('zrender/container/Group', ['require', '../core/util', '../Element', '../core/BoundingRect'], function (require) {\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n        this._children = [];\n        this.__storage = null;\n        this.__dirty = true;\n    };\n    Group.prototype = {\n        constructor: Group,\n        isGroup: true,\n        type: 'group',\n        silent: false,\n        children: function () {\n            return this._children.slice();\n        },\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n            }\n        },\n        childCount: function () {\n            return this._children.length;\n        },\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n                this._children.push(child);\n                this._doAdd(child);\n            }\n            return this;\n        },\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n            return this;\n        },\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n            child.parent = this;\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n        },\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n            child.parent = null;\n            if (storage) {\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n            zr && zr.refresh();\n            return this;\n        },\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n            return this;\n        },\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                } else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n    zrUtil.inherits(Group, Element);\n    return Group;\n});\ndefine('zrender/graphic/Text', ['require', './Displayable', '../core/util', '../contain/text'], function (require) {\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n    Text.prototype = {\n        constructor: Text,\n        type: 'text',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n            if (text) {\n                this.setTransform(ctx);\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(text, font, style.textAlign, 'top');\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                    case 'middle':\n                        y -= rect.height / 2 - rect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= rect.height - rect.lineHeight / 2;\n                        break;\n                    default:\n                        y += rect.lineHeight / 2;\n                    }\n                } else {\n                    textBaseline = style.textBaseline;\n                }\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n                var lineHeight = textContain.measureText('', ctx.font).width;\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n                this.restoreTransform(ctx);\n            }\n        },\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);\n                switch (textVerticalAlign) {\n                case 'middle':\n                    rect.y -= rect.height / 2;\n                    break;\n                case 'bottom':\n                    rect.y -= rect.height;\n                    break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(Text, Displayable);\n    return Text;\n});\ndefine('zrender/graphic/Image', ['require', './Displayable', '../core/BoundingRect', '../core/util', '../core/LRU'], function (require) {\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n    ZImage.prototype = {\n        constructor: ZImage,\n        type: 'image',\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }    // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                } else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                // transform\n                this.setTransform(ctx);\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n                } else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n                } else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n                this.restoreTransform(ctx);\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n            }\n        },\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n            }\n            return this._rect;\n        }\n    };\n    zrUtil.inherits(ZImage, Displayable);\n    return ZImage;\n});\ndefine('zrender/graphic/shape/Circle', ['require', '../Path'], function (require) {\n    'use strict';\n    return require('../Path').extend({\n        type: 'circle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n        buildPath: function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Ring', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'ring',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Sector', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'sector',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r0: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n            ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n            ctx.closePath();\n        }\n    });\n});\ndefine('zrender/graphic/shape/Rect', ['require', '../helper/roundRect', '../Path'], function (require) {\n    var roundRectHelper = require('../helper/roundRect');\n    return require('../Path').extend({\n        type: 'rect',\n        shape: {\n            r: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            } else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polygon', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polygon',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Polyline', ['require', '../helper/poly', '../Path'], function (require) {\n    var polyHelper = require('../helper/poly');\n    return require('../Path').extend({\n        type: 'polyline',\n        shape: {\n            points: null,\n            smooth: false,\n            smoothConstraint: null\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Line', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'line',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n});\ndefine('zrender/graphic/shape/BezierCurve', ['require', '../../core/curve', '../../core/vector', '../Path'], function (require) {\n    'use strict';\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n    var out = [];\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        } else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    return require('../Path').extend({\n        type: 'bezier-curve',\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            percent: 1\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n            } else {\n                if (percent < 1) {\n                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n            }\n        },\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n});\ndefine('zrender/graphic/shape/Arc', ['require', '../Path'], function (require) {\n    return require('../Path').extend({\n        type: 'arc',\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            startAngle: 0,\n            endAngle: Math.PI * 2,\n            clockwise: true\n        },\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n});\ndefine('zrender/graphic/RadialGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n        this.y = y == null ? 0.5 : y;\n        this.r = r == null ? 0.5 : r;\n        // Can be cloned\n        this.type = 'radial';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    RadialGradient.prototype = { constructor: RadialGradient };\n    zrUtil.inherits(RadialGradient, Gradient);\n    return RadialGradient;\n});\ndefine('zrender/graphic/LinearGradient', ['require', '../core/util', './Gradient'], function (require) {\n    'use strict';\n    var zrUtil = require('../core/util');\n    var Gradient = require('./Gradient');\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.x2 = x2 == null ? 1 : x2;\n        this.y2 = y2 == null ? 0 : y2;\n        // Can be cloned\n        this.type = 'linear';\n        // If use global coord\n        this.global = globalCoord || false;\n        Gradient.call(this, colorStops);\n    };\n    LinearGradient.prototype = { constructor: LinearGradient };\n    zrUtil.inherits(LinearGradient, Gradient);\n    return LinearGradient;\n});\ndefine('zrender/graphic/CompoundPath', ['require', './Path'], function (require) {\n    var Path = require('./Path');\n    return Path.extend({\n        type: 'compound',\n        shape: { paths: null },\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n});\ndefine('zrender/core/BoundingRect', ['require', './vector', './matrix'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n    BoundingRect.prototype = {\n        constructor: BoundingRect,\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n            this.x = x;\n            this.y = y;\n        },\n        applyTransform: function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        }(),\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n            var m = matrix.create();\n            // \n            matrix.translate(m, m, [\n                -a.x,\n                -a.y\n            ]);\n            matrix.scale(m, m, [\n                sx,\n                sy\n            ]);\n            matrix.translate(m, m, [\n                b.x,\n                b.y\n            ]);\n            return m;\n        },\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n            return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n        },\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n    return BoundingRect;\n});\ndefine('zrender/contain/text', ['require', '../core/util', '../core/BoundingRect'], function (require) {\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n        return width;\n    }\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n        switch (textBaseline) {\n        case 'bottom':\n        case 'alphabetic':\n            rect.y -= lineHeight;\n            break;\n        case 'middle':\n            rect.y -= lineHeight / 2;\n            break;    // case 'hanging':\n                      // case 'top':\n        }\n        // FIXME Right to left language\n        switch (textAlign) {\n        case 'end':\n        case 'right':\n            rect.x -= rect.width;\n            break;\n        case 'center':\n            rect.x -= rect.width / 2;\n            break;    // case 'start':\n                      // case 'left':\n        }\n        return rect;\n    }\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n        var x = rect.x;\n        var y = rect.y;\n        var height = rect.height;\n        var width = rect.width;\n        var textHeight = textRect.height;\n        var halfHeight = height / 2 - textHeight / 2;\n        var textAlign = 'left';\n        switch (textPosition) {\n        case 'left':\n            x -= distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'right':\n            x += distance + width;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'top':\n            x += width / 2;\n            y -= distance + textHeight;\n            textAlign = 'center';\n            break;\n        case 'bottom':\n            x += width / 2;\n            y += height + distance;\n            textAlign = 'center';\n            break;\n        case 'inside':\n            x += width / 2;\n            y += halfHeight;\n            textAlign = 'center';\n            break;\n        case 'insideLeft':\n            x += distance;\n            y += halfHeight;\n            textAlign = 'left';\n            break;\n        case 'insideRight':\n            x += width - distance;\n            y += halfHeight;\n            textAlign = 'right';\n            break;\n        case 'insideTop':\n            x += width / 2;\n            y += distance;\n            textAlign = 'center';\n            break;\n        case 'insideBottom':\n            x += width / 2;\n            y += height - textHeight - distance;\n            textAlign = 'center';\n            break;\n        case 'insideTopLeft':\n            x += distance;\n            y += distance;\n            textAlign = 'left';\n            break;\n        case 'insideTopRight':\n            x += width - distance;\n            y += distance;\n            textAlign = 'right';\n            break;\n        case 'insideBottomLeft':\n            x += distance;\n            y += height - textHeight - distance;\n            break;\n        case 'insideBottomRight':\n            x += width - distance;\n            y += height - textHeight - distance;\n            textAlign = 'right';\n            break;\n        }\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n        options = options || {};\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n        // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n        contentWidth = containerWidth - ellipsisWidth;\n        var textLines = (text + '').split('\\n');\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n                var subLength = j === 0 ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n            textLines[i] = textLine;\n        }\n        return textLines.join('\\n');\n    }\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n    var textContain = {\n            getWidth: getTextWidth,\n            getBoundingRect: getTextRect,\n            adjustTextPositionOnRect: adjustTextPositionOnRect,\n            truncateText: truncateText,\n            measureText: function (text, textFont) {\n                var ctx = util.getContext();\n                ctx.font = textFont || '12px sans-serif';\n                return ctx.measureText(text);\n            }\n        };\n    return textContain;\n});\ndefine('echarts/util/model', ['require', './format', './number', '../model/Model', 'zrender/core/util'], function (require) {\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = {};\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array ? value : value == null ? [] : [value];\n    };\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n    modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n    modelUtil.LABEL_OPTIONS = [\n        'position',\n        'show',\n        'textStyle',\n        'distance',\n        'formatter'\n    ];\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem) && !(dataItem instanceof Array);    // // markLine data can be array\n                                                                             // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return value == null || value === '' ? NaN : +value;    // If string (like '-'), using '+' parse to NaN\n    };\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n                $vars: [\n                    'seriesName',\n                    'name',\n                    'value'\n                ]\n            };\n        },\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && params.value instanceof Array) {\n                params.value = params.value[dimIndex];\n            }\n            var formatter = itemModel.get([\n                    'label',\n                    status,\n                    'formatter'\n                ]);\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            } else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return zrUtil.isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n            }\n        },\n        formatTooltip: zrUtil.noop\n    };\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n        var result = zrUtil.map(exists || [], function (obj, index) {\n                return { exist: obj };\n            });\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '') {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n            if (i >= result.length) {\n                result.push({ option: cptOption });\n            }\n        });\n        return result;\n    };\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\u0000_ec_\u0000') === 0;\n    };\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n        return [\n            mapToArray(mapA),\n            mapToArray(mapB)\n        ];\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    } else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    } else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({\n                            seriesId: i,\n                            dataIndex: dataIndices\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n    };\n    return modelUtil;\n});\ndefine('echarts/model/globalDefault', [], function () {\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    return {\n        color: [\n            '#c23531',\n            '#2f4554',\n            '#61a0a8',\n            '#d48265',\n            '#91c7ae',\n            '#749f83',\n            '#ca8622',\n            '#bda29a',\n            '#6e7074',\n            '#546570',\n            '#c4ccd3'\n        ],\n        textStyle: {\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n        blendMode: null,\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n        animationThreshold: 2000,\n        progressiveThreshold: 3000,\n        progressive: 400,\n        hoverLayerThreshold: 3000\n    };\n});\ndefine('echarts/model/mixin/colorPalette', [], function () {\n    return {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n            return color;\n        }\n    };\n});\ndefine('zrender/core/PathProxy', ['require', './curve', './vector', './bbox', './BoundingRect', '../config'], function (require) {\n    'use strict';\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n    var CMD = {\n            M: 1,\n            L: 2,\n            C: 3,\n            Q: 4,\n            A: 5,\n            Z: 6,\n            R: 7\n        };\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n    var hasTypedArray = typeof Float32Array != 'undefined';\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n        this._len = 0;\n        this._ctx = null;\n        this._xi = 0;\n        this._yi = 0;\n        this._x0 = 0;\n        this._y0 = 0;\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n        constructor: PathProxy,\n        _lineDash: null,\n        _dashOffset: 0,\n        _dashIdx: 0,\n        _dashSum: 0,\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n        getContext: function () {\n            return this._ctx;\n        },\n        beginPath: function (ctx) {\n            this._ctx = ctx;\n            ctx && ctx.beginPath();\n            ctx && (this.dpr = ctx.dpr);\n            // Reset\n            this._len = 0;\n            if (this._lineDash) {\n                this._lineDash = null;\n                this._dashOffset = 0;\n            }\n            return this;\n        },\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n            this._xi = x;\n            this._yi = y;\n            return this;\n        },\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n            this.addData(CMD.L, x, y);\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n            return this;\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n        closePath: function () {\n            this.addData(CMD.Z);\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n                this._dashIdx = 0;\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n        len: function () {\n            return this._len;\n        },\n        setData: function (data) {\n            var len = data.length;\n            if (!(this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n            this._len = len;\n        },\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && this.data instanceof Float32Array) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n            this._prevCmd = cmd;\n        },\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n        _needsDash: function () {\n            return this._lineDash;\n        },\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n            while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n            var x;\n            var y;\n            var tmpLen = 0;\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n            while (t <= 1) {\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n                t += lineDash[idx] / bezierLen;\n                idx = (idx + 1) % nDash;\n            }\n            // Finish the last segment and calculate the new offset\n            idx % 2 !== 0 && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    // Use fromLine\n                    bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n                }\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n            return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n        },\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L:\n                    x = d[i++];\n                    y = d[i++];\n                    // Not draw too small seg between\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                case CMD.C:\n                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.Q:\n                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var theta = d[i++];\n                    var dTheta = d[i++];\n                    var psi = d[i++];\n                    var fs = d[i++];\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    var isEllipse = Math.abs(rx - ry) > 0.001;\n                    var endAngle = theta + dTheta;\n                    if (isEllipse) {\n                        ctx.translate(cx, cy);\n                        ctx.rotate(psi);\n                        ctx.scale(scaleX, scaleY);\n                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                        ctx.scale(1 / scaleX, 1 / scaleY);\n                        ctx.rotate(-psi);\n                        ctx.translate(-cx, -cy);\n                    } else {\n                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                    }\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos(theta) * rx + cx;\n                        y0 = mathSin(theta) * ry + cy;\n                    }\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                    break;\n                case CMD.Z:\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n                }\n            }\n        }\n    };\n    PathProxy.CMD = CMD;\n    return PathProxy;\n});\ndefine('zrender/tool/transformPath', ['require', '../core/PathProxy', '../core/vector'], function (require) {\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var points = [\n            [],\n            [],\n            []\n        ];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n            switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                // cx\n                data[i++] += x;\n                // cy\n                data[i++] += y;\n                // Scale rx and ry\n                // FIXME Assume psi is 0 here\n                data[i++] *= sx;\n                data[i++] *= sy;\n                // Start angle\n                data[i++] += angle;\n                // end angle\n                data[i++] += angle;\n                // FIXME psi\n                i += 2;\n                j = i;\n                break;\n            case R:\n                // x0, y0\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                // x1, y1\n                p[0] += data[i++];\n                p[1] += data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n    return transformPath;\n});\ndefine('echarts/util/clazz', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = {};\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n            var ret = {\n                    main: '',\n                    sub: ''\n                };\n            if (componentType) {\n                componentType = componentType.split(TYPE_DELIMITER);\n                ret.main = componentType[0] || '';\n                ret.sub = componentType[1] || '';\n            }\n            return ret;\n        };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass) {\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                } else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n            zrUtil.extend(ExtendedClass.prototype, proto);\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n            return ExtendedClass;\n        };\n    };\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n                if (!componentType.sub) {\n                    if (true) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                } else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');\n            }\n            return Clazz;\n        };\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n            var result = [];\n            var obj = storage[componentType.main];\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            } else {\n                result.push(obj);\n            }\n            return result;\n        };\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n        entity.parseClassType = parseClassType;\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n        return entity;\n    };\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n    };\n    return clazz;\n});\ndefine('zrender/graphic/Displayable', ['require', '../core/util', './Style', '../Element', './mixin/RectText'], function (require) {\n    var zrUtil = require('../core/util');\n    var Style = require('./Style');\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n        opts = opts || {};\n        Element.call(this, opts);\n        // Extend properties\n        for (var name in opts) {\n            if (opts.hasOwnProperty(name) && name !== 'style') {\n                this[name] = opts[name];\n            }\n        }\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];    // FIXME Stateful must be mixined after style is setted\n                                  // Stateful.call(this, opts);\n    }\n    Displayable.prototype = {\n        constructor: Displayable,\n        type: 'displayable',\n        __dirty: true,\n        invisible: false,\n        z: 0,\n        z2: 0,\n        zlevel: 0,\n        draggable: false,\n        dragging: false,\n        silent: false,\n        culling: false,\n        cursor: 'pointer',\n        rectHover: false,\n        progressive: -1,\n        beforeBrush: function (ctx) {\n        },\n        afterBrush: function (ctx) {\n        },\n        brush: function (ctx, prevEl) {\n        },\n        getBoundingRect: function () {\n        },\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n        dirty: function () {\n            this.__dirty = true;\n            this._rect = null;\n            this.__zr && this.__zr.refresh();\n        },\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            } else {\n                this.style.set(value);\n            }\n        },\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n    zrUtil.inherits(Displayable, Element);\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n    return Displayable;\n});\ndefine('zrender/contain/path', ['require', '../core/PathProxy', './line', './cubic', './quadratic', './arc', './util', '../core/curve', './windingLine'], function (require) {\n    'use strict';\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n    var windingLine = require('./windingLine');\n    var containStroke = line.containStroke;\n    var PI2 = Math.PI * 2;\n    var EPSILON = 0.0001;\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n    // \n    var roots = [\n            -1,\n            -1,\n            -1\n        ];\n    var extrema = [\n            -1,\n            -1\n        ];\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = t === 0 || t === 1 ? 0.5 : 1;\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) {\n                    // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    } else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                } else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    } else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        } else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {\n                        // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    } else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            } else {\n                // Remove one endpoint.\n                var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {\n                    // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n    // TODO\n    // Arc \n    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 0.0001) {\n            return 0;\n        }\n        if (diff % PI2 < 0.0001) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        } else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }    //  subpath \n                     // if (w !== 0) {\n                     //     return true;\n                     // }\n            }\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n            case CMD.M:\n                // moveTo  subpath, \n                //  closePath \n                x0 = data[i++];\n                y0 = data[i++];\n                xi = x0;\n                yi = y0;\n                break;\n            case CMD.L:\n                if (isStroke) {\n                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // NOTE  L, C, Q  NaN\n                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.C:\n                if (isStroke) {\n                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.Q:\n                if (isStroke) {\n                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD.A:\n                // TODO Arc \n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                // TODO Arc \n                var psi = data[i++];\n                var anticlockwise = 1 - data[i++];\n                var x1 = Math.cos(theta) * rx + cx;\n                var y1 = Math.sin(theta) * ry + cy;\n                //  arc \n                if (i > 1) {\n                    w += windingLine(xi, yi, x1, y1, x, y);\n                } else {\n                    // \n                    x0 = x1;\n                    y0 = y1;\n                }\n                // zr scale, x\n                var _x = (x - cx) * ry / rx + cx;\n                if (isStroke) {\n                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n                        return true;\n                    }\n                } else {\n                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n                }\n                xi = Math.cos(theta + dTheta) * rx + cx;\n                yi = Math.sin(theta + dTheta) * ry + cy;\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                var width = data[i++];\n                var height = data[i++];\n                var x1 = x0 + width;\n                var y1 = y0 + height;\n                if (isStroke) {\n                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // FIXME Clockwise ?\n                    w += windingLine(x1, y0, x1, y1, x, y);\n                    w += windingLine(x0, y1, x0, y0, x, y);\n                }\n                break;\n            case CMD.Z:\n                if (isStroke) {\n                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n                        return true;\n                    }\n                } else {\n                    // Close a subpath\n                    w += windingLine(xi, yi, x0, y0, x, y);    //  subpath \n                                                               // FIXME subpaths may overlap\n                                                               // if (w !== 0) {\n                                                               //     return true;\n                                                               // }\n                }\n                xi = x0;\n                yi = y0;\n                break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n    return {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n});\ndefine('echarts/model/mixin/lineStyle', ['require', './makeStyleMapper'], function (require) {\n    var getLineStyle = require('./makeStyleMapper')([\n            [\n                'lineWidth',\n                'width'\n            ],\n            [\n                'stroke',\n                'color'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getLineDash: function () {\n            var lineType = this.get('type');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                2,\n                2\n            ];\n        }\n    };\n});\ndefine('echarts/scale/Ordinal', ['require', 'zrender/core/util', './Scale'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var Scale = require('./Scale');\n    var scaleProto = Scale.prototype;\n    var OrdinalScale = Scale.extend({\n            type: 'ordinal',\n            init: function (data, extent) {\n                this._data = data;\n                this._extent = extent || [\n                    0,\n                    data.length - 1\n                ];\n            },\n            parse: function (val) {\n                return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);\n            },\n            contain: function (rank) {\n                rank = this.parse(rank);\n                return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n            },\n            normalize: function (val) {\n                return scaleProto.normalize.call(this, this.parse(val));\n            },\n            scale: function (val) {\n                return Math.round(scaleProto.scale.call(this, val));\n            },\n            getTicks: function () {\n                var ticks = [];\n                var extent = this._extent;\n                var rank = extent[0];\n                while (rank <= extent[1]) {\n                    ticks.push(rank);\n                    rank++;\n                }\n                return ticks;\n            },\n            getLabel: function (n) {\n                return this._data[n];\n            },\n            count: function () {\n                return this._extent[1] - this._extent[0] + 1;\n            },\n            niceTicks: zrUtil.noop,\n            niceExtent: zrUtil.noop\n        });\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n    return OrdinalScale;\n});\ndefine('zrender/graphic/Pattern', ['require'], function (require) {\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n        // Can be cloned\n        this.type = 'pattern';\n    };\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return this._canvasPattern || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n    return Pattern;\n});\ndefine('echarts/model/mixin/areaStyle', ['require', './makeStyleMapper'], function (require) {\n    return {\n        getAreaStyle: require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['opacity'],\n            ['shadowColor']\n        ])\n    };\n});\ndefine('echarts/model/mixin/textStyle', ['require', 'zrender/contain/text'], function (require) {\n    var textContain = require('zrender/contain/text');\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n    return {\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');\n        },\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);\n        },\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(text, containerWidth, this.getFont(), ellipsis, options);\n        }\n    };\n});\ndefine('echarts/model/mixin/itemStyle', ['require', './makeStyleMapper'], function (require) {\n    var getItemStyle = require('./makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [\n                5,\n                5\n            ] : [\n                1,\n                1\n            ];\n        }\n    };\n});\ndefine('zrender/graphic/Style', ['require'], function (require) {\n    var STYLE_COMMON_PROPS = [\n            [\n                'shadowBlur',\n                0\n            ],\n            [\n                'shadowOffsetX',\n                0\n            ],\n            [\n                'shadowOffsetY',\n                0\n            ],\n            [\n                'shadowColor',\n                '#000'\n            ],\n            [\n                'lineCap',\n                'butt'\n            ],\n            [\n                'lineJoin',\n                'miter'\n            ],\n            [\n                'miterLimit',\n                10\n            ]\n        ];\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n        return canvasGradient;\n    }\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n        return canvasGradient;\n    }\n    Style.prototype = {\n        constructor: Style,\n        fill: '#000000',\n        stroke: null,\n        opacity: 1,\n        lineDash: null,\n        lineDashOffset: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        lineWidth: 1,\n        strokeNoScale: false,\n        text: null,\n        textFill: '#000',\n        textStroke: null,\n        textPosition: 'inside',\n        textBaseline: null,\n        textAlign: null,\n        textVerticalAlign: null,\n        textDistance: 5,\n        textShadowBlur: 0,\n        textShadowOffsetX: 0,\n        textShadowOffsetY: 0,\n        textTransform: false,\n        textRotation: 0,\n        blend: null,\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n            if (firstDraw || style.fill !== prevStyle.fill) {\n                ctx.fillStyle = style.fill;\n            }\n            if (firstDraw || style.stroke !== prevStyle.stroke) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if (firstDraw || style.opacity !== prevStyle.opacity) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n            if (firstDraw || style.blend !== prevStyle.blend) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n            }\n        },\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            } else {\n                this.extendFrom(obj, true);\n            }\n        },\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n            }\n            return canvasGradient;\n        }\n    };\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n    return Style;\n});\ndefine('zrender/graphic/mixin/RectText', ['require', '../../contain/text', '../../core/BoundingRect'], function (require) {\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n    var tmpRect = new BoundingRect();\n    var RectText = function () {\n    };\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n    RectText.prototype = {\n        constructor: RectText,\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n            // FIXME\n            ctx.save();\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            } else {\n                this.setTransform(ctx);\n            }\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                    case 'middle':\n                        y -= textRect.height / 2 - textRect.lineHeight / 2;\n                        break;\n                    case 'bottom':\n                        y -= textRect.height - textRect.lineHeight / 2;\n                        break;\n                    default:\n                        y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            } else {\n                var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n            var textLines = text.split('\\n');\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n            ctx.restore();\n        }\n    };\n    return RectText;\n});\ndefine('zrender/Element', ['require', './core/guid', './mixin/Eventful', './mixin/Transformable', './mixin/Animatable', './core/util'], function (require) {\n    'use strict';\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n    Element.prototype = {\n        type: 'element',\n        name: '',\n        __zr: null,\n        ignore: false,\n        clipPath: null,\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n            }\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n            }\n            m[4] += dx;\n            m[5] += dy;\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n        beforeUpdate: function () {\n        },\n        afterUpdate: function () {\n        },\n        update: function () {\n            this.updateTransform();\n        },\n        traverse: function (cb, context) {\n        },\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            } else {\n                this[key] = value;\n            }\n        },\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            } else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n            this.dirty(false);\n            return this;\n        },\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n            this.dirty(false);\n        },\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n                this.dirty(false);\n            }\n        },\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n    return Element;\n});\ndefine('echarts/model/mixin/makeStyleMapper', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n                properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n});\ndefine('echarts/coord/cartesian/Cartesian', ['require', 'zrender/core/util'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n        this._dimList = [];\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n    Cartesian.prototype = {\n        constructor: Cartesian,\n        type: 'cartesian',\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(this.getAxes(), function (axis) {\n                return axis.scale.type === scaleType;\n            });\n        },\n        addAxis: function (axis) {\n            var dim = axis.dim;\n            this._axes[dim] = axis;\n            this._dimList.push(dim);\n        },\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n            var output = input instanceof Array ? [] : {};\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n                output[dim] = axis[method](input[dim]);\n            }\n            return output;\n        }\n    };\n    return Cartesian;\n});\ndefine('zrender/core/guid', [], function () {\n    var idStart = 2311;\n    return function () {\n        return idStart++;\n    };\n});\ndefine('zrender/mixin/Transformable', ['require', '../core/matrix', '../core/vector'], function (require) {\n    'use strict';\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n    var EPSILON = 0.00005;\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [\n                0,\n                0\n            ];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [\n                1,\n                1\n            ];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n    };\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n        m = m || matrix.create();\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        } else {\n            mIdentity(m);\n        }\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            } else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n        var origin = this.origin;\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n        m[4] += position[0];\n        m[5] += position[1];\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        } else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n    var tmpTransform = [];\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [\n                1,\n                1\n            ];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [\n            sx,\n            sy\n        ];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [\n                x,\n                y\n            ];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n    return Transformable;\n});\ndefine('zrender/mixin/Animatable', ['require', '../animation/Animator', '../core/util', '../core/log'], function (require) {\n    'use strict';\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n    Animatable.prototype = {\n        constructor: Animatable,\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            } else {\n                target = el;\n            }\n            if (!target) {\n                log('Property \"' + path + '\" is not existed in element ' + el.id);\n                return;\n            }\n            var animators = el.animators;\n            var animator = new Animator(target, loop);\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            }).done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n            animators.push(animator);\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n            return animator;\n        },\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n            return this;\n        },\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }    // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }    // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }    // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }    // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i].done(done).start(easing);\n            }\n        },\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n                    } else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                } else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    } else {\n                        // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n            if (propertyCount > 0) {\n                this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n            }\n            return this;\n        }\n    };\n    return Animatable;\n});\ndefine('echarts/util/component', ['require', 'zrender/core/util', './clazz'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var clazz = require('./clazz');\n    var parseClassType = clazz.parseClassType;\n    var base = 0;\n    var componentUtil = {};\n    var DELIMITER = '_';\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [\n            type || '',\n            base++,\n            Math.random()\n        ].join(DELIMITER);\n    };\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n        var subTypeDefaulters = {};\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n        return entity;\n    };\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n            }\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n            zrUtil.each(fullNameList, function (name) {\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n            return {\n                graph: graph,\n                noEntryList: noEntryList\n            };\n        }\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {\n                    predecessor: [],\n                    successor: []\n                };\n            }\n            return graph[name];\n        }\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n    return componentUtil;\n});\ndefine('echarts/model/mixin/boxLayout', ['require'], function (require) {\n    return {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n});\ndefine('echarts/coord/Axis', ['require', '../util/number', 'zrender/core/util'], function (require) {\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/core/util');\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n    var normalizedExtent = [\n            0,\n            1\n        ];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [\n            0,\n            0\n        ];\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n    Axis.prototype = {\n        constructor: Axis,\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n        },\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n            return this.scale.scale(t);\n        },\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            } else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n            return Math.abs(size) / len;\n        }\n    };\n    return Axis;\n});\ndefine('echarts/coord/cartesian/axisLabelInterval', ['require', 'zrender/core/util', '../axisHelper'], function (require) {\n    'use strict';\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('../axisHelper');\n    return function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n        return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());\n    };\n});\ndefine('zrender/core/log', ['require', '../config'], function (require) {\n    var config = require('../config');\n    /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n    return function () {\n        if (config.debugMode === 0) {\n            return;\n        } else if (config.debugMode == 1) {\n            for (var k in arguments) {\n                throw new Error(arguments[k]);\n            }\n        } else if (config.debugMode > 1) {\n            for (var k in arguments) {\n                console.log(arguments[k]);\n            }\n        }\n    };    /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n});\ndefine('zrender/animation/Animator', ['require', './Clip', '../tool/color', '../core/util'], function (require) {\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n    var arraySlice = Array.prototype.slice;\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n                }\n            }\n        }\n    }\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            } else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            } else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        } else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n            }\n        } else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n                }\n            }\n        }\n    }\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n            return arraySlice.call(value);\n        }\n        return value;\n    }\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n        // For vertices morphing\n        var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function (a, b) {\n            return a.time - b.time;\n        });\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n            // Check if value is equal, deep check if value is array\n            if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                } else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            } else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n        if (isValueColor) {\n            var rgba = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n        }\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            } else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            } else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n            var range = kfPercents[frame + 1] - kfPercents[frame];\n            if (range === 0) {\n                return;\n            } else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    } else {\n                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n                    }\n                    setter(target, propName, value);\n                }\n            } else {\n                if (isValueArray) {\n                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n                } else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n                        value = rgba2String(rgba);\n                    } else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    } else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(target, propName, value);\n                }\n            }\n        };\n        var clip = new Clip({\n                target: animator._target,\n                life: trackMaxTime,\n                loop: animator._loop,\n                delay: animator._delay,\n                onframe: onframe,\n                ondestroy: oneTrackDone\n            });\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n        return clip;\n    }\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function (target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n        this._loop = loop || false;\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n        this._clipCount = 0;\n        this._delay = 0;\n        this._doneList = [];\n        this._onframeList = [];\n        this._clipList = [];\n    };\n    Animator.prototype = {\n        when: function (time, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        start: function (easing) {\n            var self = this;\n            var clipCount = 0;\n            var oneTrackDone = function () {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n                    lastClip = clip;\n                }\n            }\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        done: function (cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n    return Animator;\n});\ndefine('echarts/coord/cartesian/AxisModel', ['require', '../../model/Component', 'zrender/core/util', '../axisModelCreator', '../axisModelCommonMixin'], function (require) {\n    'use strict';\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n    var AxisModel = ComponentModel.extend({\n            type: 'cartesian2dAxis',\n            axis: null,\n            init: function () {\n                AxisModel.superApply(this, 'init', arguments);\n                this._resetRange();\n            },\n            mergeOption: function () {\n                AxisModel.superApply(this, 'mergeOption', arguments);\n                this._resetRange();\n            },\n            restoreData: function () {\n                AxisModel.superApply(this, 'restoreData', arguments);\n                this._resetRange();\n            },\n            setRange: function (rangeStart, rangeEnd) {\n                this.option.rangeStart = rangeStart;\n                this.option.rangeEnd = rangeEnd;\n            },\n            getMin: function () {\n                var option = this.option;\n                return option.rangeStart != null ? option.rangeStart : option.min;\n            },\n            getMax: function () {\n                var option = this.option;\n                return option.rangeEnd != null ? option.rangeEnd : option.max;\n            },\n            getNeedCrossZero: function () {\n                var option = this.option;\n                return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n            },\n            findGridModel: function () {\n                return this.ecModel.queryComponents({\n                    mainType: 'grid',\n                    index: this.get('gridIndex'),\n                    id: this.get('gridId')\n                })[0];\n            },\n            _resetRange: function () {\n                // rangeStart and rangeEnd is readonly.\n                this.option.rangeStart = this.option.rangeEnd = null;\n            }\n        });\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    var extraOption = { offset: 0 };\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n    return AxisModel;\n});\ndefine('zrender/animation/Clip', ['require', './easing'], function (require) {\n    var easingFuncs = require('./easing');\n    function Clip(options) {\n        this._target = options.target;\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n        // \n        this.loop = options.loop == null ? false : options.loop;\n        this.gap = options.gap || 0;\n        this.easing = options.easing || 'Linear';\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n    Clip.prototype = {\n        constructor: Clip,\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n            var percent = (globalTime - this._startTime) / this._life;\n            // \n            if (percent < 0) {\n                return;\n            }\n            percent = Math.min(percent, 1);\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n            this.fire('frame', schedule);\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart(globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n            return null;\n        },\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._needsRemove = false;\n        },\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n    return Clip;\n});\ndefine('echarts/coord/axisModelCreator', ['require', './axisDefault', 'zrender/core/util', '../model/Component', '../util/layout'], function (require) {\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = [\n            'value',\n            'category',\n            'time',\n            'log'\n        ];\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n            BaseAxisModelClass.extend({\n                type: axisName + 'Axis.' + axisType,\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n                    option.type = axisTypeDefaulter(axisName, option);\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n                defaultOption: zrUtil.mergeAll([\n                    {},\n                    axisDefault[axisType + 'Axis'],\n                    extraDefaultOption\n                ], true)\n            });\n        });\n        ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n    };\n});\ndefine('echarts/coord/axisModelCommonMixin', ['require', 'zrender/core/util', './axisHelper'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var axisHelper = require('./axisHelper');\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        } else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n    }\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n    }\n    return {\n        getFormattedLabels: getFormattedLabels,\n        getCategories: getCategories\n    };\n});\ndefine('zrender/animation/easing', [], function () {\n    var easing = {\n            linear: function (k) {\n                return k;\n            },\n            quadraticIn: function (k) {\n                return k * k;\n            },\n            quadraticOut: function (k) {\n                return k * (2 - k);\n            },\n            quadraticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k;\n                }\n                return -0.5 * (--k * (k - 2) - 1);\n            },\n            cubicIn: function (k) {\n                return k * k * k;\n            },\n            cubicOut: function (k) {\n                return --k * k * k + 1;\n            },\n            cubicInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k + 2);\n            },\n            quarticIn: function (k) {\n                return k * k * k * k;\n            },\n            quarticOut: function (k) {\n                return 1 - --k * k * k * k;\n            },\n            quarticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k;\n                }\n                return -0.5 * ((k -= 2) * k * k * k - 2);\n            },\n            quinticIn: function (k) {\n                return k * k * k * k * k;\n            },\n            quinticOut: function (k) {\n                return --k * k * k * k * k + 1;\n            },\n            quinticInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return 0.5 * k * k * k * k * k;\n                }\n                return 0.5 * ((k -= 2) * k * k * k * k + 2);\n            },\n            sinusoidalIn: function (k) {\n                return 1 - Math.cos(k * Math.PI / 2);\n            },\n            sinusoidalOut: function (k) {\n                return Math.sin(k * Math.PI / 2);\n            },\n            sinusoidalInOut: function (k) {\n                return 0.5 * (1 - Math.cos(Math.PI * k));\n            },\n            exponentialIn: function (k) {\n                return k === 0 ? 0 : Math.pow(1024, k - 1);\n            },\n            exponentialOut: function (k) {\n                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n            },\n            exponentialInOut: function (k) {\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if ((k *= 2) < 1) {\n                    return 0.5 * Math.pow(1024, k - 1);\n                }\n                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n            },\n            circularIn: function (k) {\n                return 1 - Math.sqrt(1 - k * k);\n            },\n            circularOut: function (k) {\n                return Math.sqrt(1 - --k * k);\n            },\n            circularInOut: function (k) {\n                if ((k *= 2) < 1) {\n                    return -0.5 * (Math.sqrt(1 - k * k) - 1);\n                }\n                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n            },\n            elasticIn: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n            },\n            elasticOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n            },\n            elasticInOut: function (k) {\n                var s;\n                var a = 0.1;\n                var p = 0.4;\n                if (k === 0) {\n                    return 0;\n                }\n                if (k === 1) {\n                    return 1;\n                }\n                if (!a || a < 1) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p * Math.asin(1 / a) / (2 * Math.PI);\n                }\n                if ((k *= 2) < 1) {\n                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n                }\n                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n            },\n            backIn: function (k) {\n                var s = 1.70158;\n                return k * k * ((s + 1) * k - s);\n            },\n            backOut: function (k) {\n                var s = 1.70158;\n                return --k * k * ((s + 1) * k + s) + 1;\n            },\n            backInOut: function (k) {\n                var s = 1.70158 * 1.525;\n                if ((k *= 2) < 1) {\n                    return 0.5 * (k * k * ((s + 1) * k - s));\n                }\n                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n            },\n            bounceIn: function (k) {\n                return 1 - easing.bounceOut(1 - k);\n            },\n            bounceOut: function (k) {\n                if (k < 1 / 2.75) {\n                    return 7.5625 * k * k;\n                } else if (k < 2 / 2.75) {\n                    return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n                } else if (k < 2.5 / 2.75) {\n                    return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n                } else {\n                    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n                }\n            },\n            bounceInOut: function (k) {\n                if (k < 0.5) {\n                    return easing.bounceIn(k * 2) * 0.5;\n                }\n                return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n            }\n        };\n    return easing;\n});\ndefine('echarts/coord/axisDefault', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var defaultOption = {\n            show: true,\n            zlevel: 0,\n            z: 0,\n            inverse: false,\n            name: '',\n            nameLocation: 'end',\n            nameRotate: null,\n            nameTruncate: {\n                maxWidth: null,\n                ellipsis: '...',\n                placeholder: '.'\n            },\n            nameTextStyle: {},\n            nameGap: 15,\n            silent: false,\n            triggerEvent: false,\n            tooltip: { show: false },\n            axisLine: {\n                show: true,\n                onZero: true,\n                lineStyle: {\n                    color: '#333',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisTick: {\n                show: true,\n                inside: false,\n                length: 5,\n                lineStyle: { width: 1 }\n            },\n            axisLabel: {\n                show: true,\n                inside: false,\n                rotate: 0,\n                margin: 8,\n                textStyle: { fontSize: 12 }\n            },\n            splitLine: {\n                show: true,\n                lineStyle: {\n                    color: ['#ccc'],\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            splitArea: {\n                show: false,\n                areaStyle: {\n                    color: [\n                        'rgba(250,250,250,0.3)',\n                        'rgba(200,200,200,0.3)'\n                    ]\n                }\n            }\n        };\n    var categoryAxis = zrUtil.merge({\n            boundaryGap: true,\n            splitLine: { show: false },\n            axisTick: {\n                alignWithLabel: false,\n                interval: 'auto'\n            },\n            axisLabel: { interval: 'auto' }\n        }, defaultOption);\n    var valueAxis = zrUtil.merge({\n            boundaryGap: [\n                0,\n                0\n            ],\n            splitNumber: 5\n        }, defaultOption);\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n            scale: true,\n            min: 'dataMin',\n            max: 'dataMax'\n        }, valueAxis);\n    var logAxis = zrUtil.defaults({ logBase: 10 }, valueAxis);\n    logAxis.scale = true;\n    return {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n});\ndefine('zrender/config', [], function () {\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n            debugMode: 0,\n            devicePixelRatio: dpr\n        };\n    return config;\n});\ndefine('echarts/chart/helper/createListFromArray', ['require', '../../data/List', '../../data/helper/completeDimensions', 'zrender/core/util', '../../util/model', '../../CoordinateSystem'], function (require) {\n    'use strict';\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = registeredCoordSys && registeredCoordSys.dimensions || [\n                'x',\n                'y'\n            ];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n        var list = new List(dimensions, seriesModel);\n        var nameList = createNameList(axesInfo, data);\n        var categories = {};\n        var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            } : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n        return list;\n    }\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n    }\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n            cartesian2d: function (data, seriesModel, ecModel) {\n                var axesModels = zrUtil.map([\n                        'xAxis',\n                        'yAxis'\n                    ], function (name) {\n                        return ecModel.queryComponents({\n                            mainType: name,\n                            index: seriesModel.get(name + 'Index'),\n                            id: seriesModel.get(name + 'Id')\n                        })[0];\n                    });\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n                if (true) {\n                    if (!xAxisModel) {\n                        throw new Error('xAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n                    }\n                    if (!yAxisModel) {\n                        throw new Error('yAxis \"' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n                    }\n                }\n                var xAxisType = xAxisModel.get('type');\n                var yAxisType = yAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'x',\n                            type: getDimTypeByAxis(xAxisType),\n                            stackable: isStackable(xAxisType)\n                        },\n                        {\n                            name: 'y',\n                            type: getDimTypeByAxis(yAxisType),\n                            stackable: isStackable(yAxisType)\n                        }\n                    ];\n                var isXAxisCateogry = xAxisType === 'category';\n                var isYAxisCategory = yAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'x',\n                    'y',\n                    'z'\n                ]);\n                var categoryAxesModels = {};\n                if (isXAxisCateogry) {\n                    categoryAxesModels.x = xAxisModel;\n                }\n                if (isYAxisCategory) {\n                    categoryAxesModels.y = yAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            polar: function (data, seriesModel, ecModel) {\n                var polarModel = ecModel.queryComponents({\n                        mainType: 'polar',\n                        index: seriesModel.get('polarIndex'),\n                        id: seriesModel.get('polarId')\n                    })[0];\n                var angleAxisModel = polarModel.findAxisModel('angleAxis');\n                var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n                if (true) {\n                    if (!angleAxisModel) {\n                        throw new Error('angleAxis option not found');\n                    }\n                    if (!radiusAxisModel) {\n                        throw new Error('radiusAxis option not found');\n                    }\n                }\n                var radiusAxisType = radiusAxisModel.get('type');\n                var angleAxisType = angleAxisModel.get('type');\n                var dimensions = [\n                        {\n                            name: 'radius',\n                            type: getDimTypeByAxis(radiusAxisType),\n                            stackable: isStackable(radiusAxisType)\n                        },\n                        {\n                            name: 'angle',\n                            type: getDimTypeByAxis(angleAxisType),\n                            stackable: isStackable(angleAxisType)\n                        }\n                    ];\n                var isAngleAxisCateogry = angleAxisType === 'category';\n                var isRadiusAxisCateogry = radiusAxisType === 'category';\n                completeDimensions(dimensions, data, [\n                    'radius',\n                    'angle',\n                    'value'\n                ]);\n                var categoryAxesModels = {};\n                if (isRadiusAxisCateogry) {\n                    categoryAxesModels.radius = radiusAxisModel;\n                }\n                if (isAngleAxisCateogry) {\n                    categoryAxesModels.angle = angleAxisModel;\n                }\n                return {\n                    dimensions: dimensions,\n                    categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n                    categoryAxesModels: categoryAxesModels\n                };\n            },\n            geo: function (data, seriesModel, ecModel) {\n                // TODO Region\n                // \n                return {\n                    dimensions: completeDimensions([\n                        { name: 'lng' },\n                        { name: 'lat' }\n                    ], data, [\n                        'lng',\n                        'lat',\n                        'value'\n                    ])\n                };\n            }\n        };\n    function createNameList(result, data) {\n        var nameList = [];\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                } else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n        return nameList;\n    }\n    return createListFromArray;\n});\ndefine('zrender/core/curve', ['require', './vector'], function (require) {\n    'use strict';\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 0.0001;\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1 - p0);\n        var d = p0 - val;\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n        var n = 0;\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            } else {\n                var t1 = -c / b;\n                //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = B * B - 4 * A * C;\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;\n                // t1, a is not zero\n                var t2 = -K / 2;\n                // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                } else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                } else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n        _v0[0] = x;\n        _v0[1] = y;\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n            d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        } else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            } else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        } else {\n            return (p0 - p1) / divider;\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        _v0[0] = x;\n        _v0[1] = y;\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n            var d1 = v2DistSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            } else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                } else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n    return {\n        cubicAt: cubicAt,\n        cubicDerivativeAt: cubicDerivativeAt,\n        cubicRootAt: cubicRootAt,\n        cubicExtrema: cubicExtrema,\n        cubicSubdivide: cubicSubdivide,\n        cubicProjectPoint: cubicProjectPoint,\n        quadraticAt: quadraticAt,\n        quadraticDerivativeAt: quadraticDerivativeAt,\n        quadraticRootAt: quadraticRootAt,\n        quadraticExtremum: quadraticExtremum,\n        quadraticSubdivide: quadraticSubdivide,\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n});\ndefine('zrender/core/bbox', ['require', './vector', './curve'], function (require) {\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function (points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n        var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff % PI2 < 0.0001 && diff > 0.0001) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % PI2;\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % PI2;\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        } else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n    return bbox;\n});\ndefine('echarts/data/DataDiffer', ['require'], function (require) {\n    'use strict';\n    function defaultKeyGetter(item) {\n        return item;\n    }\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n    DataDiffer.prototype = {\n        constructor: DataDiffer,\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    } else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                } else {\n                    this._remove && this._remove(i);\n                }\n            }\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    } else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            } else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n    return DataDiffer;\n});\ndefine('echarts/data/helper/completeDimensions', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);\n                dimensions[i] = guessOrdinal(data, i) ? {\n                    type: 'ordinal',\n                    name: name\n                } : name;\n            }\n        }\n        return dimensions;\n    }\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                var value = retrieveValue(data[i]);\n                if (!zrUtil.isArray(value)) {\n                    return false;\n                }\n                var value = value[dimIndex];\n                if (value != null && isFinite(value)) {\n                    return false;\n                } else if (zrUtil.isString(value) && value !== '-') {\n                    return true;\n                }\n            }\n            return false;\n        };\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n    }\n    return completeDimensions;\n});\ndefine('zrender/contain/cubic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/line', [], function () {\n    return {\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n                return false;\n            }\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n            } else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/quadratic', ['require', '../core/curve'], function (require) {\n    var curve = require('../core/curve');\n    return {\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n            return d <= _l / 2;\n        }\n    };\n});\ndefine('zrender/contain/arc', ['require', './util'], function (require) {\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n    return {\n        containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n            if (d - _l > r || d + _l < r) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n        }\n    };\n});\ndefine('zrender/contain/util', ['require'], function (require) {\n    var PI2 = Math.PI * 2;\n    return {\n        normalizeRadian: function (angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n});\ndefine('zrender/contain/windingLine', [], function () {\n    return function windingLine(x0, y0, x1, y1, x, y) {\n        if (y > y0 && y > y1 || y < y0 && y < y1) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n        var x_ = t * (x1 - x0) + x0;\n        return x_ > x ? dir : 0;\n    };\n});\ndefine('echarts/chart/bar/barItemStyle', ['require', '../../model/mixin/makeStyleMapper'], function (require) {\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')([\n            [\n                'fill',\n                'color'\n            ],\n            [\n                'stroke',\n                'borderColor'\n            ],\n            [\n                'lineWidth',\n                'borderWidth'\n            ],\n            [\n                'stroke',\n                'barBorderColor'\n            ],\n            [\n                'lineWidth',\n                'barBorderWidth'\n            ],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]);\n    return {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n});\ndefine('zrender/core/LRU', ['require'], function (require) {\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n        this._len = 0;\n    };\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        } else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        } else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        } else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n        this._list = new LinkedList();\n        this._map = {};\n        this._maxSize = maxSize || 10;\n    };\n    var LRUProto = LRU.prototype;\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n            return entry.value;\n        }\n    };\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n    return LRU;\n});\ndefine('zrender/graphic/helper/poly', ['require', './smoothSpline', './smoothBezier'], function (require) {\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n    return {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n                    }\n                } else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n                closePath && ctx.closePath();\n            }\n        }\n    };\n});\ndefine('zrender/graphic/helper/smoothSpline', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    return function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n            var w = pos - idx;\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            } else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n            var w2 = w * w;\n            var w3 = w * w2;\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n});\ndefine('zrender/graphic/helper/smoothBezier', ['require', '../../core/vector'], function (require) {\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    return function (points, smooth, isLoop, constraint) {\n        var cps = [];\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n        var min, max;\n        if (constraint) {\n            min = [\n                Infinity,\n                Infinity\n            ];\n            max = [\n                -Infinity,\n                -Infinity\n            ];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            } else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                } else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n            vec2.sub(v, nextPoint, prevPoint);\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n        return cps;\n    };\n});\ndefine('zrender/graphic/helper/roundRect', ['require'], function (require) {\n    return {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            } else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                } else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                } else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                } else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            } else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n});\ndefine('zrender/Storage', ['require', './core/util', './core/env', './container/Group', './core/timsort'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var env = require('./core/env');\n    var Group = require('./container/Group');\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n    };\n    Storage.prototype = {\n        constructor: Storage,\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n            el.beforeUpdate();\n            if (el.__dirty) {\n                el.update();\n            }\n            el.afterUpdate();\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath  group \n                clipPath.parent = el;\n                clipPath.updateTransform();\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                } else {\n                    clipPaths = [clipPath];\n                }\n            }\n            if (el.isGroup) {\n                var children = el._children;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n                // Mark group clean here\n                el.__dirty = false;\n            } else {\n                el.__clipPaths = clipPaths;\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n                return;\n            }\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n            var el;\n            if (typeof elId == 'string') {\n                el = this._elements[elId];\n            } else {\n                el = elId;\n            }\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n            this._elements[el.id] = el;\n            return this;\n        },\n        get: function (elId) {\n            return this._elements[elId];\n        },\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n            return this;\n        },\n        dispose: function () {\n            this._elements = this._renderList = this._roots = null;\n        },\n        displayableSortFunc: shapeCompareFunc\n    };\n    return Storage;\n});\ndefine('zrender/Handler', ['require', './core/util', './mixin/Draggable', './mixin/Eventful'], function (require) {\n    'use strict';\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n    var Eventful = require('./mixin/Eventful');\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n    function EmptyProxy() {\n    }\n    EmptyProxy.prototype.dispose = function () {\n    };\n    var handlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function (storage, painter, proxy) {\n        Eventful.call(this);\n        this.storage = storage;\n        this.painter = painter;\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n        // Attach handler\n        proxy.handler = this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n        Draggable.call(this);\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n    Handler.prototype = {\n        constructor: Handler,\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n            this._hovered = hovered;\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n            this.trigger('globalout', { event: event });\n        },\n        resize: function (event) {\n            this._hovered = null;\n        },\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n        dispose: function () {\n            this.proxy.dispose();\n            this.storage = this.proxy = this.painter = null;\n        },\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n            var el = targetEl;\n            while (el) {\n                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n                el.trigger(eventName, eventPacket);\n                el = el.parent;\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof layer[eventHandler] == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n        findHover: function (x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0; i--) {\n                if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n    // Common handlers\n    util.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            } else if (name === 'mosueup') {\n                this._upel = hovered;\n            } else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n        return false;\n    }\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n    return Handler;\n});\ndefine('zrender/animation/Animation', ['require', '../core/util', '../core/event', './requestAnimationFrame', './Animator'], function (require) {\n    'use strict';\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n    var requestAnimationFrame = require('./requestAnimationFrame');\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n        options = options || {};\n        this.stage = options.stage || {};\n        this.onframe = options.onframe || function () {\n        };\n        // private properties\n        this._clips = [];\n        this._running = false;\n        this._time;\n        this._pausedTime;\n        this._pauseStart;\n        this._paused = false;\n        Dispatcher.call(this);\n    };\n    Animation.prototype = {\n        constructor: Animation,\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        removeClip: function (clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n        _update: function () {\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                } else {\n                    i++;\n                }\n            }\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n            this._time = time;\n            this.onframe(delta);\n            this.trigger('frame', delta);\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n        _startLoop: function () {\n            var self = this;\n            this._running = true;\n            function step() {\n                if (self._running) {\n                    requestAnimationFrame(step);\n                    !self._paused && self._update();\n                }\n            }\n            requestAnimationFrame(step);\n        },\n        start: function () {\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n            this._startLoop();\n        },\n        stop: function () {\n            this._running = false;\n        },\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += new Date().getTime() - this._pauseStart;\n                this._paused = false;\n            }\n        },\n        clear: function () {\n            this._clips = [];\n        },\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(target, options.loop, options.getter, options.setter);\n            return animator;\n        }\n    };\n    util.mixin(Animation, Dispatcher);\n    return Animation;\n});\ndefine('zrender/dom/HandlerProxy', ['require', '../core/event', '../core/util', '../mixin/Eventful', '../core/env', '../core/GestureMgr'], function (require) {\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n    var TOUCH_CLICK_DELAY = 300;\n    var mouseHandlerNames = [\n            'click',\n            'dblclick',\n            'mousewheel',\n            'mouseout',\n            'mouseup',\n            'mousedown',\n            'mousemove'\n        ];\n    var touchHandlerNames = [\n            'touchstart',\n            'touchend',\n            'touchmove'\n        ];\n    function eventNameFix(name) {\n        return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n    }\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n        stage === 'start' && gestureMgr.clear();\n        var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null), proxy.dom);\n        stage === 'end' && gestureMgr.clear();\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n    var domHandlers = {\n            mousemove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                this.trigger('mousemove', event);\n            },\n            mouseout: function (event) {\n                event = normalizeEvent(this.dom, event);\n                var element = event.toElement || event.relatedTarget;\n                if (element != this.dom) {\n                    while (element && element.nodeType != 9) {\n                        // rootdommouseOut\n                        if (element === this.dom) {\n                            return;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                this.trigger('mouseout', event);\n            },\n            touchstart: function (event) {\n                // Default mouse behaviour should not be disabled here.\n                // For example, page may needs to be slided.\n                event = normalizeEvent(this.dom, event);\n                this._lastTouchMoment = new Date();\n                processGesture(this, event, 'start');\n                // findHover\n                // this._mobileFindFixed(event);\n                // Trigger mousemove and mousedown\n                domHandlers.mousemove.call(this, event);\n                domHandlers.mousedown.call(this, event);\n                setTouchTimer(this);\n            },\n            touchmove: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'change');\n                // Mouse move should always be triggered no matter whether\n                // there is gestrue event, because mouse move and pinch may\n                // be used at the same time.\n                domHandlers.mousemove.call(this, event);\n                setTouchTimer(this);\n            },\n            touchend: function (event) {\n                event = normalizeEvent(this.dom, event);\n                processGesture(this, event, 'end');\n                domHandlers.mouseup.call(this, event);\n                // click event should always be triggered no matter whether\n                // there is gestrue event. System click can not be prevented.\n                if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                    domHandlers.click.call(this, event);\n                }\n                setTouchTimer(this);\n            }\n        };\n    // Common handlers\n    zrUtil.each([\n        'click',\n        'mousedown',\n        'mouseup',\n        'mousewheel',\n        'dblclick'\n    ], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n        this.dom = dom;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n        this._handlers = {};\n        initDomHandler(this);\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);    // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                                                       // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n    return HandlerDomProxy;\n});\ndefine('zrender/Painter', ['require', './config', './core/util', './core/log', './core/BoundingRect', './core/timsort', './Layer', './animation/requestAnimationFrame', './graphic/Image'], function (require) {\n    'use strict';\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n    var Layer = require('./Layer');\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n        if (layer.isBuildin) {\n            return true;\n        }\n        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n            return false;\n        }\n        return true;\n    }\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) {\n            // Can both be null or undefined\n            return false;\n        }\n        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n        // domRoot.onselectstart = returnFalse; // \n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';\n        opts = opts || {};\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n        var rootStyle = root.style;\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n            root.innerHTML = '';\n        }\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n            var domRoot = this._domRoot = createRoot(this._width, this._height);\n            root.appendChild(domRoot);\n        } else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n        this.pathToImage = this._createPathToImage();\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n        this._hoverElements = [];\n    };\n    Painter.prototype = {\n        constructor: Painter,\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n        refresh: function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var zlevelList = this._zlevelList;\n            this._paintList(list, paintAll);\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n            this.refreshHover();\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n            return this;\n        },\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                    style: el.style,\n                    shape: el.shape\n                });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(100000);\n            }\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n        _startProgessive: function () {\n            var self = this;\n            if (!self._furtherProgressive) {\n                return;\n            }\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n            self._progress++;\n            requestAnimationFrame(step);\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n                    self._doPaintList(self.storage.getDisplayList());\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    } else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n        _paintList: function (list, paintAll) {\n            if (paintAll == null) {\n                paintAll = false;\n            }\n            this._updateLayerStatus(list);\n            this._clearProgressive();\n            this.eachBuildinLayer(preProcessLayer);\n            this._doPaintList(list, paintAll);\n            this.eachBuildinLayer(postProcessLayer);\n        },\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n            // var invTransform = [];\n            var scope;\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n                var elFrame = el.__frame;\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n                    // Reset scope\n                    scope = {};\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n                    if (!currentLayer.isBuildin) {\n                        log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n                    }\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n                        if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n                        layerProgress = currentProgressiveLayer.__progress;\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                } else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n                el.__dirty = false;\n            }\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n                var clipPaths = el.__clipPaths;\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n                this.insertLayer(zlevel, layer);\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n            return layer;\n        },\n        insertLayer: function (zlevel, layer) {\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            } else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                } else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            layersMap[zlevel] = layer;\n        },\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n        getLayers: function () {\n            return this._layers;\n        },\n        _updateLayerStatus: function (list) {\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n                    currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                } else {\n                    el.__frame = -1;\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                } else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n                var layer = this._layers[zlevel];\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n            domRoot.style.display = '';\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n                this.refresh(true);\n            }\n            this._width = width;\n            this._height = height;\n            return this;\n        },\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n        dispose: function () {\n            this.root.innerHTML = '';\n            this.root = this.storage = this._domRoot = this._layers = null;\n        },\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n            var displayList = this.storage.getDisplayList(true);\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n            return imageLayer.dom;\n        },\n        getWidth: function () {\n            return this._width;\n        },\n        getHeight: function () {\n            return this._height;\n        },\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;\n        },\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;\n        },\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n            var pathTransform = {\n                    position: path.position,\n                    rotation: path.rotation,\n                    scale: path.scale\n                };\n            path.position = [\n                0,\n                0,\n                0\n            ];\n            path.rotation = 0;\n            path.scale = [\n                1,\n                1\n            ];\n            if (path) {\n                path.brush(ctx);\n            }\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                    id: id,\n                    style: {\n                        x: 0,\n                        y: 0,\n                        image: canvas\n                    }\n                });\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n            return imgShape;\n        },\n        _createPathToImage: function () {\n            var me = this;\n            return function (id, e, width, height) {\n                return me._pathToImage(id, e, width, height, me.dpr);\n            };\n        }\n    };\n    return Painter;\n});\ndefine('zrender/mixin/Draggable', ['require'], function (require) {\n    function Draggable() {\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);    // this._dropTarget = null;\n                                                      // this._draggingTarget = null;\n                                                      // this._x = 0;\n                                                      // this._y = 0;\n    }\n    Draggable.prototype = {\n        constructor: Draggable,\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                var x = e.offsetX;\n                var y = e.offsetY;\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n    };\n    return Draggable;\n});\ndefine('zrender/core/event', ['require', '../mixin/Eventful'], function (require) {\n    'use strict';\n    var Eventful = require('../mixin/Eventful');\n    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n            left: 0,\n            top: 0\n        };\n    }\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n    /**\n     * domtouch\n     */\n    function normalizeEvent(el, e) {\n        e = e || window.event;\n        if (e.zrX != null) {\n            return e;\n        }\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        } else {\n            var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n        return e;\n    }\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        } else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        } else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2 ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        } : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n    return {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        stop: stop,\n        Dispatcher: Eventful\n    };\n});\ndefine('zrender/animation/requestAnimationFrame', ['require'], function (require) {\n    return typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n        setTimeout(func, 16);\n    };\n});\ndefine('zrender/core/GestureMgr', ['require', './event'], function (require) {\n    'use strict';\n    var eventUtil = require('./event');\n    var GestureMgr = function () {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n    GestureMgr.prototype = {\n        constructor: GestureMgr,\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n            if (!touches) {\n                return;\n            }\n            var trackItem = {\n                    points: [],\n                    touches: [],\n                    target: target,\n                    event: event\n                };\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([\n                    pos.zrX,\n                    pos.zrY\n                ]);\n                trackItem.touches.push(touch);\n            }\n            this._track.push(trackItem);\n        },\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n    var recognizers = {\n            pinch: function (track, event) {\n                var trackLen = track.length;\n                if (!trackLen) {\n                    return;\n                }\n                var pinchEnd = (track[trackLen - 1] || {}).points;\n                var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n                if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n                    var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                    !isFinite(pinchScale) && (pinchScale = 1);\n                    event.pinchScale = pinchScale;\n                    var pinchCenter = center(pinchEnd);\n                    event.pinchX = pinchCenter[0];\n                    event.pinchY = pinchCenter[1];\n                    return {\n                        type: 'pinch',\n                        target: track[0].target,\n                        event: event\n                    };\n                }\n            }    // Only pinch currently.\n        };\n    return GestureMgr;\n});\ndefine('zrender/Layer', ['require', './core/util', './config', './graphic/Style', './graphic/Pattern'], function (require) {\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n    function returnFalse() {\n        return false;\n    }\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function (id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }    // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n        var domStyle = dom.style;\n        if (domStyle) {\n            // Not in node\n            dom.onselectstart = returnFalse;\n            // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n        this.domBack = null;\n        this.ctxBack = null;\n        this.painter = painter;\n        this.config = null;\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n    Layer.prototype = {\n        constructor: Layer,\n        elCount: 0,\n        __dirty: true,\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.dpr = this.dpr;\n        },\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n        resize: function (width, height) {\n            var dpr = this.dpr;\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n            var dpr = this.dpr;\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n            }\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }    // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n    return Layer;\n});\ndefine('echarts/preprocessor/helper/compatStyle', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var POSSIBLE_STYLES = [\n            'areaStyle',\n            'lineStyle',\n            'nodeStyle',\n            'linkStyle',\n            'chordStyle',\n            'label',\n            'labelLine'\n        ];\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    } else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n    return function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    } else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('echarts/component/helper/selectableMixin', ['require', 'zrender/core/util'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    return {\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n});\ndefine('echarts/component/axis/AxisView', ['require', 'zrender/core/util', '../../util/graphic', './AxisBuilder', '../../echarts'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n    var axisBuilderAttrs = [\n            'axisLine',\n            'axisLabel',\n            'axisTick',\n            'axisName'\n        ];\n    var selfBuilderAttrs = [\n            'splitArea',\n            'splitLine'\n        ];\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n    var AxisView = require('../../echarts').extendComponentView({\n            type: 'axis',\n            render: function (axisModel, ecModel) {\n                this.group.removeAll();\n                var oldAxisGroup = this._axisGroup;\n                this._axisGroup = new graphic.Group();\n                this.group.add(this._axisGroup);\n                if (!axisModel.get('show')) {\n                    return;\n                }\n                var gridModel = axisModel.findGridModel();\n                var layout = layoutAxis(gridModel, axisModel);\n                var axisBuilder = new AxisBuilder(axisModel, layout);\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this._axisGroup.add(axisBuilder.getGroup());\n                zrUtil.each(selfBuilderAttrs, function (name) {\n                    if (axisModel.get(name + '.show')) {\n                        this['_' + name](axisModel, gridModel, layout.labelInterval);\n                    }\n                }, this);\n                graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n            },\n            _splitLine: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitLineModel = axisModel.getModel('splitLine');\n                var lineStyleModel = splitLineModel.getModel('lineStyle');\n                var lineColors = lineStyleModel.get('color');\n                var lineInterval = getInterval(splitLineModel, labelInterval);\n                lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var isHorizontal = axis.isHorizontal();\n                var lineCount = 0;\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var p1 = [];\n                var p2 = [];\n                // Simple optimization\n                // Batching the lines if color are the same\n                var lineStyle = lineStyleModel.getLineStyle();\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    if (isHorizontal) {\n                        p1[0] = tickCoord;\n                        p1[1] = gridRect.y;\n                        p2[0] = tickCoord;\n                        p2[1] = gridRect.y + gridRect.height;\n                    } else {\n                        p1[0] = gridRect.x;\n                        p1[1] = tickCoord;\n                        p2[0] = gridRect.x + gridRect.width;\n                        p2[1] = tickCoord;\n                    }\n                    var colorIndex = lineCount++ % lineColors.length;\n                    this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'line_' + ticks[i],\n                        shape: {\n                            x1: p1[0],\n                            y1: p1[1],\n                            x2: p2[0],\n                            y2: p2[1]\n                        },\n                        style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle),\n                        silent: true\n                    })));\n                }\n            },\n            _splitArea: function (axisModel, gridModel, labelInterval) {\n                var axis = axisModel.axis;\n                var splitAreaModel = axisModel.getModel('splitArea');\n                var areaStyleModel = splitAreaModel.getModel('areaStyle');\n                var areaColors = areaStyleModel.get('color');\n                var gridRect = gridModel.coordinateSystem.getRect();\n                var ticksCoords = axis.getTicksCoords();\n                var ticks = axis.scale.getTicks();\n                var prevX = axis.toGlobalCoord(ticksCoords[0]);\n                var prevY = axis.toGlobalCoord(ticksCoords[0]);\n                var count = 0;\n                var areaInterval = getInterval(splitAreaModel, labelInterval);\n                var areaStyle = areaStyleModel.getAreaStyle();\n                areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n                for (var i = 1; i < ticksCoords.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                        continue;\n                    }\n                    var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n                    var x;\n                    var y;\n                    var width;\n                    var height;\n                    if (axis.isHorizontal()) {\n                        x = prevX;\n                        y = gridRect.y;\n                        width = tickCoord - x;\n                        height = gridRect.height;\n                    } else {\n                        x = gridRect.x;\n                        y = prevY;\n                        width = gridRect.width;\n                        height = tickCoord - y;\n                    }\n                    var colorIndex = count++ % areaColors.length;\n                    this._axisGroup.add(new graphic.Rect({\n                        anid: 'area_' + ticks[i],\n                        shape: {\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        },\n                        style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle),\n                        silent: true\n                    }));\n                    prevX = x + width;\n                    prevY = y + height;\n                }\n            }\n        });\n    AxisView.extend({ type: 'xAxis' });\n    AxisView.extend({ type: 'yAxis' });\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [\n                rect.x,\n                rect.x + rect.width,\n                rect.y,\n                rect.y + rect.height\n            ];\n        var axisOffset = axisModel.get('offset') || 0;\n        var posMap = {\n                x: {\n                    top: rectBound[2] - axisOffset,\n                    bottom: rectBound[3] + axisOffset\n                },\n                y: {\n                    left: rectBound[0] - axisOffset,\n                    right: rectBound[1] + axisOffset\n                }\n            };\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n        // Tick and label direction, x y is axisDim\n        var dirMap = {\n                top: -1,\n                bottom: 1,\n                left: -1,\n                right: 1\n            };\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n        return layout;\n    }\n});\ndefine('echarts/chart/pie/labelLayout', ['require', 'zrender/contain/text'], function (require) {\n    'use strict';\n    var textContain = require('zrender/contain/text');\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n            shiftUp(end - 1, delta / 2);\n        }\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n                    break;\n                }\n            }\n        }\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;\n            // \n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            } else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            } else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                } else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n    return function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n            cx = layout.cx;\n            cy = layout.cy;\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            } else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n                    var y3 = y2;\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [\n                        [\n                            x1,\n                            y1\n                        ],\n                        [\n                            x2,\n                            y2\n                        ],\n                        [\n                            x3,\n                            y3\n                        ]\n                    ];\n                }\n                textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n            var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n            var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n});\ndefine('echarts/component/axis/AxisBuilder', ['require', 'zrender/core/util', '../../util/format', '../../util/graphic', '../../model/Model', '../../util/number', 'zrender/core/vector'], function (require) {\n    var zrUtil = require('zrender/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n    var PI = Math.PI;\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = { componentType: axisModel.mainType };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n        // Default value\n        zrUtil.defaults(opt, {\n            labelOffset: 0,\n            nameDirection: 1,\n            tickDirection: 1,\n            labelDirection: 1,\n            silent: true\n        });\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n                position: opt.position.slice(),\n                rotation: opt.rotation\n            });\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n        this._dumbGroup = dumbGroup;\n    };\n    AxisBuilder.prototype = {\n        constructor: AxisBuilder,\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n        add: function (name) {\n            builders[name].call(this);\n        },\n        getGroup: function () {\n            return this.group;\n        }\n    };\n    var builders = {\n            axisLine: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisLine.show')) {\n                    return;\n                }\n                var extent = this.axisModel.axis.getExtent();\n                var matrix = this._transform;\n                var pt1 = [\n                        extent[0],\n                        0\n                    ];\n                var pt2 = [\n                        extent[1],\n                        0\n                    ];\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line',\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),\n                    strokeContainThreshold: opt.strokeContainThreshold || 5,\n                    silent: true,\n                    z2: 1\n                })));\n            },\n            axisTick: function () {\n                var axisModel = this.axisModel;\n                if (!axisModel.get('axisTick.show')) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var tickModel = axisModel.getModel('axisTick');\n                var opt = this.opt;\n                var lineStyleModel = tickModel.getModel('lineStyle');\n                var tickLen = tickModel.get('length');\n                var tickInterval = getInterval(tickModel, opt.labelInterval);\n                var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n                var ticks = axis.scale.getTicks();\n                var pt1 = [];\n                var pt2 = [];\n                var matrix = this._transform;\n                for (var i = 0; i < ticksCoords.length; i++) {\n                    // Only ordinal scale support tick interval\n                    if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                        continue;\n                    }\n                    var tickCoord = ticksCoords[i];\n                    pt1[0] = tickCoord;\n                    pt1[1] = 0;\n                    pt2[0] = tickCoord;\n                    pt2[1] = opt.tickDirection * tickLen;\n                    if (matrix) {\n                        v2ApplyTransform(pt1, pt1, matrix);\n                        v2ApplyTransform(pt2, pt2, matrix);\n                    }\n                    // Tick line, Not use group transform to have better line draw\n                    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                        anid: 'tick_' + ticks[i],\n                        shape: {\n                            x1: pt1[0],\n                            y1: pt1[1],\n                            x2: pt2[0],\n                            y2: pt2[1]\n                        },\n                        style: zrUtil.defaults(lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') }),\n                        z2: 2,\n                        silent: true\n                    })));\n                }\n            },\n            axisLabel: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n                if (!show) {\n                    return;\n                }\n                var axis = axisModel.axis;\n                var labelModel = axisModel.getModel('axisLabel');\n                var textStyleModel = labelModel.getModel('textStyle');\n                var labelMargin = labelModel.get('margin');\n                var ticks = axis.scale.getTicks();\n                var labels = axisModel.getFormattedLabels();\n                // Special label rotate.\n                var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n                // To radian.\n                labelRotation = labelRotation * PI / 180;\n                var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n                var categoryData = axisModel.get('data');\n                var textEls = [];\n                var silent = isSilent(axisModel);\n                var triggerEvent = axisModel.get('triggerEvent');\n                for (var i = 0; i < ticks.length; i++) {\n                    if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                        continue;\n                    }\n                    var itemTextStyleModel = textStyleModel;\n                    if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                        itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);\n                    }\n                    var textColor = itemTextStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n                    var tickCoord = axis.dataToCoord(ticks[i]);\n                    var pos = [\n                            tickCoord,\n                            opt.labelOffset + opt.labelDirection * labelMargin\n                        ];\n                    var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n                    var textEl = new graphic.Text({\n                            anid: 'label_' + ticks[i],\n                            style: {\n                                text: labels[i],\n                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                                textFont: itemTextStyleModel.getFont(),\n                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                            },\n                            position: pos,\n                            rotation: labelLayout.rotation,\n                            silent: silent,\n                            z2: 10\n                        });\n                    // Pack data for mouse event\n                    if (triggerEvent) {\n                        textEl.eventData = makeAxisEventDataBase(axisModel);\n                        textEl.eventData.targetType = 'axisLabel';\n                        textEl.eventData.value = labelBeforeFormat;\n                    }\n                    // FIXME\n                    this._dumbGroup.add(textEl);\n                    textEl.updateTransform();\n                    textEls.push(textEl);\n                    this.group.add(textEl);\n                    textEl.decomposeTransform();\n                }\n                function isTwoLabelOverlapped(current, next) {\n                    var firstRect = current && current.getBoundingRect().clone();\n                    var nextRect = next && next.getBoundingRect().clone();\n                    if (firstRect && nextRect) {\n                        firstRect.applyTransform(current.getLocalTransform());\n                        nextRect.applyTransform(next.getLocalTransform());\n                        return firstRect.intersect(nextRect);\n                    }\n                }\n                if (axis.type !== 'category') {\n                    // If min or max are user set, we need to check\n                    // If the tick on min(max) are overlap on their neighbour tick\n                    // If they are overlapped, we need to hide the min(max) tick label\n                    if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                        var firstLabel = textEls[0];\n                        var nextLabel = textEls[1];\n                        if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                            firstLabel.ignore = true;\n                        }\n                    }\n                    if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                        var lastLabel = textEls[textEls.length - 1];\n                        var prevLabel = textEls[textEls.length - 2];\n                        if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                            lastLabel.ignore = true;\n                        }\n                    }\n                }\n            },\n            axisName: function () {\n                var opt = this.opt;\n                var axisModel = this.axisModel;\n                var name = retrieve(opt.axisName, axisModel.get('name'));\n                if (!name) {\n                    return;\n                }\n                var nameLocation = axisModel.get('nameLocation');\n                var nameDirection = opt.nameDirection;\n                var textStyleModel = axisModel.getModel('nameTextStyle');\n                var gap = axisModel.get('nameGap') || 0;\n                var extent = this.axisModel.axis.getExtent();\n                var gapSignal = extent[0] > extent[1] ? -1 : 1;\n                var pos = [\n                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n                    ];\n                var labelLayout;\n                var nameRotation = axisModel.get('nameRotate');\n                if (nameRotation != null) {\n                    nameRotation = nameRotation * PI / 180;    // To radian.\n                }\n                var axisNameAvailableWidth;\n                if (nameLocation === 'middle') {\n                    labelLayout = innerTextLayout(opt, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n                } else {\n                    labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n                    axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                    if (axisNameAvailableWidth != null) {\n                        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n                        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                    }\n                }\n                var textFont = textStyleModel.getFont();\n                var truncateOpt = axisModel.get('nameTruncate', true) || {};\n                var ellipsis = truncateOpt.ellipsis;\n                var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n                var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n                        minChar: 2,\n                        placeholder: truncateOpt.placeholder\n                    }) : name;\n                var tooltipOpt = axisModel.get('tooltip', true);\n                var mainType = axisModel.mainType;\n                var formatterParams = {\n                        componentType: mainType,\n                        name: name,\n                        $vars: ['name']\n                    };\n                formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n                var textEl = new graphic.Text({\n                        anid: 'name',\n                        __fullText: name,\n                        __truncatedText: truncatedText,\n                        style: {\n                            text: truncatedText,\n                            textFont: textFont,\n                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n                            textAlign: labelLayout.textAlign,\n                            textVerticalAlign: labelLayout.verticalAlign\n                        },\n                        position: pos,\n                        rotation: labelLayout.rotation,\n                        silent: isSilent(axisModel),\n                        z2: 1,\n                        tooltip: tooltipOpt && tooltipOpt.show ? zrUtil.extend({\n                            content: name,\n                            formatter: function () {\n                                return name;\n                            },\n                            formatterParams: formatterParams\n                        }, tooltipOpt) : null\n                    });\n                if (axisModel.get('triggerEvent')) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisName';\n                    textEl.eventData.name = name;\n                }\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n                this.group.add(textEl);\n                textEl.decomposeTransform();\n            }\n        };\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        if (isRadianAroundZero(rotationDiff)) {\n            // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI)) {\n            // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            } else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        } else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            } else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n    }\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n            var rawTick;\n            var scale = axis.scale;\n            return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n        };\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n            var interval = model.get('interval');\n            if (interval == null || interval == 'auto') {\n                interval = labelInterval;\n            }\n            return interval;\n        };\n    return AxisBuilder;\n});\ndefine('zrender', ['zrender/zrender'], function (zrender) { return zrender;});\ndefine('echarts', ['echarts/echarts'], function (echarts) { return echarts;});\nvar echarts = require('echarts');\n\necharts.graphic = require('echarts/util/graphic');\necharts.number = require('echarts/util/number');\necharts.format = require('echarts/util/format');\n\n\nrequire('echarts/chart/bar');\n\nrequire('echarts/chart/pie');\n\n\nrequire('echarts/component/grid');\n\nrequire('echarts/component/title');\n\n\n\n\nreturn echarts;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/echarts.js\n ** module id = 47\n ** module chunks = 2\n **/"],"sourceRoot":""}